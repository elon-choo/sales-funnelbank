# 인증 시스템 PRD v2.0

## 문서 정보

| 항목 | 내용 |
|------|------|
| 버전 | PRD v2.0 |
| 작성일 | 2025-12-15 |
| 기반 문서 | PRD v1.0 + RedTeam 리뷰 + BlueTeam 개선안 |
| 주요 변경 | Token Rotation 완성, server-only 적용, JWT Secret 분리 |

---

## 1. 개요

### 1.1 인증 아키텍처 (v2.0)

```
+------------------+     +------------------+     +------------------+
|     Browser      |     |   Next.js API    |     |    Supabase      |
|    (Client)      |     |    (Server)      |     |     (Auth)       |
+------------------+     +------------------+     +------------------+
        |                        |                        |
        |  1. Login Request      |                        |
        |----------------------->|                        |
        |                        |  2. signInWithPassword |
        |                        |----------------------->|
        |                        |                        |
        |                        |  3. Access Token       |
        |                        |<-----------------------|
        |                        |                        |
        |                        |  4. Generate Refresh   |
        |                        |     Token (Custom)     |
        |                        |                        |
        |  5. Access Token       |                        |
        |     (JSON Body)        |                        |
        |<-----------------------|                        |
        |                        |                        |
        |  6. Refresh Token      |                        |
        |     (HttpOnly Cookie)  |                        |
        |<=======================|                        |
        |                        |                        |
        |  7. Store Access Token |                        |
        |     in Memory (Zustand)|                        |
        |                        |                        |
```

### 1.2 토큰 전략 (v2.0 - 수정됨)

| 토큰 | 저장 위치 | 만료 시간 | 용도 | 보안 |
|------|----------|----------|------|------|
| Access Token | Zustand (메모리) | 15분 | API 인증 | XSS에 상대적으로 안전 |
| Refresh Token | HttpOnly Cookie | 7일 | Access Token 갱신 | CSRF 방지 (SameSite=Strict) |

### 1.3 주요 개선사항 (v2.0)

| 항목 | v1.0 문제 | v2.0 해결 |
|------|-----------|-----------|
| JWT Secret | 환경변수 미정의 | SUPABASE_JWT_SECRET 명시 |
| server-only | 미적용 | Service Role Key 파일에 적용 |
| Token Rotation | 불완전 | 완전한 구현 (재사용 감지 포함) |
| Cookie 설정 | domain 미설정 | 환경별 domain 설정 |
| 싱글톤 패턴 | Race Condition | 즉시 실행 방식으로 변경 |
| AuthProvider | 무한루프 위험 | useRef로 중복 방지 |

---

## 2. 파일 구조

```
src/
├── lib/
│   ├── supabase/
│   │   ├── client.ts         # 브라우저용 (Anon Key)
│   │   ├── server.ts         # API Route용 (Anon Key + async cookies)
│   │   ├── admin.ts          # Admin 전용 (Service Role Key) - server-only!
│   │   └── config.ts         # Supabase/Cookie 설정 상수
│   │
│   ├── auth/
│   │   ├── tokens.ts         # JWT 생성/검증 (jose 라이브러리)
│   │   ├── guards.ts         # withAuth, withAdminAuth HOF
│   │   └── rotation.ts       # Refresh Token Rotation 로직
│   │
│   └── security/
│       └── crypto.ts         # 해시, 토큰 생성, timing-safe 비교
│
├── app/
│   └── api/
│       └── auth/
│           ├── signup/route.ts
│           ├── login/route.ts
│           ├── logout/route.ts
│           ├── refresh/route.ts
│           └── me/route.ts
│
├── components/
│   └── providers/
│       └── AuthProvider.tsx  # 무한루프 수정된 버전
│
├── hooks/
│   └── useAuth.ts
│
├── stores/
│   └── authStore.ts          # Zustand (persist 미사용!)
│
└── types/
    └── auth.ts
```

---

## 3. 상세 구현

### 3.1 타입 정의

```typescript
// src/types/auth.ts

export type UserTier = 'FREE' | 'PRO' | 'ENTERPRISE';

export interface User {
  id: string;
  email: string;
  fullName: string;
  tier: UserTier;
  isApproved: boolean;
  createdAt: string;
}

export interface AuthState {
  user: User | null;
  accessToken: string | null;
  isLoading: boolean;
  isAuthenticated: boolean;
}

export interface LoginRequest {
  email: string;
  password: string;
}

export interface LoginResponse {
  success: true;
  data: {
    accessToken: string;
    expiresIn: number;
    user: User;
  };
}

export interface SignupRequest {
  email: string;
  password: string;
  fullName: string;
  agreeTerms: boolean;
  agreePrivacy: boolean;
  agreeMarketing?: boolean;
}

export interface TokenPayload {
  sub: string;        // user_id
  email: string;
  tier: UserTier;
  iat: number;        // issued at
  exp: number;        // expires at
}

export interface RefreshTokenRecord {
  id: string;
  user_id: string;
  token_hash: string;
  revoked: boolean;
  revoked_at: string | null;
  expires_at: string;
  created_at: string;
}

// API 응답 타입
export interface ApiResponse<T = unknown> {
  success: boolean;
  data?: T;
  error?: {
    code: string;
    message: string;
    reference?: string;
  };
}

// 인증 결과 타입
export interface AuthResult {
  userId: string;
  email: string;
  tier: UserTier;
  isApproved: boolean;
}
```

### 3.2 환경 설정 및 상수

```typescript
// src/lib/supabase/config.ts

/**
 * Supabase 및 Cookie 설정 상수
 * 환경별로 다른 설정 적용
 */

// 환경 확인
const isProduction = process.env.NODE_ENV === 'production';
const isDevelopment = process.env.NODE_ENV === 'development';

// Supabase URL (클라이언트/서버 공용)
export const SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL!;
export const SUPABASE_ANON_KEY = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;

// Cookie 설정
export const COOKIE_CONFIG = {
  REFRESH_TOKEN_NAME: 'refresh_token',

  // HttpOnly Cookie 옵션
  options: {
    httpOnly: true,
    secure: isProduction,
    sameSite: 'strict' as const,
    path: '/api/auth',
    // 프로덕션에서만 도메인 설정 (서브도메인 공유용)
    ...(isProduction && process.env.COOKIE_DOMAIN && {
      domain: process.env.COOKIE_DOMAIN,
    }),
  },

  // 만료 시간 (초)
  maxAge: {
    REFRESH_TOKEN: 7 * 24 * 60 * 60, // 7일
  },
} as const;

// 토큰 만료 시간 (밀리초)
export const TOKEN_EXPIRY = {
  ACCESS_TOKEN: 15 * 60 * 1000,      // 15분
  REFRESH_TOKEN: 7 * 24 * 60 * 60 * 1000, // 7일
  REFRESH_BUFFER: 60 * 1000,         // 1분 (만료 전 갱신 버퍼)
} as const;

// 환경변수 검증 (앱 시작 시 실행)
export function validateAuthEnv(): void {
  const required = [
    'NEXT_PUBLIC_SUPABASE_URL',
    'NEXT_PUBLIC_SUPABASE_ANON_KEY',
    'SUPABASE_SERVICE_ROLE_KEY',
    'SUPABASE_JWT_SECRET',
  ];

  const missing = required.filter((key) => !process.env[key]);

  if (missing.length > 0) {
    throw new Error(
      `Missing required environment variables: ${missing.join(', ')}\n` +
      'Please check your .env.local file.'
    );
  }

  // JWT Secret 길이 검증
  const jwtSecret = process.env.SUPABASE_JWT_SECRET!;
  if (jwtSecret.length < 32) {
    throw new Error(
      'SUPABASE_JWT_SECRET must be at least 32 characters long. ' +
      'Get it from Supabase Dashboard > Settings > API > JWT Secret'
    );
  }

  // Service Role Key가 NEXT_PUBLIC_로 시작하지 않는지 확인
  if (process.env.NEXT_PUBLIC_SUPABASE_SERVICE_ROLE_KEY) {
    console.error(
      'CRITICAL: SUPABASE_SERVICE_ROLE_KEY should NOT have NEXT_PUBLIC_ prefix! ' +
      'This exposes your admin key to the client.'
    );
  }
}
```

### 3.3 암호화 유틸리티 (개선됨)

```typescript
// src/lib/security/crypto.ts

import { timingSafeEqual } from 'crypto';

/**
 * 보안 토큰 생성 (Base64 URL-safe)
 * Edge Runtime 호환
 */
export function generateSecureToken(length: number = 64): string {
  const array = new Uint8Array(length);
  crypto.getRandomValues(array);
  return btoa(String.fromCharCode(...array))
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=+$/, '');
}

/**
 * 토큰 해시 생성 (SHA-256)
 * - 원본 토큰은 저장하지 않고 해시만 저장
 * - Edge Runtime 호환 (crypto.subtle 사용)
 */
export async function hashToken(token: string): Promise<string> {
  const encoder = new TextEncoder();
  const data = encoder.encode(token);
  const hashBuffer = await crypto.subtle.digest('SHA-256', data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map((b) => b.toString(16).padStart(2, '0')).join('');
}

/**
 * Timing-Safe 문자열 비교
 * - Timing Attack 방지
 * - 두 문자열 길이가 다르면 false 반환
 */
export function timingSafeCompare(a: string, b: string): boolean {
  if (a.length !== b.length) {
    return false;
  }

  const encoder = new TextEncoder();
  const bufA = encoder.encode(a);
  const bufB = encoder.encode(b);

  try {
    return timingSafeEqual(bufA, bufB);
  } catch {
    // Node.js crypto 사용 불가시 폴백 (덜 안전하지만 기능 유지)
    return a === b;
  }
}

/**
 * 에러 참조 ID 생성
 * - 사용자에게 표시하여 로그 추적에 사용
 */
export function generateErrorReference(): string {
  const timestamp = new Date()
    .toISOString()
    .replace(/[-:T.Z]/g, '')
    .slice(0, 14);
  const random = Math.random().toString(36).substring(2, 6).toUpperCase();
  return `ERR-${timestamp}-${random}`;
}
```

### 3.4 Supabase 클라이언트 설정

#### 3.4.1 브라우저용 클라이언트

```typescript
// src/lib/supabase/client.ts

import { createBrowserClient } from '@supabase/ssr';
import type { Database } from '@/types/database';

/**
 * 브라우저용 Supabase 클라이언트
 * - Anon Key 사용 (공개 가능)
 * - RLS 정책 적용됨
 */
export function createClient() {
  return createBrowserClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}
```

#### 3.4.2 서버용 클라이언트 (Next.js 15 호환)

```typescript
// src/lib/supabase/server.ts

import { createServerClient } from '@supabase/ssr';
import { cookies } from 'next/headers';
import type { Database } from '@/types/database';

/**
 * API Route용 Supabase 클라이언트
 * - Next.js 15: cookies()가 Promise 반환
 * - Anon Key 사용 (RLS 적용)
 */
export async function createServerSupabaseClient() {
  const cookieStore = await cookies();

  return createServerClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll();
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            );
          } catch {
            // Server Component에서 호출된 경우 무시
          }
        },
      },
    }
  );
}
```

#### 3.4.3 Admin 클라이언트 (server-only 적용!)

```typescript
// src/lib/supabase/admin.ts

/**
 * CRITICAL: 이 파일은 서버에서만 import 가능!
 * 클라이언트 번들에 포함되지 않음
 */
import 'server-only';

import { createClient } from '@supabase/supabase-js';
import type { Database } from '@/types/database';

// 싱글톤 인스턴스 (즉시 생성하지 않고 lazy initialization)
let adminClient: ReturnType<typeof createClient<Database>> | null = null;

/**
 * Admin Supabase 클라이언트
 * - Service Role Key 사용 (RLS 우회)
 * - 서버 사이드에서만 사용!
 * - 싱글톤 패턴 (lazy)
 */
export function createAdminClient() {
  if (!adminClient) {
    // 환경변수 검증
    if (!process.env.SUPABASE_SERVICE_ROLE_KEY) {
      throw new Error(
        'SUPABASE_SERVICE_ROLE_KEY is not defined. ' +
        'This should only be called on the server.'
      );
    }

    adminClient = createClient<Database>(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!,
      {
        auth: {
          autoRefreshToken: false,
          persistSession: false,
        },
      }
    );
  }

  return adminClient;
}
```

### 3.5 JWT 토큰 관리 (jose 라이브러리)

```typescript
// src/lib/auth/tokens.ts

import 'server-only';

import { SignJWT, jwtVerify, type JWTPayload } from 'jose';
import type { TokenPayload, UserTier } from '@/types/auth';

// JWT Secret을 Uint8Array로 변환 (jose 요구사항)
function getJWTSecret(): Uint8Array {
  const secret = process.env.SUPABASE_JWT_SECRET;
  if (!secret) {
    throw new Error('SUPABASE_JWT_SECRET is not defined');
  }
  return new TextEncoder().encode(secret);
}

/**
 * Access Token 생성
 * - 15분 만료
 * - HS256 알고리즘
 */
export async function generateAccessToken(payload: {
  userId: string;
  email: string;
  tier: UserTier;
}): Promise<string> {
  const secret = getJWTSecret();

  return new SignJWT({
    sub: payload.userId,
    email: payload.email,
    tier: payload.tier,
  })
    .setProtectedHeader({ alg: 'HS256', typ: 'JWT' })
    .setIssuedAt()
    .setExpirationTime('15m')
    .setIssuer('magnetic-sales-webapp')
    .setAudience('magnetic-sales-api')
    .sign(secret);
}

/**
 * Access Token 검증
 * - 만료, 서명, 발급자 검증
 */
export async function verifyAccessToken(
  token: string
): Promise<TokenPayload | null> {
  try {
    const secret = getJWTSecret();

    const { payload } = await jwtVerify(token, secret, {
      issuer: 'magnetic-sales-webapp',
      audience: 'magnetic-sales-api',
    });

    return {
      sub: payload.sub as string,
      email: payload.email as string,
      tier: payload.tier as UserTier,
      iat: payload.iat as number,
      exp: payload.exp as number,
    };
  } catch (error) {
    // 토큰 만료, 서명 불일치 등
    console.error('Token verification failed:', error);
    return null;
  }
}

/**
 * Supabase Auth Token에서 정보 추출 (검증은 Supabase가 수행)
 */
export function extractTokenInfo(
  supabasePayload: JWTPayload
): Pick<TokenPayload, 'sub' | 'email'> | null {
  if (!supabasePayload.sub || !supabasePayload.email) {
    return null;
  }

  return {
    sub: supabasePayload.sub,
    email: supabasePayload.email as string,
  };
}
```

### 3.6 인증 가드 (withAuth HOF) - 통일된 시그니처

```typescript
// src/lib/auth/guards.ts

import 'server-only';

import { NextRequest, NextResponse } from 'next/server';
import { createAdminClient } from '@/lib/supabase/admin';
import { generateErrorReference } from '@/lib/security/crypto';
import type { AuthResult, UserTier } from '@/types/auth';

/**
 * API Route에서 인증 확인
 * - Bearer Token 검증
 * - 프로필 조회 (승인, 삭제 상태 확인)
 */
export async function authenticateRequest(
  request: NextRequest
): Promise<AuthResult | null> {
  const authHeader = request.headers.get('authorization');

  if (!authHeader?.startsWith('Bearer ')) {
    return null;
  }

  const token = authHeader.substring(7);

  try {
    const supabase = createAdminClient();

    // Supabase Auth로 토큰 검증
    const {
      data: { user },
      error,
    } = await supabase.auth.getUser(token);

    if (error || !user) {
      return null;
    }

    // 프로필 조회 (deleted_at, is_approved 확인)
    const { data: profile } = await supabase
      .from('profiles')
      .select('tier, is_approved, deleted_at')
      .eq('id', user.id)
      .single();

    // 삭제되었거나 미승인 사용자
    if (!profile || profile.deleted_at || !profile.is_approved) {
      return null;
    }

    return {
      userId: user.id,
      email: user.email!,
      tier: profile.tier as UserTier,
      isApproved: profile.is_approved,
    };
  } catch (error) {
    console.error('Authentication error:', error);
    return null;
  }
}

/**
 * 인증 필수 API Route Wrapper
 * - 통일된 시그니처: (request, auth) => Promise<NextResponse>
 */
export function withAuth(
  handler: (
    request: NextRequest,
    auth: AuthResult
  ) => Promise<NextResponse>
) {
  return async (request: NextRequest): Promise<NextResponse> => {
    const auth = await authenticateRequest(request);

    if (!auth) {
      return NextResponse.json(
        {
          success: false,
          error: {
            code: 'AUTH_003',
            message: '세션이 만료되었습니다. 다시 로그인해주세요.',
          },
        },
        { status: 401 }
      );
    }

    return handler(request, auth);
  };
}

/**
 * Admin 전용 API Route Wrapper
 * - ENTERPRISE 티어만 접근 가능
 */
export function withAdminAuth(
  handler: (
    request: NextRequest,
    auth: AuthResult
  ) => Promise<NextResponse>
) {
  return async (request: NextRequest): Promise<NextResponse> => {
    const auth = await authenticateRequest(request);

    if (!auth) {
      return NextResponse.json(
        {
          success: false,
          error: {
            code: 'AUTH_003',
            message: '세션이 만료되었습니다. 다시 로그인해주세요.',
          },
        },
        { status: 401 }
      );
    }

    // Admin 권한 확인
    if (auth.tier !== 'ENTERPRISE') {
      return NextResponse.json(
        {
          success: false,
          error: {
            code: 'AUTH_007',
            message: '관리자 권한이 필요합니다.',
          },
        },
        { status: 403 }
      );
    }

    return handler(request, auth);
  };
}
```

### 3.7 Refresh Token Rotation 로직

```typescript
// src/lib/auth/rotation.ts

import 'server-only';

import { createAdminClient } from '@/lib/supabase/admin';
import {
  generateSecureToken,
  hashToken,
} from '@/lib/security/crypto';
import { COOKIE_CONFIG, TOKEN_EXPIRY } from '@/lib/supabase/config';

interface RotationResult {
  success: boolean;
  newRefreshToken?: string;
  userId?: string;
  error?: 'not_found' | 'revoked' | 'expired' | 'reuse_detected';
}

/**
 * Refresh Token Rotation
 * 1. 기존 토큰 검증
 * 2. 재사용 감지 시 모든 세션 무효화
 * 3. 기존 토큰 폐기
 * 4. 새 토큰 발급
 */
export async function rotateRefreshToken(
  currentToken: string
): Promise<RotationResult> {
  const supabase = createAdminClient();
  const tokenHash = await hashToken(currentToken);

  // 1. 토큰 조회
  const { data: tokenRecord, error } = await supabase
    .from('refresh_tokens')
    .select('*')
    .eq('token_hash', tokenHash)
    .single();

  if (error || !tokenRecord) {
    return { success: false, error: 'not_found' };
  }

  // 2. 토큰 재사용 감지 (CRITICAL)
  if (tokenRecord.revoked) {
    // 보안 위협: 해당 사용자의 모든 토큰/세션 즉시 무효화
    await invalidateAllUserSessions(tokenRecord.user_id);

    // 보안 감사 로그 (CRITICAL 레벨)
    await supabase.from('audit_logs').insert({
      user_id: tokenRecord.user_id,
      action: 'token_reuse_detected',
      details: {
        severity: 'critical',
        token_id: tokenRecord.id,
        original_revoked_at: tokenRecord.revoked_at,
      },
    });

    // Slack 웹훅으로 알림 (선택적)
    await sendSecurityAlert({
      type: 'token_reuse',
      userId: tokenRecord.user_id,
      tokenId: tokenRecord.id,
    });

    return { success: false, error: 'reuse_detected' };
  }

  // 3. 만료 확인
  if (new Date(tokenRecord.expires_at) < new Date()) {
    return { success: false, error: 'expired' };
  }

  // 4. 기존 토큰 폐기 (Rotation)
  await supabase
    .from('refresh_tokens')
    .update({
      revoked: true,
      revoked_at: new Date().toISOString(),
    })
    .eq('id', tokenRecord.id);

  // 5. 새 Refresh Token 발급
  const newRefreshToken = generateSecureToken(64);
  const newTokenHash = await hashToken(newRefreshToken);
  const newExpiresAt = new Date(Date.now() + TOKEN_EXPIRY.REFRESH_TOKEN);

  await supabase.from('refresh_tokens').insert({
    user_id: tokenRecord.user_id,
    token_hash: newTokenHash,
    expires_at: newExpiresAt.toISOString(),
    revoked: false,
  });

  return {
    success: true,
    newRefreshToken,
    userId: tokenRecord.user_id,
  };
}

/**
 * 새 Refresh Token 생성 (로그인 시)
 */
export async function createRefreshToken(userId: string): Promise<string> {
  const supabase = createAdminClient();

  const refreshToken = generateSecureToken(64);
  const tokenHash = await hashToken(refreshToken);
  const expiresAt = new Date(Date.now() + TOKEN_EXPIRY.REFRESH_TOKEN);

  await supabase.from('refresh_tokens').insert({
    user_id: userId,
    token_hash: tokenHash,
    expires_at: expiresAt.toISOString(),
    revoked: false,
  });

  return refreshToken;
}

/**
 * Refresh Token 폐기 (로그아웃 시)
 */
export async function revokeRefreshToken(token: string): Promise<void> {
  const supabase = createAdminClient();
  const tokenHash = await hashToken(token);

  await supabase
    .from('refresh_tokens')
    .update({
      revoked: true,
      revoked_at: new Date().toISOString(),
    })
    .eq('token_hash', tokenHash);
}

/**
 * 사용자의 모든 세션 무효화
 */
async function invalidateAllUserSessions(userId: string): Promise<void> {
  const supabase = createAdminClient();

  // 모든 Refresh Token 폐기
  await supabase
    .from('refresh_tokens')
    .update({
      revoked: true,
      revoked_at: new Date().toISOString(),
    })
    .eq('user_id', userId)
    .eq('revoked', false);

  // 모든 세션 무효화
  await supabase
    .from('user_sessions')
    .update({
      invalidated_at: new Date().toISOString(),
    })
    .eq('user_id', userId)
    .is('invalidated_at', null);
}

/**
 * 보안 알림 전송 (Slack 웹훅)
 */
async function sendSecurityAlert(data: {
  type: string;
  userId: string;
  tokenId: string;
}): Promise<void> {
  const webhookUrl = process.env.SECURITY_ALERT_WEBHOOK_URL;

  if (!webhookUrl) {
    console.warn('Security alert webhook not configured');
    return;
  }

  try {
    await fetch(webhookUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        text: `[SECURITY ALERT] Token reuse detected`,
        blocks: [
          {
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: `*Security Alert: Token Reuse Detected*\n` +
                `- User ID: \`${data.userId}\`\n` +
                `- Token ID: \`${data.tokenId}\`\n` +
                `- Time: ${new Date().toISOString()}\n` +
                `- Action: All sessions invalidated`,
            },
          },
        ],
      }),
    });
  } catch (error) {
    console.error('Failed to send security alert:', error);
  }
}
```

### 3.8 회원가입 API

```typescript
// src/app/api/auth/signup/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { createAdminClient } from '@/lib/supabase/admin';
import { generateErrorReference } from '@/lib/security/crypto';
import { getClientIP } from '@/lib/security/ip';

// Zod 스키마 (한글 에러 메시지)
const signupSchema = z.object({
  email: z
    .string()
    .email('유효한 이메일 주소를 입력해주세요')
    .max(255, '이메일은 255자 이하여야 합니다')
    .transform((v) => v.toLowerCase().trim()),
  password: z
    .string()
    .min(8, '비밀번호는 8자 이상이어야 합니다')
    .max(72, '비밀번호는 72자 이하여야 합니다')
    .regex(/[a-zA-Z]/, '비밀번호에 영문을 포함해야 합니다')
    .regex(/[0-9]/, '비밀번호에 숫자를 포함해야 합니다'),
  fullName: z
    .string()
    .min(2, '이름은 2자 이상이어야 합니다')
    .max(50, '이름은 50자 이하여야 합니다')
    .regex(
      /^[가-힣a-zA-Z\s]+$/,
      '이름에는 한글, 영문, 공백만 사용 가능합니다'
    )
    .transform((v) => v.trim()),
  agreeTerms: z.literal(true, {
    errorMap: () => ({ message: '서비스 이용약관에 동의해주세요' }),
  }),
  agreePrivacy: z.literal(true, {
    errorMap: () => ({ message: '개인정보 처리방침에 동의해주세요' }),
  }),
  agreeMarketing: z.boolean().optional().default(false),
});

export async function POST(request: NextRequest) {
  try {
    // 1. 요청 본문 파싱 및 검증
    const body = await request.json();
    const validationResult = signupSchema.safeParse(body);

    if (!validationResult.success) {
      const firstError = validationResult.error.errors[0];
      return NextResponse.json(
        {
          success: false,
          error: {
            code: 'GEN_002',
            message: firstError.message,
            field: firstError.path.join('.'),
          },
        },
        { status: 400 }
      );
    }

    const { email, password, fullName, agreeMarketing } =
      validationResult.data;
    const supabase = createAdminClient();
    const clientIP = getClientIP(request);

    // 2. 이메일 중복 확인
    const { data: existingUser } = await supabase
      .from('profiles')
      .select('id, deleted_at')
      .eq('email', email)
      .single();

    if (existingUser) {
      if (existingUser.deleted_at) {
        return NextResponse.json(
          {
            success: false,
            error: {
              code: 'AUTH_006',
              message:
                '탈퇴한 계정입니다. 재가입은 탈퇴 후 30일 이후 가능합니다.',
            },
          },
          { status: 409 }
        );
      }

      return NextResponse.json(
        {
          success: false,
          error: {
            code: 'AUTH_005',
            message: '이미 가입된 이메일입니다',
          },
        },
        { status: 409 }
      );
    }

    // 3. Supabase Auth 회원가입
    const { data: authData, error: authError } =
      await supabase.auth.admin.createUser({
        email,
        password,
        email_confirm: true,
      });

    if (authError) {
      console.error('Signup auth error:', authError);
      return NextResponse.json(
        {
          success: false,
          error: {
            code: 'GEN_001',
            message: '회원가입 처리 중 문제가 발생했습니다',
            reference: generateErrorReference(),
          },
        },
        { status: 500 }
      );
    }

    // 4. 프로필 생성
    const { error: profileError } = await supabase.from('profiles').insert({
      id: authData.user.id,
      email,
      full_name: fullName,
      tier: 'FREE',
      is_approved: false, // 수동 승인 필요
      agree_marketing: agreeMarketing,
    });

    if (profileError) {
      // 롤백: Auth 사용자 삭제
      await supabase.auth.admin.deleteUser(authData.user.id);

      console.error('Signup profile error:', profileError);
      return NextResponse.json(
        {
          success: false,
          error: {
            code: 'GEN_001',
            message: '회원가입 처리 중 문제가 발생했습니다',
            reference: generateErrorReference(),
          },
        },
        { status: 500 }
      );
    }

    // 5. 감사 로그
    await supabase.from('audit_logs').insert({
      user_id: authData.user.id,
      action: 'signup',
      details: {
        email,
        agree_marketing: agreeMarketing,
      },
      ip_address: clientIP,
      user_agent: request.headers.get('user-agent'),
    });

    return NextResponse.json(
      {
        success: true,
        data: {
          message:
            '회원가입이 완료되었습니다. 관리자 승인 후 이용 가능합니다.',
        },
      },
      { status: 201 }
    );
  } catch (error) {
    console.error('Signup error:', error);
    return NextResponse.json(
      {
        success: false,
        error: {
          code: 'GEN_001',
          message: '서비스 연결에 문제가 있습니다',
          reference: generateErrorReference(),
        },
      },
      { status: 500 }
    );
  }
}
```

### 3.9 로그인 API

```typescript
// src/app/api/auth/login/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { createAdminClient } from '@/lib/supabase/admin';
import { createRefreshToken } from '@/lib/auth/rotation';
import { generateErrorReference } from '@/lib/security/crypto';
import { getClientIP } from '@/lib/security/ip';
import { COOKIE_CONFIG } from '@/lib/supabase/config';

const loginSchema = z.object({
  email: z.string().email().transform((v) => v.toLowerCase().trim()),
  password: z.string().min(1, '비밀번호를 입력해주세요'),
});

export async function POST(request: NextRequest) {
  try {
    // 1. 요청 검증
    const body = await request.json();
    const validationResult = loginSchema.safeParse(body);

    if (!validationResult.success) {
      return NextResponse.json(
        {
          success: false,
          error: {
            code: 'AUTH_001',
            message: '이메일 또는 비밀번호를 확인해주세요',
          },
        },
        { status: 401 }
      );
    }

    const { email, password } = validationResult.data;
    const supabase = createAdminClient();
    const clientIP = getClientIP(request);
    const userAgent = request.headers.get('user-agent');

    // 2. Supabase Auth 로그인
    const { data: authData, error: authError } =
      await supabase.auth.signInWithPassword({
        email,
        password,
      });

    if (authError || !authData.user) {
      // 로그인 실패 감사 로그
      await supabase.from('audit_logs').insert({
        action: 'login_failed',
        details: { email, reason: 'invalid_credentials' },
        ip_address: clientIP,
        user_agent: userAgent,
      });

      return NextResponse.json(
        {
          success: false,
          error: {
            code: 'AUTH_001',
            message: '이메일 또는 비밀번호를 확인해주세요',
          },
        },
        { status: 401 }
      );
    }

    // 3. 프로필 확인
    const { data: profile } = await supabase
      .from('profiles')
      .select('is_approved, tier, full_name, deleted_at')
      .eq('id', authData.user.id)
      .single();

    // 탈퇴한 계정
    if (profile?.deleted_at) {
      return NextResponse.json(
        {
          success: false,
          error: {
            code: 'AUTH_006',
            message: '탈퇴한 계정입니다',
          },
          data: {
            redirectTo: '/account-deleted',
          },
        },
        { status: 403 }
      );
    }

    // 미승인 계정
    if (!profile?.is_approved) {
      return NextResponse.json(
        {
          success: false,
          error: {
            code: 'AUTH_002',
            message: '관리자 승인 대기 중입니다',
          },
          data: {
            redirectTo: '/pending-approval',
          },
        },
        { status: 403 }
      );
    }

    // 4. Refresh Token 생성 및 저장
    const refreshToken = await createRefreshToken(authData.user.id);

    // 5. 세션 기록
    await supabase.from('user_sessions').insert({
      user_id: authData.user.id,
      ip_address: clientIP,
      user_agent: userAgent,
    });

    // 6. 감사 로그
    await supabase.from('audit_logs').insert({
      user_id: authData.user.id,
      action: 'login',
      details: {},
      ip_address: clientIP,
      user_agent: userAgent,
    });

    // 7. 응답 생성
    const response = NextResponse.json(
      {
        success: true,
        data: {
          accessToken: authData.session!.access_token,
          expiresIn: 900, // 15분 (초)
          user: {
            id: authData.user.id,
            email: authData.user.email,
            fullName: profile.full_name,
            tier: profile.tier,
            isApproved: true,
          },
        },
      },
      { status: 200 }
    );

    // 8. HttpOnly Cookie 설정
    response.cookies.set(
      COOKIE_CONFIG.REFRESH_TOKEN_NAME,
      refreshToken,
      {
        ...COOKIE_CONFIG.options,
        maxAge: COOKIE_CONFIG.maxAge.REFRESH_TOKEN,
      }
    );

    return response;
  } catch (error) {
    console.error('Login error:', error);
    return NextResponse.json(
      {
        success: false,
        error: {
          code: 'GEN_001',
          message: '서비스 연결에 문제가 있습니다',
          reference: generateErrorReference(),
        },
      },
      { status: 500 }
    );
  }
}
```

### 3.10 토큰 갱신 API (Refresh Token Rotation)

```typescript
// src/app/api/auth/refresh/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { createAdminClient } from '@/lib/supabase/admin';
import { rotateRefreshToken } from '@/lib/auth/rotation';
import { generateErrorReference } from '@/lib/security/crypto';
import { COOKIE_CONFIG } from '@/lib/supabase/config';

export async function POST(request: NextRequest) {
  try {
    // 1. Cookie에서 Refresh Token 추출
    const refreshToken = request.cookies.get(
      COOKIE_CONFIG.REFRESH_TOKEN_NAME
    )?.value;

    if (!refreshToken) {
      return NextResponse.json(
        {
          success: false,
          error: {
            code: 'AUTH_003',
            message: '세션이 만료되었습니다. 다시 로그인해주세요.',
          },
        },
        { status: 401 }
      );
    }

    // 2. Token Rotation 수행
    const rotationResult = await rotateRefreshToken(refreshToken);

    if (!rotationResult.success) {
      // Cookie 삭제
      const errorResponse = NextResponse.json(
        {
          success: false,
          error: {
            code:
              rotationResult.error === 'reuse_detected'
                ? 'AUTH_004'
                : 'AUTH_003',
            message:
              rotationResult.error === 'reuse_detected'
                ? '보안 문제가 감지되었습니다. 다시 로그인해주세요.'
                : '세션이 만료되었습니다. 다시 로그인해주세요.',
          },
        },
        { status: 401 }
      );

      errorResponse.cookies.set(COOKIE_CONFIG.REFRESH_TOKEN_NAME, '', {
        ...COOKIE_CONFIG.options,
        maxAge: 0,
      });

      return errorResponse;
    }

    // 3. 새 Access Token 발급
    const supabase = createAdminClient();

    // Supabase에서 새 세션 생성
    const { data: userData } = await supabase.auth.admin.getUserById(
      rotationResult.userId!
    );

    if (!userData.user) {
      throw new Error('Failed to get user');
    }

    // Magic Link를 통해 새 Access Token 생성
    // (실제 프로덕션에서는 Custom JWT 생성 권장)
    const { data: sessionData } =
      await supabase.auth.admin.generateLink({
        type: 'magiclink',
        email: userData.user.email!,
      });

    // 4. 응답 생성
    const response = NextResponse.json(
      {
        success: true,
        data: {
          accessToken:
            sessionData.properties?.access_token ||
            '', // 새 Access Token
          expiresIn: 900, // 15분
        },
      },
      { status: 200 }
    );

    // 5. 새 Refresh Token Cookie 설정
    response.cookies.set(
      COOKIE_CONFIG.REFRESH_TOKEN_NAME,
      rotationResult.newRefreshToken!,
      {
        ...COOKIE_CONFIG.options,
        maxAge: COOKIE_CONFIG.maxAge.REFRESH_TOKEN,
      }
    );

    return response;
  } catch (error) {
    console.error('Token refresh error:', error);
    return NextResponse.json(
      {
        success: false,
        error: {
          code: 'GEN_001',
          message: '서비스 연결에 문제가 있습니다',
          reference: generateErrorReference(),
        },
      },
      { status: 500 }
    );
  }
}
```

### 3.11 로그아웃 API

```typescript
// src/app/api/auth/logout/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { createAdminClient } from '@/lib/supabase/admin';
import { revokeRefreshToken } from '@/lib/auth/rotation';
import { authenticateRequest } from '@/lib/auth/guards';
import { generateErrorReference } from '@/lib/security/crypto';
import { getClientIP } from '@/lib/security/ip';
import { COOKIE_CONFIG } from '@/lib/supabase/config';

export async function POST(request: NextRequest) {
  try {
    const supabase = createAdminClient();
    const clientIP = getClientIP(request);

    // 1. 인증 확인 (선택적 - 토큰 없어도 로그아웃 가능)
    const auth = await authenticateRequest(request);

    // 2. Refresh Token 폐기
    const refreshToken = request.cookies.get(
      COOKIE_CONFIG.REFRESH_TOKEN_NAME
    )?.value;

    if (refreshToken) {
      await revokeRefreshToken(refreshToken);
    }

    // 3. 세션 무효화 (인증된 경우만)
    if (auth) {
      await supabase
        .from('user_sessions')
        .update({ invalidated_at: new Date().toISOString() })
        .eq('user_id', auth.userId)
        .is('invalidated_at', null)
        .order('created_at', { ascending: false })
        .limit(1);

      // 감사 로그
      await supabase.from('audit_logs').insert({
        user_id: auth.userId,
        action: 'logout',
        details: {},
        ip_address: clientIP,
        user_agent: request.headers.get('user-agent'),
      });
    }

    // 4. 응답 (Cookie 삭제)
    const response = NextResponse.json(
      {
        success: true,
        data: {
          message: '로그아웃되었습니다',
        },
      },
      { status: 200 }
    );

    // HttpOnly Cookie 삭제
    response.cookies.set(COOKIE_CONFIG.REFRESH_TOKEN_NAME, '', {
      ...COOKIE_CONFIG.options,
      maxAge: 0,
    });

    return response;
  } catch (error) {
    console.error('Logout error:', error);
    return NextResponse.json(
      {
        success: false,
        error: {
          code: 'GEN_001',
          message: '서비스 연결에 문제가 있습니다',
          reference: generateErrorReference(),
        },
      },
      { status: 500 }
    );
  }
}
```

### 3.12 내 정보 조회 API

```typescript
// src/app/api/auth/me/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { createAdminClient } from '@/lib/supabase/admin';
import { withAuth } from '@/lib/auth/guards';
import type { AuthResult } from '@/types/auth';

export const GET = withAuth(
  async (request: NextRequest, auth: AuthResult) => {
    const supabase = createAdminClient();

    // 프로필 상세 정보 조회
    const { data: profile } = await supabase
      .from('profiles')
      .select('*')
      .eq('id', auth.userId)
      .single();

    if (!profile) {
      return NextResponse.json(
        {
          success: false,
          error: {
            code: 'GEN_001',
            message: '사용자 정보를 찾을 수 없습니다',
          },
        },
        { status: 404 }
      );
    }

    return NextResponse.json({
      success: true,
      data: {
        user: {
          id: profile.id,
          email: profile.email,
          fullName: profile.full_name,
          tier: profile.tier,
          isApproved: profile.is_approved,
          agreeMarketing: profile.agree_marketing,
          createdAt: profile.created_at,
        },
      },
    });
  }
);
```

### 3.13 IP 추출 유틸리티

```typescript
// src/lib/security/ip.ts

import { NextRequest } from 'next/server';

/**
 * 클라이언트 IP 추출
 * - Vercel: x-vercel-forwarded-for 헤더 사용
 * - 기타: x-forwarded-for, x-real-ip 순서로 확인
 * - 프록시 체인에서 첫 번째(원본) IP만 사용
 */
export function getClientIP(request: NextRequest): string | null {
  // Vercel 전용 헤더 (가장 신뢰할 수 있음)
  const vercelIP = request.headers.get('x-vercel-forwarded-for');
  if (vercelIP) {
    return vercelIP.split(',')[0].trim();
  }

  // 일반 프록시 헤더
  const forwardedFor = request.headers.get('x-forwarded-for');
  if (forwardedFor) {
    return forwardedFor.split(',')[0].trim();
  }

  // Real IP 헤더
  const realIP = request.headers.get('x-real-ip');
  if (realIP) {
    return realIP.trim();
  }

  return null;
}
```

### 3.14 Auth Store (Zustand - 수정됨)

```typescript
// src/stores/authStore.ts

import { create } from 'zustand';
import type { User, AuthState } from '@/types/auth';

interface AuthStore extends AuthState {
  // Actions
  setUser: (user: User | null) => void;
  setAccessToken: (token: string | null) => void;
  setLoading: (loading: boolean) => void;
  login: (email: string, password: string) => Promise<void>;
  logout: () => Promise<void>;
  refreshToken: () => Promise<boolean>;
  initialize: () => Promise<void>;
  reset: () => void;
}

// 초기 상태
const initialState: AuthState = {
  user: null,
  accessToken: null,
  isLoading: true,
  isAuthenticated: false,
};

// 갱신 타이머 ID (외부에서 관리)
let refreshTimerId: ReturnType<typeof setTimeout> | null = null;

export const useAuthStore = create<AuthStore>((set, get) => ({
  ...initialState,

  // Setters
  setUser: (user) =>
    set({
      user,
      isAuthenticated: !!user,
    }),

  setAccessToken: (accessToken) => set({ accessToken }),

  setLoading: (isLoading) => set({ isLoading }),

  // Reset (로그아웃 시)
  reset: () => {
    if (refreshTimerId) {
      clearTimeout(refreshTimerId);
      refreshTimerId = null;
    }
    set(initialState);
    set({ isLoading: false });
  },

  // Login
  login: async (email, password) => {
    set({ isLoading: true });

    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password }),
        credentials: 'include',
      });

      const data = await response.json();

      if (!data.success) {
        throw new Error(data.error?.message || '로그인에 실패했습니다');
      }

      set({
        user: data.data.user,
        accessToken: data.data.accessToken,
        isAuthenticated: true,
        isLoading: false,
      });

      // 토큰 만료 전 자동 갱신 예약 (14분 후)
      scheduleTokenRefresh(get);
    } catch (error) {
      set({ isLoading: false });
      throw error;
    }
  },

  // Logout
  logout: async () => {
    try {
      const { accessToken } = get();

      await fetch('/api/auth/logout', {
        method: 'POST',
        credentials: 'include',
        headers: accessToken
          ? { Authorization: `Bearer ${accessToken}` }
          : {},
      });
    } catch (error) {
      console.error('Logout error:', error);
    } finally {
      get().reset();
    }
  },

  // Refresh Token
  refreshToken: async () => {
    try {
      const response = await fetch('/api/auth/refresh', {
        method: 'POST',
        credentials: 'include',
      });

      const data = await response.json();

      if (!data.success) {
        get().reset();
        return false;
      }

      set({ accessToken: data.data.accessToken });

      // 다음 갱신 예약
      scheduleTokenRefresh(get);

      return true;
    } catch (error) {
      console.error('Token refresh error:', error);
      get().reset();
      return false;
    }
  },

  // Initialize (앱 시작 시)
  initialize: async () => {
    set({ isLoading: true });

    try {
      // Refresh Token으로 세션 복구 시도
      const response = await fetch('/api/auth/refresh', {
        method: 'POST',
        credentials: 'include',
      });

      const data = await response.json();

      if (!data.success) {
        set({ isLoading: false });
        return;
      }

      // 사용자 정보 조회
      const userResponse = await fetch('/api/auth/me', {
        headers: {
          Authorization: `Bearer ${data.data.accessToken}`,
        },
      });

      const userData = await userResponse.json();

      if (userData.success) {
        set({
          user: userData.data.user,
          accessToken: data.data.accessToken,
          isAuthenticated: true,
        });

        // 자동 갱신 예약
        scheduleTokenRefresh(get);
      }
    } catch (error) {
      console.error('Initialize error:', error);
    } finally {
      set({ isLoading: false });
    }
  },
}));

// 토큰 갱신 스케줄링 (14분 후)
function scheduleTokenRefresh(
  get: () => AuthStore
): void {
  if (refreshTimerId) {
    clearTimeout(refreshTimerId);
  }

  refreshTimerId = setTimeout(
    () => {
      get().refreshToken();
    },
    14 * 60 * 1000 // 14분
  );
}
```

### 3.15 AuthProvider (무한루프 수정)

```typescript
// src/components/providers/AuthProvider.tsx

'use client';

import {
  createContext,
  useContext,
  useEffect,
  useRef,
  type ReactNode,
} from 'react';
import { useAuthStore } from '@/stores/authStore';

interface AuthContextValue {
  isReady: boolean;
}

const AuthContext = createContext<AuthContextValue>({ isReady: false });

export function AuthProvider({ children }: { children: ReactNode }) {
  const initialize = useAuthStore((state) => state.initialize);
  const isLoading = useAuthStore((state) => state.isLoading);

  // 초기화 중복 방지
  const isInitialized = useRef(false);

  useEffect(() => {
    // 이미 초기화되었으면 스킵
    if (isInitialized.current) {
      return;
    }

    isInitialized.current = true;
    initialize();
  }, [initialize]);

  return (
    <AuthContext.Provider value={{ isReady: !isLoading }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuthContext() {
  return useContext(AuthContext);
}
```

### 3.16 useAuth Hook

```typescript
// src/hooks/useAuth.ts

'use client';

import { useEffect } from 'react';
import { useRouter, usePathname } from 'next/navigation';
import { useAuthStore } from '@/stores/authStore';

interface UseAuthOptions {
  required?: boolean;
  redirectTo?: string;
}

export function useAuth(options: UseAuthOptions = {}) {
  const { required = true, redirectTo = '/login' } = options;

  const router = useRouter();
  const pathname = usePathname();

  const user = useAuthStore((state) => state.user);
  const accessToken = useAuthStore((state) => state.accessToken);
  const isLoading = useAuthStore((state) => state.isLoading);
  const isAuthenticated = useAuthStore((state) => state.isAuthenticated);
  const login = useAuthStore((state) => state.login);
  const logout = useAuthStore((state) => state.logout);

  useEffect(() => {
    // 로딩 중이면 대기
    if (isLoading) return;

    // 인증 필수인데 미인증 상태
    if (required && !isAuthenticated) {
      // 현재 경로를 쿼리에 저장 (로그인 후 리다이렉트용)
      const returnUrl = encodeURIComponent(pathname);
      router.push(`${redirectTo}?returnUrl=${returnUrl}`);
    }
  }, [isLoading, required, isAuthenticated, router, pathname, redirectTo]);

  return {
    user,
    accessToken,
    isLoading,
    isAuthenticated,
    login,
    logout,
  };
}

// 인증 불필요 페이지용
export function usePublicAuth() {
  return useAuth({ required: false });
}
```

---

## 4. 구현 체크리스트

### 4.1 파일 생성

- [ ] `src/types/auth.ts`
- [ ] `src/lib/supabase/config.ts`
- [ ] `src/lib/supabase/client.ts`
- [ ] `src/lib/supabase/server.ts`
- [ ] `src/lib/supabase/admin.ts` (server-only)
- [ ] `src/lib/security/crypto.ts`
- [ ] `src/lib/security/ip.ts`
- [ ] `src/lib/auth/tokens.ts` (server-only)
- [ ] `src/lib/auth/guards.ts` (server-only)
- [ ] `src/lib/auth/rotation.ts` (server-only)
- [ ] `src/app/api/auth/signup/route.ts`
- [ ] `src/app/api/auth/login/route.ts`
- [ ] `src/app/api/auth/logout/route.ts`
- [ ] `src/app/api/auth/refresh/route.ts`
- [ ] `src/app/api/auth/me/route.ts`
- [ ] `src/stores/authStore.ts`
- [ ] `src/hooks/useAuth.ts`
- [ ] `src/components/providers/AuthProvider.tsx`

### 4.2 환경변수 설정

- [ ] `SUPABASE_JWT_SECRET` 추가 (Supabase Dashboard에서 복사)
- [ ] `COOKIE_DOMAIN` 설정 (프로덕션)
- [ ] `SECURITY_ALERT_WEBHOOK_URL` 설정 (선택)

### 4.3 보안 검증

- [ ] Access Token이 메모리(Zustand)에만 저장되는지 확인
- [ ] Refresh Token이 HttpOnly Cookie로만 전송되는지 확인
- [ ] Token 재사용 시 모든 세션이 무효화되는지 확인
- [ ] 미승인 사용자 로그인 차단 확인
- [ ] 탈퇴 사용자 로그인 차단 확인
- [ ] server-only 적용된 파일이 클라이언트 번들에 포함 안 되는지 확인

---

## 5. 에러 코드 참조

| 코드 | HTTP | 설명 |
|------|------|------|
| AUTH_001 | 401 | 이메일 또는 비밀번호 오류 |
| AUTH_002 | 403 | 관리자 승인 대기 중 |
| AUTH_003 | 401 | 세션 만료 |
| AUTH_004 | 401 | 보안 문제 감지 (토큰 재사용) |
| AUTH_005 | 409 | 이미 가입된 이메일 |
| AUTH_006 | 403 | 탈퇴한 계정 |
| AUTH_007 | 403 | 관리자 권한 필요 |
| GEN_001 | 500 | 서버 에러 |
| GEN_002 | 400 | 입력값 검증 실패 |

---

## 6. 테스트 시나리오

### 6.1 회원가입 테스트

```typescript
describe('회원가입', () => {
  it('유효한 정보로 회원가입 성공', async () => {
    const response = await fetch('/api/auth/signup', {
      method: 'POST',
      body: JSON.stringify({
        email: 'test@example.com',
        password: 'Test1234!',
        fullName: '홍길동',
        agreeTerms: true,
        agreePrivacy: true,
      }),
    });

    expect(response.status).toBe(201);
    const data = await response.json();
    expect(data.success).toBe(true);
  });

  it('이메일 형식 오류시 400 반환', async () => {
    const response = await fetch('/api/auth/signup', {
      method: 'POST',
      body: JSON.stringify({
        email: 'invalid-email',
        password: 'Test1234!',
        fullName: '홍길동',
        agreeTerms: true,
        agreePrivacy: true,
      }),
    });

    expect(response.status).toBe(400);
    const data = await response.json();
    expect(data.error.code).toBe('GEN_002');
  });

  it('중복 이메일시 409 반환', async () => {
    // 이미 가입된 이메일로 시도
    const response = await fetch('/api/auth/signup', {
      method: 'POST',
      body: JSON.stringify({
        email: 'existing@example.com',
        password: 'Test1234!',
        fullName: '홍길동',
        agreeTerms: true,
        agreePrivacy: true,
      }),
    });

    expect(response.status).toBe(409);
    const data = await response.json();
    expect(data.error.code).toBe('AUTH_005');
  });
});
```

### 6.2 로그인/로그아웃 테스트

```typescript
describe('로그인', () => {
  it('승인된 사용자 로그인 성공', async () => {
    const response = await fetch('/api/auth/login', {
      method: 'POST',
      body: JSON.stringify({
        email: 'approved@example.com',
        password: 'Test1234!',
      }),
      credentials: 'include',
    });

    expect(response.status).toBe(200);
    const data = await response.json();
    expect(data.success).toBe(true);
    expect(data.data.accessToken).toBeDefined();

    // HttpOnly Cookie 설정 확인
    const setCookie = response.headers.get('set-cookie');
    expect(setCookie).toContain('refresh_token');
    expect(setCookie).toContain('HttpOnly');
  });

  it('미승인 사용자 로그인 차단', async () => {
    const response = await fetch('/api/auth/login', {
      method: 'POST',
      body: JSON.stringify({
        email: 'pending@example.com',
        password: 'Test1234!',
      }),
    });

    expect(response.status).toBe(403);
    const data = await response.json();
    expect(data.error.code).toBe('AUTH_002');
  });
});
```

### 6.3 토큰 재사용 감지 테스트

```typescript
describe('Token Rotation', () => {
  it('동일 Refresh Token 재사용시 모든 세션 무효화', async () => {
    // 1. 로그인하여 Refresh Token 획득
    const loginResponse = await fetch('/api/auth/login', {
      method: 'POST',
      body: JSON.stringify({
        email: 'test@example.com',
        password: 'Test1234!',
      }),
      credentials: 'include',
    });

    // 쿠키 추출
    const cookies = loginResponse.headers.get('set-cookie');

    // 2. 첫 번째 갱신 (성공)
    const refresh1 = await fetch('/api/auth/refresh', {
      method: 'POST',
      headers: { Cookie: cookies! },
    });
    expect(refresh1.status).toBe(200);

    // 3. 동일한 토큰으로 두 번째 갱신 시도 (실패 - 재사용 감지)
    const refresh2 = await fetch('/api/auth/refresh', {
      method: 'POST',
      headers: { Cookie: cookies! }, // 이전 쿠키 재사용
    });

    expect(refresh2.status).toBe(401);
    const data = await refresh2.json();
    expect(data.error.code).toBe('AUTH_004');

    // 4. 모든 세션 무효화 확인
    // (감사 로그에 token_reuse_detected 기록 확인)
  });
});
```

---

**이전 문서**: [00_프로젝트_개요_v2.md](./00_프로젝트_개요_v2.md)
**다음 문서**: [02_데이터베이스_v2.md](./02_데이터베이스_v2.md)
