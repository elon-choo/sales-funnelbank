# 데이터베이스 PRD v2.0

## 문서 정보

| 항목 | 내용 |
|------|------|
| 버전 | PRD v2.0 |
| 작성일 | 2025-12-15 |
| 기반 문서 | PRD v1.0 + RedTeam 리뷰 + BlueTeam 개선안 |
| 데이터베이스 | PostgreSQL 15 (Supabase) |
| 주요 변경 | RLS 통합, Advisory Lock 수정, 스키마 정규화 |

---

## 1. 개요

### 1.1 ER 다이어그램 (v2.0)

```
┌──────────────────────────────────────────────────────────────────────────┐
│                           AUTHENTICATION                                  │
├──────────────────────────────────────────────────────────────────────────┤
│                                                                           │
│  ┌─────────────┐         ┌─────────────────┐         ┌───────────────┐   │
│  │ auth.users  │────────>│    profiles     │────────>│refresh_tokens │   │
│  │ (Supabase)  │   1:1   │                 │   1:N   │               │   │
│  └─────────────┘         └─────────────────┘         └───────────────┘   │
│                                  │                                        │
│                                  │ 1:N                                    │
│                                  ▼                                        │
│                          ┌─────────────────┐                              │
│                          │  user_sessions  │                              │
│                          └─────────────────┘                              │
│                                                                           │
└──────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────┐
│                            CORE BUSINESS                                  │
├──────────────────────────────────────────────────────────────────────────┤
│                                                                           │
│  ┌─────────────┐         ┌─────────────────┐         ┌───────────────┐   │
│  │  profiles   │────────>│  landing_pages  │<────────│  qa_sessions  │   │
│  │             │   1:N   │                 │   1:1   │               │   │
│  └─────────────┘         └─────────────────┘         └───────────────┘   │
│         │                        │                          │             │
│         │ 1:N                    │                          │             │
│         ▼                        │                          │             │
│  ┌─────────────┐                 │                          │             │
│  │ token_usage │                 │                          │             │
│  └─────────────┘                 │                          │             │
│         ▲                        │                          │             │
│         │                        │                          │             │
│  ┌──────┴──────┐                 │                          │             │
│  │   token_    │                 │                          │             │
│  │reservations │                 │                          │             │
│  └─────────────┘                 │                          │             │
│                                  │                          │             │
└──────────────────────────────────┴──────────────────────────┘             │

┌──────────────────────────────────────────────────────────────────────────┐
│                          SYSTEM / AUDIT                                   │
├──────────────────────────────────────────────────────────────────────────┤
│                                                                           │
│  ┌─────────────┐         ┌─────────────────┐         ┌───────────────┐   │
│  │ audit_logs  │         │   rate_limits   │         │security_events│   │
│  └─────────────┘         └─────────────────┘         └───────────────┘   │
│                                                                           │
└──────────────────────────────────────────────────────────────────────────┘
```

### 1.2 테이블 목록 (v2.0)

| 테이블명 | 설명 | v2.0 변경사항 |
|----------|------|---------------|
| profiles | 사용자 프로필 | approval_changed_at 추가 |
| landing_pages | 랜딩페이지 | 기존 유지 |
| qa_sessions | Q&A 세션 | 기존 유지 |
| token_usage | 토큰 사용 기록 | reservation_id 추가 |
| token_reservations | 토큰 예약 | error_reason 추가 |
| refresh_tokens | Refresh Token | 기존 유지 |
| audit_logs | 감사 로그 | severity 컬럼 추가 |
| user_sessions | 사용자 세션 | device_info 추가 |
| rate_limits | Rate Limit | 기존 유지 |
| security_events | 보안 이벤트 | **신규** |

---

## 2. 마이그레이션 파일 (v2.0)

### 2.1 파일 구조

```
supabase/
└── migrations/
    ├── 001_initial_schema.sql      # 기본 테이블
    ├── 002_soft_delete.sql         # Soft Delete
    ├── 003_refresh_tokens.sql      # 인증 토큰
    ├── 004_audit_logs.sql          # 감사 로그
    ├── 005_rate_limits.sql         # Rate Limiting
    ├── 006_token_reservations.sql  # 토큰 예약
    ├── 007_functions_triggers.sql  # 함수/트리거
    ├── 008_rls_policies.sql        # RLS 정책 통합 (v2.0 신규)
    └── 009_schema_fixes.sql        # v2.0 스키마 수정
```

### 2.2 001_initial_schema.sql

```sql
-- ============================================
-- 001_initial_schema.sql
-- 기본 테이블 생성
-- ============================================

-- updated_at 자동 갱신 함수
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- profiles 테이블
-- ============================================
CREATE TABLE IF NOT EXISTS profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT NOT NULL,
    tier TEXT NOT NULL DEFAULT 'FREE' CHECK (tier IN ('FREE', 'PRO', 'ENTERPRISE')),
    is_approved BOOLEAN NOT NULL DEFAULT FALSE,
    agree_marketing BOOLEAN NOT NULL DEFAULT FALSE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 인덱스
CREATE INDEX IF NOT EXISTS idx_profiles_email ON profiles(email);
CREATE INDEX IF NOT EXISTS idx_profiles_tier ON profiles(tier);
CREATE INDEX IF NOT EXISTS idx_profiles_is_approved ON profiles(is_approved);

-- updated_at 트리거
CREATE TRIGGER update_profiles_updated_at
    BEFORE UPDATE ON profiles
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- RLS 활성화
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;

-- ============================================
-- landing_pages 테이블
-- ============================================
CREATE TABLE IF NOT EXISTS landing_pages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
    qa_session_id UUID,
    title TEXT NOT NULL,
    content JSONB NOT NULL DEFAULT '{}',
    status TEXT NOT NULL DEFAULT 'draft' CHECK (status IN ('draft', 'published', 'archived')),
    slug TEXT UNIQUE,
    published_url TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 인덱스
CREATE INDEX IF NOT EXISTS idx_landing_pages_user_id ON landing_pages(user_id);
CREATE INDEX IF NOT EXISTS idx_landing_pages_status ON landing_pages(status);
CREATE INDEX IF NOT EXISTS idx_landing_pages_slug ON landing_pages(slug);
CREATE INDEX IF NOT EXISTS idx_landing_pages_created_at ON landing_pages(created_at DESC);

-- updated_at 트리거
CREATE TRIGGER update_landing_pages_updated_at
    BEFORE UPDATE ON landing_pages
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- RLS 활성화
ALTER TABLE landing_pages ENABLE ROW LEVEL SECURITY;

-- ============================================
-- qa_sessions 테이블
-- ============================================
CREATE TABLE IF NOT EXISTS qa_sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
    landing_page_id UUID REFERENCES landing_pages(id) ON DELETE SET NULL,
    answers JSONB NOT NULL DEFAULT '{}',
    current_step INTEGER NOT NULL DEFAULT 1 CHECK (current_step BETWEEN 1 AND 40),
    status TEXT NOT NULL DEFAULT 'in_progress' CHECK (status IN ('in_progress', 'completed', 'abandoned')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- landing_pages FK 추가
ALTER TABLE landing_pages
ADD CONSTRAINT fk_landing_pages_qa_session
FOREIGN KEY (qa_session_id) REFERENCES qa_sessions(id) ON DELETE SET NULL;

-- 인덱스
CREATE INDEX IF NOT EXISTS idx_qa_sessions_user_id ON qa_sessions(user_id);
CREATE INDEX IF NOT EXISTS idx_qa_sessions_status ON qa_sessions(status);
CREATE INDEX IF NOT EXISTS idx_qa_sessions_landing_page_id ON qa_sessions(landing_page_id);

-- updated_at 트리거
CREATE TRIGGER update_qa_sessions_updated_at
    BEFORE UPDATE ON qa_sessions
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- RLS 활성화
ALTER TABLE qa_sessions ENABLE ROW LEVEL SECURITY;

-- ============================================
-- token_usage 테이블
-- ============================================
CREATE TABLE IF NOT EXISTS token_usage (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
    tokens_used INTEGER NOT NULL CHECK (tokens_used > 0),
    action TEXT NOT NULL CHECK (action IN ('generate', 'regenerate', 'edit')),
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 인덱스
CREATE INDEX IF NOT EXISTS idx_token_usage_user_id ON token_usage(user_id);
CREATE INDEX IF NOT EXISTS idx_token_usage_created_at ON token_usage(created_at);
-- 일일 토큰 사용량 조회 최적화
CREATE INDEX IF NOT EXISTS idx_token_usage_user_date
    ON token_usage(user_id, (created_at::DATE));

-- RLS 활성화
ALTER TABLE token_usage ENABLE ROW LEVEL SECURITY;
```

### 2.3 002_soft_delete.sql

```sql
-- ============================================
-- 002_soft_delete.sql
-- Soft Delete 컬럼 추가
-- ============================================

-- profiles에 deleted_at 추가
ALTER TABLE profiles ADD COLUMN IF NOT EXISTS deleted_at TIMESTAMPTZ;
-- 부분 인덱스: 삭제되지 않은 레코드만
CREATE INDEX IF NOT EXISTS idx_profiles_active
    ON profiles(id) WHERE deleted_at IS NULL;

-- landing_pages에 deleted_at 추가
ALTER TABLE landing_pages ADD COLUMN IF NOT EXISTS deleted_at TIMESTAMPTZ;
-- 복합 인덱스: 사용자별 활성 랜딩페이지
CREATE INDEX IF NOT EXISTS idx_landing_pages_user_active
    ON landing_pages(user_id, created_at DESC) WHERE deleted_at IS NULL;
-- 복합 인덱스: 삭제된 랜딩페이지 (30일 이내)
CREATE INDEX IF NOT EXISTS idx_landing_pages_deleted_recovery
    ON landing_pages(user_id, deleted_at)
    WHERE deleted_at IS NOT NULL;

-- qa_sessions에 deleted_at 추가
ALTER TABLE qa_sessions ADD COLUMN IF NOT EXISTS deleted_at TIMESTAMPTZ;
CREATE INDEX IF NOT EXISTS idx_qa_sessions_active
    ON qa_sessions(user_id) WHERE deleted_at IS NULL;
```

### 2.4 003_refresh_tokens.sql

```sql
-- ============================================
-- 003_refresh_tokens.sql
-- Refresh Token 관리 테이블
-- ============================================

CREATE TABLE IF NOT EXISTS refresh_tokens (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
    token_hash TEXT NOT NULL,
    revoked BOOLEAN NOT NULL DEFAULT FALSE,
    revoked_at TIMESTAMPTZ,
    expires_at TIMESTAMPTZ NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- 유니크 제약 (해시 충돌 방지)
    CONSTRAINT unique_token_hash UNIQUE (token_hash)
);

-- 인덱스
CREATE INDEX IF NOT EXISTS idx_refresh_tokens_user_id ON refresh_tokens(user_id);
CREATE INDEX IF NOT EXISTS idx_refresh_tokens_token_hash ON refresh_tokens(token_hash);
CREATE INDEX IF NOT EXISTS idx_refresh_tokens_expires_at ON refresh_tokens(expires_at);
-- 활성 토큰 조회 최적화
CREATE INDEX IF NOT EXISTS idx_refresh_tokens_user_active
    ON refresh_tokens(user_id) WHERE revoked = FALSE;

-- RLS 활성화 (서버 사이드 전용 - 정책 없음)
ALTER TABLE refresh_tokens ENABLE ROW LEVEL SECURITY;

-- ============================================
-- user_sessions 테이블
-- ============================================

CREATE TABLE IF NOT EXISTS user_sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
    ip_address INET,
    user_agent TEXT,
    device_info JSONB DEFAULT '{}',  -- v2.0 추가
    invalidated_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 인덱스
CREATE INDEX IF NOT EXISTS idx_user_sessions_user_id ON user_sessions(user_id);
-- 활성 세션 조회 최적화
CREATE INDEX IF NOT EXISTS idx_user_sessions_user_active
    ON user_sessions(user_id, created_at DESC)
    WHERE invalidated_at IS NULL;

-- RLS 활성화
ALTER TABLE user_sessions ENABLE ROW LEVEL SECURITY;
```

### 2.5 004_audit_logs.sql

```sql
-- ============================================
-- 004_audit_logs.sql
-- 감사 로그 테이블
-- ============================================

CREATE TABLE IF NOT EXISTS audit_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES profiles(id) ON DELETE SET NULL,
    action TEXT NOT NULL,
    severity TEXT DEFAULT 'info' CHECK (severity IN ('info', 'warning', 'error', 'critical')),  -- v2.0 추가
    details JSONB DEFAULT '{}',
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 인덱스
CREATE INDEX IF NOT EXISTS idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_action ON audit_logs(action);
CREATE INDEX IF NOT EXISTS idx_audit_logs_severity ON audit_logs(severity);  -- v2.0 추가
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON audit_logs(created_at DESC);
-- 보안 이벤트 빠른 조회
CREATE INDEX IF NOT EXISTS idx_audit_logs_security
    ON audit_logs(created_at DESC)
    WHERE severity IN ('error', 'critical');

-- RLS 활성화
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;

-- ============================================
-- security_events 테이블 (v2.0 신규)
-- 보안 이벤트 전용 테이블 (빠른 조회용)
-- ============================================

CREATE TABLE IF NOT EXISTS security_events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    event_type TEXT NOT NULL CHECK (event_type IN (
        'token_reuse',
        'rate_limit_exceeded',
        'cors_blocked',
        'prompt_injection_detected',
        'brute_force_attempt',
        'suspicious_activity'
    )),
    user_id UUID REFERENCES profiles(id) ON DELETE SET NULL,
    ip_address INET,
    details JSONB NOT NULL DEFAULT '{}',
    resolved BOOLEAN DEFAULT FALSE,
    resolved_at TIMESTAMPTZ,
    resolved_by UUID REFERENCES profiles(id),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 인덱스
CREATE INDEX IF NOT EXISTS idx_security_events_type ON security_events(event_type);
CREATE INDEX IF NOT EXISTS idx_security_events_created_at ON security_events(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_security_events_unresolved
    ON security_events(created_at DESC) WHERE resolved = FALSE;

-- RLS 활성화
ALTER TABLE security_events ENABLE ROW LEVEL SECURITY;

-- 감사 대상 액션 정의 (COMMENT)
COMMENT ON TABLE audit_logs IS '
감사 대상 액션:
- signup: 회원가입
- login: 로그인
- login_failed: 로그인 실패
- logout: 로그아웃
- password_change: 비밀번호 변경
- profile_update: 프로필 수정
- approval_change: 승인 상태 변경
- sessions_invalidated: 세션 무효화
- token_reuse_detected: 토큰 재사용 감지 (CRITICAL)
- landing_page_created: LP 생성
- landing_page_updated: LP 수정
- landing_page_deleted: LP 삭제 (soft)
- landing_page_restored: LP 복구
- landing_page_permanently_deleted: LP 영구 삭제
- ai_generation: AI 생성 요청
- ai_generation_failed: AI 생성 실패
- rate_limit_exceeded: Rate Limit 초과
- cors_blocked: CORS 차단
- prompt_injection_blocked: Prompt Injection 차단
- error: 일반 에러
';
```

### 2.6 005_rate_limits.sql

```sql
-- ============================================
-- 005_rate_limits.sql
-- Rate Limiting 테이블 및 함수
-- ============================================

CREATE TABLE IF NOT EXISTS rate_limits (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL,       -- IP 또는 user_id
    endpoint TEXT NOT NULL,         -- API 엔드포인트
    request_count INTEGER NOT NULL DEFAULT 1,
    window_start TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- 복합 유니크 키 (윈도우별 단일 레코드)
    CONSTRAINT unique_rate_limit UNIQUE (identifier, endpoint, window_start)
);

-- 인덱스
CREATE INDEX IF NOT EXISTS idx_rate_limits_lookup
    ON rate_limits(identifier, endpoint, window_start DESC);
-- 정리용 인덱스
CREATE INDEX IF NOT EXISTS idx_rate_limits_cleanup
    ON rate_limits(window_start) WHERE window_start < NOW() - INTERVAL '1 hour';

-- RLS 활성화 (서버 사이드 전용)
ALTER TABLE rate_limits ENABLE ROW LEVEL SECURITY;

-- ============================================
-- Rate Limit 체크 함수 (Fail-Closed)
-- v2.0: 에러 발생 시 차단 (Fail-Closed)
-- ============================================

CREATE OR REPLACE FUNCTION check_rate_limit(
    p_identifier TEXT,
    p_endpoint TEXT,
    p_limit INTEGER,
    p_window_seconds INTEGER
)
RETURNS JSONB AS $$
DECLARE
    v_window_start TIMESTAMPTZ;
    v_current_count INTEGER;
    v_result JSONB;
BEGIN
    -- 윈도우 시작 시간 계산 (슬라이딩 윈도우)
    v_window_start := DATE_TRUNC('second', NOW())
        - ((EXTRACT(EPOCH FROM NOW())::BIGINT % p_window_seconds) * INTERVAL '1 second');

    -- 현재 카운트 조회 및 증가 (UPSERT)
    INSERT INTO rate_limits (identifier, endpoint, request_count, window_start)
    VALUES (p_identifier, p_endpoint, 1, v_window_start)
    ON CONFLICT (identifier, endpoint, window_start)
    DO UPDATE SET request_count = rate_limits.request_count + 1
    RETURNING request_count INTO v_current_count;

    -- 제한 초과 확인
    IF v_current_count > p_limit THEN
        v_result := jsonb_build_object(
            'allowed', FALSE,
            'current', v_current_count,
            'limit', p_limit,
            'reset_at', v_window_start + (p_window_seconds * INTERVAL '1 second'),
            'retry_after', EXTRACT(EPOCH FROM (v_window_start + (p_window_seconds * INTERVAL '1 second') - NOW()))::INTEGER
        );
    ELSE
        v_result := jsonb_build_object(
            'allowed', TRUE,
            'current', v_current_count,
            'limit', p_limit,
            'remaining', p_limit - v_current_count
        );
    END IF;

    RETURN v_result;

EXCEPTION WHEN OTHERS THEN
    -- v2.0 Fail-Closed: 에러 발생 시 차단
    RETURN jsonb_build_object(
        'allowed', FALSE,
        'error', TRUE,
        'message', 'Rate limit check failed',
        'retry_after', 60
    );
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- 오래된 Rate Limit 정리 함수
-- ============================================

CREATE OR REPLACE FUNCTION cleanup_old_rate_limits()
RETURNS INTEGER AS $$
DECLARE
    v_count INTEGER;
BEGIN
    DELETE FROM rate_limits
    WHERE window_start < NOW() - INTERVAL '1 hour';

    GET DIAGNOSTICS v_count = ROW_COUNT;
    RETURN v_count;
END;
$$ LANGUAGE plpgsql;
```

### 2.7 006_token_reservations.sql

```sql
-- ============================================
-- 006_token_reservations.sql
-- 토큰 예약 테이블 및 함수
-- v2.0: Advisory Lock hashtext() 수정
-- ============================================

CREATE TABLE IF NOT EXISTS token_reservations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
    estimated_tokens INTEGER NOT NULL CHECK (estimated_tokens > 0),
    actual_tokens INTEGER,
    status TEXT NOT NULL DEFAULT 'reserved' CHECK (status IN ('reserved', 'confirmed', 'cancelled', 'expired')),
    error_reason TEXT,  -- v2.0 추가: 실패 사유
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    confirmed_at TIMESTAMPTZ
);

-- 인덱스
CREATE INDEX IF NOT EXISTS idx_token_reservations_user_id ON token_reservations(user_id);
CREATE INDEX IF NOT EXISTS idx_token_reservations_status ON token_reservations(status);
-- 대기 중인 예약 조회 최적화
CREATE INDEX IF NOT EXISTS idx_token_reservations_user_pending
    ON token_reservations(user_id, created_at DESC)
    WHERE status = 'reserved';

-- RLS 활성화
ALTER TABLE token_reservations ENABLE ROW LEVEL SECURITY;

-- token_usage에 reservation_id 추가 (v2.0)
ALTER TABLE token_usage
ADD COLUMN IF NOT EXISTS reservation_id UUID REFERENCES token_reservations(id);

-- ============================================
-- 토큰 예약 함수 (Advisory Lock 수정됨)
-- v2.0: hashtext() 대신 hash_numeric 사용
-- ============================================

-- 안전한 해시 함수 (bigint 반환)
CREATE OR REPLACE FUNCTION safe_user_hash(p_user_id UUID)
RETURNS BIGINT AS $$
BEGIN
    -- UUID를 안정적인 bigint로 변환
    -- 충돌 확률 최소화를 위해 상위/하위 비트 조합
    RETURN (
        ('x' || substr(p_user_id::TEXT, 1, 8))::BIT(32)::BIGINT << 32
    ) | (
        ('x' || substr(p_user_id::TEXT, 10, 8))::BIT(32)::BIGINT
    );
END;
$$ LANGUAGE plpgsql IMMUTABLE;

CREATE OR REPLACE FUNCTION check_and_reserve_tokens(
    p_user_id UUID,
    p_estimated_tokens INTEGER
)
RETURNS JSONB AS $$
DECLARE
    v_tier TEXT;
    v_daily_limit INTEGER;
    v_used_today INTEGER;
    v_reserved_pending INTEGER;
    v_available INTEGER;
    v_reservation_id UUID;
    v_lock_key BIGINT;
BEGIN
    -- v2.0: 안전한 락 키 생성
    v_lock_key := safe_user_hash(p_user_id);

    -- Advisory Lock 획득 (트랜잭션 범위)
    PERFORM pg_advisory_xact_lock(v_lock_key);

    -- 사용자 티어 확인
    SELECT tier INTO v_tier
    FROM profiles
    WHERE id = p_user_id AND deleted_at IS NULL;

    IF v_tier IS NULL THEN
        RETURN jsonb_build_object(
            'success', FALSE,
            'error', 'user_not_found'
        );
    END IF;

    -- 티어별 일일 한도
    v_daily_limit := CASE v_tier
        WHEN 'FREE' THEN 100000
        WHEN 'PRO' THEN 500000
        WHEN 'ENTERPRISE' THEN 2000000
        ELSE 100000
    END;

    -- 오늘 사용량 조회 (타임존 고려)
    SELECT COALESCE(SUM(tokens_used), 0) INTO v_used_today
    FROM token_usage
    WHERE user_id = p_user_id
      AND created_at >= DATE_TRUNC('day', NOW() AT TIME ZONE 'Asia/Seoul')
      AND created_at < DATE_TRUNC('day', NOW() AT TIME ZONE 'Asia/Seoul') + INTERVAL '1 day';

    -- 대기 중인 예약량 조회 (10분 이내)
    SELECT COALESCE(SUM(estimated_tokens), 0) INTO v_reserved_pending
    FROM token_reservations
    WHERE user_id = p_user_id
      AND status = 'reserved'
      AND created_at > NOW() - INTERVAL '10 minutes';

    -- 사용 가능 토큰 계산
    v_available := v_daily_limit - v_used_today - v_reserved_pending;

    IF v_available < p_estimated_tokens THEN
        RETURN jsonb_build_object(
            'success', FALSE,
            'error', 'insufficient_tokens',
            'available', GREATEST(v_available, 0),
            'requested', p_estimated_tokens,
            'daily_limit', v_daily_limit,
            'used_today', v_used_today,
            'reserved', v_reserved_pending,
            'reset_at', (DATE_TRUNC('day', NOW() AT TIME ZONE 'Asia/Seoul') + INTERVAL '1 day') AT TIME ZONE 'Asia/Seoul'
        );
    END IF;

    -- 예약 생성
    INSERT INTO token_reservations (user_id, estimated_tokens, status)
    VALUES (p_user_id, p_estimated_tokens, 'reserved')
    RETURNING id INTO v_reservation_id;

    RETURN jsonb_build_object(
        'success', TRUE,
        'reservation_id', v_reservation_id,
        'available_after', v_available - p_estimated_tokens,
        'daily_limit', v_daily_limit,
        'expires_at', NOW() + INTERVAL '10 minutes'
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- 토큰 확정 함수
-- v2.0: token_usage에 reservation_id 연결
-- ============================================

CREATE OR REPLACE FUNCTION confirm_token_usage(
    p_reservation_id UUID,
    p_actual_tokens INTEGER
)
RETURNS JSONB AS $$
DECLARE
    v_reservation RECORD;
BEGIN
    -- 예약 조회 및 업데이트
    UPDATE token_reservations
    SET
        status = 'confirmed',
        actual_tokens = p_actual_tokens,
        confirmed_at = NOW()
    WHERE id = p_reservation_id AND status = 'reserved'
    RETURNING * INTO v_reservation;

    IF v_reservation IS NULL THEN
        RETURN jsonb_build_object(
            'success', FALSE,
            'error', 'reservation_not_found_or_already_processed'
        );
    END IF;

    -- token_usage에 실제 사용량 기록 (reservation_id 연결)
    INSERT INTO token_usage (user_id, tokens_used, action, reservation_id, metadata)
    VALUES (
        v_reservation.user_id,
        p_actual_tokens,
        'generate',
        p_reservation_id,
        jsonb_build_object(
            'estimated', v_reservation.estimated_tokens,
            'difference', v_reservation.estimated_tokens - p_actual_tokens
        )
    );

    RETURN jsonb_build_object(
        'success', TRUE,
        'estimated', v_reservation.estimated_tokens,
        'actual', p_actual_tokens,
        'difference', v_reservation.estimated_tokens - p_actual_tokens,
        'refunded', GREATEST(v_reservation.estimated_tokens - p_actual_tokens, 0)
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- 토큰 예약 취소 함수
-- ============================================

CREATE OR REPLACE FUNCTION cancel_token_reservation(
    p_reservation_id UUID,
    p_reason TEXT DEFAULT NULL
)
RETURNS JSONB AS $$
DECLARE
    v_updated INTEGER;
BEGIN
    UPDATE token_reservations
    SET
        status = 'cancelled',
        error_reason = p_reason
    WHERE id = p_reservation_id AND status = 'reserved';

    GET DIAGNOSTICS v_updated = ROW_COUNT;

    IF v_updated = 0 THEN
        RETURN jsonb_build_object(
            'success', FALSE,
            'error', 'reservation_not_found_or_already_processed'
        );
    END IF;

    RETURN jsonb_build_object(
        'success', TRUE,
        'message', 'Reservation cancelled'
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- 만료된 예약 정리 함수
-- ============================================

CREATE OR REPLACE FUNCTION cleanup_expired_reservations()
RETURNS INTEGER AS $$
DECLARE
    v_count INTEGER;
BEGIN
    UPDATE token_reservations
    SET
        status = 'expired',
        error_reason = 'Reservation expired after 10 minutes'
    WHERE status = 'reserved'
      AND created_at < NOW() - INTERVAL '10 minutes';

    GET DIAGNOSTICS v_count = ROW_COUNT;
    RETURN v_count;
END;
$$ LANGUAGE plpgsql;
```

### 2.8 007_functions_triggers.sql

```sql
-- ============================================
-- 007_functions_triggers.sql
-- 함수 및 트리거
-- v2.0: approval_changed_at 추가
-- ============================================

-- profiles에 approval_changed_at 추가
ALTER TABLE profiles
ADD COLUMN IF NOT EXISTS approval_changed_at TIMESTAMPTZ;

-- ============================================
-- 승인 상태 변경 시 세션 무효화 트리거
-- v2.0: approval_changed_at 자동 업데이트
-- ============================================

CREATE OR REPLACE FUNCTION invalidate_user_sessions()
RETURNS TRIGGER AS $$
BEGIN
    -- is_approved가 변경된 경우
    IF OLD.is_approved IS DISTINCT FROM NEW.is_approved THEN
        -- approval_changed_at 업데이트
        NEW.approval_changed_at := NOW();

        -- 모든 Refresh Token 폐기
        UPDATE refresh_tokens
        SET revoked = TRUE, revoked_at = NOW()
        WHERE user_id = NEW.id AND revoked = FALSE;

        -- 세션 무효화
        UPDATE user_sessions
        SET invalidated_at = NOW()
        WHERE user_id = NEW.id AND invalidated_at IS NULL;

        -- 감사 로그
        INSERT INTO audit_logs (user_id, action, severity, details)
        VALUES (
            NEW.id,
            'sessions_invalidated',
            CASE WHEN NEW.is_approved THEN 'info' ELSE 'warning' END,
            jsonb_build_object(
                'reason', 'approval_status_changed',
                'old_status', OLD.is_approved,
                'new_status', NEW.is_approved,
                'changed_by', current_user
            )
        );
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 트리거 생성
DROP TRIGGER IF EXISTS on_approval_change ON profiles;
CREATE TRIGGER on_approval_change
    BEFORE UPDATE ON profiles
    FOR EACH ROW
    EXECUTE FUNCTION invalidate_user_sessions();

-- ============================================
-- 사용자 토큰 사용량 조회 함수
-- ============================================

CREATE OR REPLACE FUNCTION get_user_token_usage(p_user_id UUID)
RETURNS JSONB AS $$
DECLARE
    v_tier TEXT;
    v_daily_limit INTEGER;
    v_used_today INTEGER;
    v_reserved INTEGER;
    v_today_start TIMESTAMPTZ;
    v_today_end TIMESTAMPTZ;
BEGIN
    -- 타임존 고려한 오늘 범위
    v_today_start := DATE_TRUNC('day', NOW() AT TIME ZONE 'Asia/Seoul');
    v_today_end := v_today_start + INTERVAL '1 day';

    -- 사용자 티어 확인
    SELECT tier INTO v_tier
    FROM profiles
    WHERE id = p_user_id AND deleted_at IS NULL;

    IF v_tier IS NULL THEN
        RETURN jsonb_build_object('error', 'user_not_found');
    END IF;

    -- 티어별 일일 한도
    v_daily_limit := CASE v_tier
        WHEN 'FREE' THEN 100000
        WHEN 'PRO' THEN 500000
        WHEN 'ENTERPRISE' THEN 2000000
        ELSE 100000
    END;

    -- 오늘 사용량
    SELECT COALESCE(SUM(tokens_used), 0) INTO v_used_today
    FROM token_usage
    WHERE user_id = p_user_id
      AND created_at >= v_today_start
      AND created_at < v_today_end;

    -- 대기 중인 예약량
    SELECT COALESCE(SUM(estimated_tokens), 0) INTO v_reserved
    FROM token_reservations
    WHERE user_id = p_user_id
      AND status = 'reserved'
      AND created_at > NOW() - INTERVAL '10 minutes';

    RETURN jsonb_build_object(
        'tier', v_tier,
        'daily_limit', v_daily_limit,
        'used_today', v_used_today,
        'reserved', v_reserved,
        'available', GREATEST(v_daily_limit - v_used_today - v_reserved, 0),
        'usage_percentage', ROUND((v_used_today::NUMERIC / v_daily_limit) * 100, 2),
        'reset_at', v_today_end AT TIME ZONE 'Asia/Seoul'
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- 정리 함수들
-- ============================================

-- 오래된 감사 로그 정리 (90일)
CREATE OR REPLACE FUNCTION cleanup_old_audit_logs()
RETURNS INTEGER AS $$
DECLARE
    v_count INTEGER;
BEGIN
    -- CRITICAL 레벨은 삭제하지 않음
    DELETE FROM audit_logs
    WHERE created_at < NOW() - INTERVAL '90 days'
      AND severity != 'critical';

    GET DIAGNOSTICS v_count = ROW_COUNT;
    RETURN v_count;
END;
$$ LANGUAGE plpgsql;

-- 30일 초과 삭제 데이터 영구 삭제
CREATE OR REPLACE FUNCTION permanently_delete_expired_data()
RETURNS JSONB AS $$
DECLARE
    v_profiles INTEGER := 0;
    v_landing_pages INTEGER := 0;
    v_qa_sessions INTEGER := 0;
BEGIN
    -- 30일 초과 삭제된 qa_sessions 먼저 삭제 (FK)
    DELETE FROM qa_sessions
    WHERE deleted_at IS NOT NULL
      AND deleted_at < NOW() - INTERVAL '30 days';
    GET DIAGNOSTICS v_qa_sessions = ROW_COUNT;

    -- 30일 초과 삭제된 landing_pages 삭제
    DELETE FROM landing_pages
    WHERE deleted_at IS NOT NULL
      AND deleted_at < NOW() - INTERVAL '30 days';
    GET DIAGNOSTICS v_landing_pages = ROW_COUNT;

    -- 30일 초과 삭제된 profiles 삭제
    DELETE FROM profiles
    WHERE deleted_at IS NOT NULL
      AND deleted_at < NOW() - INTERVAL '30 days';
    GET DIAGNOSTICS v_profiles = ROW_COUNT;

    RETURN jsonb_build_object(
        'profiles_deleted', v_profiles,
        'landing_pages_deleted', v_landing_pages,
        'qa_sessions_deleted', v_qa_sessions,
        'executed_at', NOW()
    );
END;
$$ LANGUAGE plpgsql;

-- 오래된 세션 정리 (30일)
CREATE OR REPLACE FUNCTION cleanup_old_sessions()
RETURNS INTEGER AS $$
DECLARE
    v_count INTEGER;
BEGIN
    DELETE FROM user_sessions
    WHERE created_at < NOW() - INTERVAL '30 days';

    GET DIAGNOSTICS v_count = ROW_COUNT;
    RETURN v_count;
END;
$$ LANGUAGE plpgsql;

-- 폐기된 리프레시 토큰 정리 (7일 이상 지난 것)
CREATE OR REPLACE FUNCTION cleanup_revoked_refresh_tokens()
RETURNS INTEGER AS $$
DECLARE
    v_count INTEGER;
BEGIN
    DELETE FROM refresh_tokens
    WHERE revoked = TRUE
      AND revoked_at < NOW() - INTERVAL '7 days';

    GET DIAGNOSTICS v_count = ROW_COUNT;
    RETURN v_count;
END;
$$ LANGUAGE plpgsql;
```

### 2.9 008_rls_policies.sql (v2.0 신규 - 통합 정책)

```sql
-- ============================================
-- 008_rls_policies.sql
-- RLS 정책 통합 (v2.0)
-- 기존 OR 조합 정책 제거 후 단일 정책으로 재구성
-- ============================================

-- ============================================
-- profiles RLS 정책
-- ============================================

-- 기존 정책 모두 삭제
DROP POLICY IF EXISTS "Users can view own profile" ON profiles;
DROP POLICY IF EXISTS "Users can update own profile" ON profiles;
DROP POLICY IF EXISTS "Admins can view all profiles" ON profiles;
DROP POLICY IF EXISTS "Admins can update approval status" ON profiles;

-- 단일 SELECT 정책: 본인 OR 관리자
CREATE POLICY "profiles_select_policy" ON profiles
FOR SELECT USING (
    -- 본인 (삭제되지 않은 경우)
    (auth.uid() = id AND deleted_at IS NULL)
    OR
    -- 관리자 (모든 프로필 조회 가능)
    EXISTS (
        SELECT 1 FROM profiles admin
        WHERE admin.id = auth.uid()
          AND admin.tier = 'ENTERPRISE'
          AND admin.is_approved = TRUE
          AND admin.deleted_at IS NULL
    )
);

-- 단일 UPDATE 정책: 본인만
CREATE POLICY "profiles_update_policy" ON profiles
FOR UPDATE USING (
    auth.uid() = id AND deleted_at IS NULL
)
WITH CHECK (
    auth.uid() = id AND deleted_at IS NULL
);

-- 관리자 승인 상태 변경용 (Service Role에서만 사용)
-- 클라이언트는 이 정책으로 접근 불가

-- ============================================
-- landing_pages RLS 정책
-- ============================================

DROP POLICY IF EXISTS "Users can view own landing pages" ON landing_pages;
DROP POLICY IF EXISTS "Users can view own active landing pages" ON landing_pages;
DROP POLICY IF EXISTS "Users can view own deleted landing pages for recovery" ON landing_pages;
DROP POLICY IF EXISTS "Users can create landing pages" ON landing_pages;
DROP POLICY IF EXISTS "Users can update own landing pages" ON landing_pages;
DROP POLICY IF EXISTS "Users can update own active landing pages" ON landing_pages;
DROP POLICY IF EXISTS "Users can soft delete own landing pages" ON landing_pages;
DROP POLICY IF EXISTS "Anyone can view published landing pages" ON landing_pages;

-- SELECT: 본인 활성 + 본인 삭제(30일내) + 발행됨
CREATE POLICY "landing_pages_select_policy" ON landing_pages
FOR SELECT USING (
    -- 본인 활성 랜딩페이지
    (user_id = auth.uid() AND deleted_at IS NULL)
    OR
    -- 본인 삭제된 랜딩페이지 (30일 이내, 복구용)
    (user_id = auth.uid() AND deleted_at IS NOT NULL AND deleted_at > NOW() - INTERVAL '30 days')
    OR
    -- 발행된 랜딩페이지 (공개)
    (status = 'published' AND deleted_at IS NULL)
);

-- INSERT: 본인만
CREATE POLICY "landing_pages_insert_policy" ON landing_pages
FOR INSERT WITH CHECK (
    user_id = auth.uid()
);

-- UPDATE: 본인만 (삭제/복구 포함)
CREATE POLICY "landing_pages_update_policy" ON landing_pages
FOR UPDATE USING (
    user_id = auth.uid()
)
WITH CHECK (
    user_id = auth.uid()
);

-- DELETE: 사용 안 함 (Soft Delete만 사용)

-- ============================================
-- qa_sessions RLS 정책
-- ============================================

DROP POLICY IF EXISTS "Users can view own sessions" ON qa_sessions;
DROP POLICY IF EXISTS "Users can view own active sessions" ON qa_sessions;
DROP POLICY IF EXISTS "Users can create sessions" ON qa_sessions;
DROP POLICY IF EXISTS "Users can update own sessions" ON qa_sessions;
DROP POLICY IF EXISTS "Users can update own active sessions" ON qa_sessions;

-- SELECT: 본인 활성
CREATE POLICY "qa_sessions_select_policy" ON qa_sessions
FOR SELECT USING (
    user_id = auth.uid() AND deleted_at IS NULL
);

-- INSERT: 본인만
CREATE POLICY "qa_sessions_insert_policy" ON qa_sessions
FOR INSERT WITH CHECK (
    user_id = auth.uid()
);

-- UPDATE: 본인만
CREATE POLICY "qa_sessions_update_policy" ON qa_sessions
FOR UPDATE USING (
    user_id = auth.uid() AND deleted_at IS NULL
)
WITH CHECK (
    user_id = auth.uid()
);

-- ============================================
-- token_usage RLS 정책
-- ============================================

DROP POLICY IF EXISTS "Users can view own token usage" ON token_usage;
DROP POLICY IF EXISTS "System can insert token usage" ON token_usage;

-- SELECT: 본인만
CREATE POLICY "token_usage_select_policy" ON token_usage
FOR SELECT USING (
    user_id = auth.uid()
);

-- INSERT: Service Role만 (함수 통해서만)

-- ============================================
-- token_reservations RLS 정책
-- ============================================

DROP POLICY IF EXISTS "Users can view own reservations" ON token_reservations;

-- SELECT: 본인만
CREATE POLICY "token_reservations_select_policy" ON token_reservations
FOR SELECT USING (
    user_id = auth.uid()
);

-- INSERT/UPDATE: Service Role만 (함수 통해서만)

-- ============================================
-- user_sessions RLS 정책
-- ============================================

DROP POLICY IF EXISTS "Users can view own sessions" ON user_sessions;

-- SELECT: 본인만 (활성 세션)
CREATE POLICY "user_sessions_select_policy" ON user_sessions
FOR SELECT USING (
    user_id = auth.uid() AND invalidated_at IS NULL
);

-- ============================================
-- audit_logs RLS 정책
-- ============================================

DROP POLICY IF EXISTS "Users can view own audit logs" ON audit_logs;
DROP POLICY IF EXISTS "Admins can view all audit logs" ON audit_logs;

-- SELECT: 본인 OR 관리자
CREATE POLICY "audit_logs_select_policy" ON audit_logs
FOR SELECT USING (
    -- 본인 로그
    user_id = auth.uid()
    OR
    -- 관리자 (모든 로그)
    EXISTS (
        SELECT 1 FROM profiles admin
        WHERE admin.id = auth.uid()
          AND admin.tier = 'ENTERPRISE'
          AND admin.is_approved = TRUE
          AND admin.deleted_at IS NULL
    )
);

-- INSERT: Service Role만

-- ============================================
-- security_events RLS 정책
-- ============================================

-- 관리자만 조회 가능
CREATE POLICY "security_events_select_policy" ON security_events
FOR SELECT USING (
    EXISTS (
        SELECT 1 FROM profiles admin
        WHERE admin.id = auth.uid()
          AND admin.tier = 'ENTERPRISE'
          AND admin.is_approved = TRUE
          AND admin.deleted_at IS NULL
    )
);

-- INSERT/UPDATE: Service Role만

-- ============================================
-- refresh_tokens, rate_limits
-- 클라이언트 직접 접근 불가 (Service Role만)
-- 정책 없음 = 접근 차단
-- ============================================
```

### 2.10 009_schema_fixes.sql (v2.0 스키마 수정)

```sql
-- ============================================
-- 009_schema_fixes.sql
-- v2.0 스키마 수정 및 추가 인덱스
-- ============================================

-- ============================================
-- 복합 인덱스 최적화
-- ============================================

-- 사용자별 오늘 토큰 사용량 (최빈 쿼리)
DROP INDEX IF EXISTS idx_token_usage_user_date;
CREATE INDEX idx_token_usage_daily ON token_usage (
    user_id,
    created_at DESC
) WHERE created_at >= CURRENT_DATE;

-- 활성 예약 조회 최적화
CREATE INDEX IF NOT EXISTS idx_token_reservations_active
    ON token_reservations(user_id, created_at DESC)
    WHERE status = 'reserved' AND created_at > NOW() - INTERVAL '10 minutes';

-- ============================================
-- 데이터 정합성 체크 함수
-- ============================================

CREATE OR REPLACE FUNCTION check_data_consistency()
RETURNS TABLE (
    check_name TEXT,
    status TEXT,
    details JSONB
) AS $$
BEGIN
    -- 1. 프로필 없는 Auth 사용자 체크
    RETURN QUERY
    SELECT
        'orphan_auth_users'::TEXT,
        CASE WHEN COUNT(*) = 0 THEN 'OK' ELSE 'WARNING' END,
        jsonb_build_object('count', COUNT(*))
    FROM auth.users u
    WHERE NOT EXISTS (SELECT 1 FROM profiles p WHERE p.id = u.id);

    -- 2. 만료된 예약 체크
    RETURN QUERY
    SELECT
        'expired_reservations'::TEXT,
        CASE WHEN COUNT(*) = 0 THEN 'OK' ELSE 'NEEDS_CLEANUP' END,
        jsonb_build_object('count', COUNT(*))
    FROM token_reservations
    WHERE status = 'reserved'
      AND created_at < NOW() - INTERVAL '10 minutes';

    -- 3. 30일 초과 삭제 데이터 체크
    RETURN QUERY
    SELECT
        'expired_soft_deletes'::TEXT,
        'INFO',
        jsonb_build_object(
            'profiles', (SELECT COUNT(*) FROM profiles WHERE deleted_at < NOW() - INTERVAL '30 days'),
            'landing_pages', (SELECT COUNT(*) FROM landing_pages WHERE deleted_at < NOW() - INTERVAL '30 days'),
            'qa_sessions', (SELECT COUNT(*) FROM qa_sessions WHERE deleted_at < NOW() - INTERVAL '30 days')
        );

    -- 4. 폐기된 리프레시 토큰 체크
    RETURN QUERY
    SELECT
        'old_revoked_tokens'::TEXT,
        CASE WHEN COUNT(*) = 0 THEN 'OK' ELSE 'NEEDS_CLEANUP' END,
        jsonb_build_object('count', COUNT(*))
    FROM refresh_tokens
    WHERE revoked = TRUE AND revoked_at < NOW() - INTERVAL '7 days';
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- 통계 함수
-- ============================================

CREATE OR REPLACE FUNCTION get_system_stats()
RETURNS JSONB AS $$
DECLARE
    v_result JSONB;
BEGIN
    SELECT jsonb_build_object(
        'total_users', (SELECT COUNT(*) FROM profiles WHERE deleted_at IS NULL),
        'approved_users', (SELECT COUNT(*) FROM profiles WHERE is_approved = TRUE AND deleted_at IS NULL),
        'pending_users', (SELECT COUNT(*) FROM profiles WHERE is_approved = FALSE AND deleted_at IS NULL),
        'total_landing_pages', (SELECT COUNT(*) FROM landing_pages WHERE deleted_at IS NULL),
        'published_landing_pages', (SELECT COUNT(*) FROM landing_pages WHERE status = 'published' AND deleted_at IS NULL),
        'active_sessions', (SELECT COUNT(*) FROM user_sessions WHERE invalidated_at IS NULL AND created_at > NOW() - INTERVAL '7 days'),
        'tokens_used_today', (
            SELECT COALESCE(SUM(tokens_used), 0)
            FROM token_usage
            WHERE created_at >= DATE_TRUNC('day', NOW() AT TIME ZONE 'Asia/Seoul')
        ),
        'security_events_today', (
            SELECT COUNT(*)
            FROM security_events
            WHERE created_at >= DATE_TRUNC('day', NOW())
        ),
        'generated_at', NOW()
    ) INTO v_result;

    RETURN v_result;
END;
$$ LANGUAGE plpgsql;
```

---

## 3. TypeScript 타입 정의

```typescript
// src/types/database.ts

export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[];

export type UserTier = 'FREE' | 'PRO' | 'ENTERPRISE';
export type LandingPageStatus = 'draft' | 'published' | 'archived';
export type QASessionStatus = 'in_progress' | 'completed' | 'abandoned';
export type TokenAction = 'generate' | 'regenerate' | 'edit';
export type ReservationStatus = 'reserved' | 'confirmed' | 'cancelled' | 'expired';
export type AuditSeverity = 'info' | 'warning' | 'error' | 'critical';
export type SecurityEventType =
  | 'token_reuse'
  | 'rate_limit_exceeded'
  | 'cors_blocked'
  | 'prompt_injection_detected'
  | 'brute_force_attempt'
  | 'suspicious_activity';

export interface Database {
  public: {
    Tables: {
      profiles: {
        Row: {
          id: string;
          email: string;
          full_name: string;
          tier: UserTier;
          is_approved: boolean;
          agree_marketing: boolean;
          approval_changed_at: string | null;
          deleted_at: string | null;
          created_at: string;
          updated_at: string;
        };
        Insert: {
          id: string;
          email: string;
          full_name: string;
          tier?: UserTier;
          is_approved?: boolean;
          agree_marketing?: boolean;
          approval_changed_at?: string | null;
          deleted_at?: string | null;
          created_at?: string;
          updated_at?: string;
        };
        Update: {
          email?: string;
          full_name?: string;
          tier?: UserTier;
          is_approved?: boolean;
          agree_marketing?: boolean;
          approval_changed_at?: string | null;
          deleted_at?: string | null;
          updated_at?: string;
        };
      };
      landing_pages: {
        Row: {
          id: string;
          user_id: string;
          qa_session_id: string | null;
          title: string;
          content: Json;
          status: LandingPageStatus;
          slug: string | null;
          published_url: string | null;
          deleted_at: string | null;
          created_at: string;
          updated_at: string;
        };
        Insert: {
          id?: string;
          user_id: string;
          qa_session_id?: string | null;
          title: string;
          content?: Json;
          status?: LandingPageStatus;
          slug?: string | null;
          published_url?: string | null;
          deleted_at?: string | null;
          created_at?: string;
          updated_at?: string;
        };
        Update: {
          user_id?: string;
          qa_session_id?: string | null;
          title?: string;
          content?: Json;
          status?: LandingPageStatus;
          slug?: string | null;
          published_url?: string | null;
          deleted_at?: string | null;
          updated_at?: string;
        };
      };
      qa_sessions: {
        Row: {
          id: string;
          user_id: string;
          landing_page_id: string | null;
          answers: Json;
          current_step: number;
          status: QASessionStatus;
          deleted_at: string | null;
          created_at: string;
          updated_at: string;
        };
        Insert: {
          id?: string;
          user_id: string;
          landing_page_id?: string | null;
          answers?: Json;
          current_step?: number;
          status?: QASessionStatus;
          deleted_at?: string | null;
          created_at?: string;
          updated_at?: string;
        };
        Update: {
          landing_page_id?: string | null;
          answers?: Json;
          current_step?: number;
          status?: QASessionStatus;
          deleted_at?: string | null;
          updated_at?: string;
        };
      };
      token_usage: {
        Row: {
          id: string;
          user_id: string;
          tokens_used: number;
          action: TokenAction;
          reservation_id: string | null;
          metadata: Json;
          created_at: string;
        };
        Insert: {
          id?: string;
          user_id: string;
          tokens_used: number;
          action: TokenAction;
          reservation_id?: string | null;
          metadata?: Json;
          created_at?: string;
        };
        Update: never; // Immutable
      };
      token_reservations: {
        Row: {
          id: string;
          user_id: string;
          estimated_tokens: number;
          actual_tokens: number | null;
          status: ReservationStatus;
          error_reason: string | null;
          created_at: string;
          confirmed_at: string | null;
        };
        Insert: {
          id?: string;
          user_id: string;
          estimated_tokens: number;
          actual_tokens?: number | null;
          status?: ReservationStatus;
          error_reason?: string | null;
          created_at?: string;
          confirmed_at?: string | null;
        };
        Update: {
          actual_tokens?: number | null;
          status?: ReservationStatus;
          error_reason?: string | null;
          confirmed_at?: string | null;
        };
      };
      refresh_tokens: {
        Row: {
          id: string;
          user_id: string;
          token_hash: string;
          revoked: boolean;
          revoked_at: string | null;
          expires_at: string;
          created_at: string;
        };
        Insert: {
          id?: string;
          user_id: string;
          token_hash: string;
          revoked?: boolean;
          revoked_at?: string | null;
          expires_at: string;
          created_at?: string;
        };
        Update: {
          revoked?: boolean;
          revoked_at?: string | null;
        };
      };
      audit_logs: {
        Row: {
          id: string;
          user_id: string | null;
          action: string;
          severity: AuditSeverity;
          details: Json;
          ip_address: string | null;
          user_agent: string | null;
          created_at: string;
        };
        Insert: {
          id?: string;
          user_id?: string | null;
          action: string;
          severity?: AuditSeverity;
          details?: Json;
          ip_address?: string | null;
          user_agent?: string | null;
          created_at?: string;
        };
        Update: never; // Immutable
      };
      user_sessions: {
        Row: {
          id: string;
          user_id: string;
          ip_address: string | null;
          user_agent: string | null;
          device_info: Json;
          invalidated_at: string | null;
          created_at: string;
        };
        Insert: {
          id?: string;
          user_id: string;
          ip_address?: string | null;
          user_agent?: string | null;
          device_info?: Json;
          invalidated_at?: string | null;
          created_at?: string;
        };
        Update: {
          invalidated_at?: string | null;
        };
      };
      rate_limits: {
        Row: {
          id: string;
          identifier: string;
          endpoint: string;
          request_count: number;
          window_start: string;
          created_at: string;
        };
        Insert: {
          id?: string;
          identifier: string;
          endpoint: string;
          request_count?: number;
          window_start?: string;
          created_at?: string;
        };
        Update: {
          request_count?: number;
        };
      };
      security_events: {
        Row: {
          id: string;
          event_type: SecurityEventType;
          user_id: string | null;
          ip_address: string | null;
          details: Json;
          resolved: boolean;
          resolved_at: string | null;
          resolved_by: string | null;
          created_at: string;
        };
        Insert: {
          id?: string;
          event_type: SecurityEventType;
          user_id?: string | null;
          ip_address?: string | null;
          details?: Json;
          resolved?: boolean;
          resolved_at?: string | null;
          resolved_by?: string | null;
          created_at?: string;
        };
        Update: {
          resolved?: boolean;
          resolved_at?: string | null;
          resolved_by?: string | null;
        };
      };
    };
    Functions: {
      check_rate_limit: {
        Args: {
          p_identifier: string;
          p_endpoint: string;
          p_limit: number;
          p_window_seconds: number;
        };
        Returns: Json;
      };
      check_and_reserve_tokens: {
        Args: {
          p_user_id: string;
          p_estimated_tokens: number;
        };
        Returns: Json;
      };
      confirm_token_usage: {
        Args: {
          p_reservation_id: string;
          p_actual_tokens: number;
        };
        Returns: Json;
      };
      cancel_token_reservation: {
        Args: {
          p_reservation_id: string;
          p_reason?: string;
        };
        Returns: Json;
      };
      get_user_token_usage: {
        Args: {
          p_user_id: string;
        };
        Returns: Json;
      };
      get_system_stats: {
        Args: Record<string, never>;
        Returns: Json;
      };
      check_data_consistency: {
        Args: Record<string, never>;
        Returns: {
          check_name: string;
          status: string;
          details: Json;
        }[];
      };
    };
  };
}
```

---

## 4. 마이그레이션 실행

### 4.1 Supabase CLI 명령어

```bash
# 1. Supabase 로컬 시작
npx supabase start

# 2. 마이그레이션 적용
npx supabase db push

# 3. 마이그레이션 상태 확인
npx supabase db status

# 4. 타입 생성 (로컬 DB 기반)
npx supabase gen types typescript --local > src/types/database.ts

# 5. 타입 생성 (프로덕션 DB 기반)
npx supabase gen types typescript --project-id YOUR_PROJECT_ID > src/types/database.ts
```

### 4.2 마이그레이션 순서 검증

```bash
# 마이그레이션 순서 확인
ls -la supabase/migrations/

# 예상 결과:
# 001_initial_schema.sql
# 002_soft_delete.sql
# 003_refresh_tokens.sql
# 004_audit_logs.sql
# 005_rate_limits.sql
# 006_token_reservations.sql
# 007_functions_triggers.sql
# 008_rls_policies.sql
# 009_schema_fixes.sql
```

### 4.3 롤백 스크립트

```sql
-- rollback_v2.sql
-- v2.0 변경사항만 롤백

BEGIN;

-- 1. v2.0 신규 컬럼 삭제
ALTER TABLE profiles DROP COLUMN IF EXISTS approval_changed_at;
ALTER TABLE token_usage DROP COLUMN IF EXISTS reservation_id;
ALTER TABLE token_reservations DROP COLUMN IF EXISTS error_reason;
ALTER TABLE audit_logs DROP COLUMN IF EXISTS severity;
ALTER TABLE user_sessions DROP COLUMN IF EXISTS device_info;

-- 2. v2.0 신규 테이블 삭제
DROP TABLE IF EXISTS security_events;

-- 3. v2.0 함수 삭제
DROP FUNCTION IF EXISTS safe_user_hash(UUID);
DROP FUNCTION IF EXISTS check_data_consistency();
DROP FUNCTION IF EXISTS get_system_stats();

-- 4. RLS 정책은 008_rls_policies.sql 이전 상태로 수동 복원 필요

COMMIT;
```

---

## 5. 구현 체크리스트

### 5.1 마이그레이션 파일

- [ ] 001_initial_schema.sql 적용
- [ ] 002_soft_delete.sql 적용
- [ ] 003_refresh_tokens.sql 적용
- [ ] 004_audit_logs.sql 적용
- [ ] 005_rate_limits.sql 적용
- [ ] 006_token_reservations.sql 적용
- [ ] 007_functions_triggers.sql 적용
- [ ] 008_rls_policies.sql 적용 (v2.0)
- [ ] 009_schema_fixes.sql 적용 (v2.0)

### 5.2 RLS 정책 검증

- [ ] profiles: 본인/관리자만 SELECT 가능
- [ ] landing_pages: 본인/발행됨만 SELECT 가능
- [ ] qa_sessions: 본인만 접근 가능
- [ ] token_usage: 본인만 SELECT 가능
- [ ] refresh_tokens: 클라이언트 접근 차단
- [ ] rate_limits: 클라이언트 접근 차단
- [ ] audit_logs: 본인/관리자만 SELECT 가능
- [ ] security_events: 관리자만 접근 가능

### 5.3 함수 검증

- [ ] check_rate_limit: Fail-Closed 동작 확인
- [ ] check_and_reserve_tokens: Advisory Lock 정상 작동
- [ ] confirm_token_usage: reservation_id 연결 확인
- [ ] get_user_token_usage: 타임존 처리 확인

### 5.4 정리 작업 (Cron Job)

- [ ] cleanup_expired_reservations (매 분)
- [ ] cleanup_old_rate_limits (매 시간)
- [ ] cleanup_old_audit_logs (매일)
- [ ] cleanup_revoked_refresh_tokens (매일)
- [ ] cleanup_old_sessions (매일)
- [ ] permanently_delete_expired_data (매일)

---

## 6. Vercel Cron 설정

```json
// vercel.json
{
  "crons": [
    {
      "path": "/api/cron/cleanup",
      "schedule": "0 * * * *"
    }
  ]
}
```

```typescript
// src/app/api/cron/cleanup/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { createAdminClient } from '@/lib/supabase/admin';

export async function GET(request: NextRequest) {
  // Cron 인증 확인
  const authHeader = request.headers.get('authorization');
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const supabase = createAdminClient();
  const results: Record<string, number | unknown> = {};

  try {
    // 만료된 예약 정리
    const { data: reservations } = await supabase.rpc('cleanup_expired_reservations');
    results.expired_reservations = reservations;

    // 오래된 Rate Limit 정리
    const { data: rateLimits } = await supabase.rpc('cleanup_old_rate_limits');
    results.old_rate_limits = rateLimits;

    // 폐기된 Refresh Token 정리
    const { data: tokens } = await supabase.rpc('cleanup_revoked_refresh_tokens');
    results.revoked_tokens = tokens;

    // 오래된 세션 정리
    const { data: sessions } = await supabase.rpc('cleanup_old_sessions');
    results.old_sessions = sessions;

    // 영구 삭제 (30일 초과)
    const { data: permanent } = await supabase.rpc('permanently_delete_expired_data');
    results.permanent_deletes = permanent;

    return NextResponse.json({
      success: true,
      results,
      executed_at: new Date().toISOString(),
    });
  } catch (error) {
    console.error('Cleanup cron error:', error);
    return NextResponse.json(
      { success: false, error: 'Cleanup failed' },
      { status: 500 }
    );
  }
}
```

---

**이전 문서**: [01_인증_시스템_v2.md](./01_인증_시스템_v2.md)
**다음 문서**: [03_API_엔드포인트_v2.md](./03_API_엔드포인트_v2.md)
