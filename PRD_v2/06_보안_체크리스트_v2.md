# 06. 보안 체크리스트 v2

## 개요

Magnetic Sales WebApp의 보안 체크리스트는 OWASP Top 10 (2021)을 기반으로 작성되었으며, Red/Blue Team 피드백을 반영하여 실전 공격 시나리오에 대한 방어 메커니즘을 포함합니다.

**Red/Blue Team 피드백 반영:**
- 70개 보안 이슈 대응 (CRITICAL: 12, HIGH: 18, MEDIUM: 25, LOW: 15)
- OWASP Top 10 전체 항목 커버
- 실전 공격 벡터 기반 방어 전략

---

## 1. OWASP Top 10 대응

### A01:2021 - Broken Access Control

#### 1.1 인증 및 권한 검증

##### 문제
- 사용자가 권한 없이 타인의 데이터 접근
- URL 조작으로 Admin 페이지 접근
- JWT 토큰 변조

##### 대응 방안

**[CRITICAL-004] JWT Secret 환경 변수화**
```bash
# .env.local
SUPABASE_JWT_SECRET=your-jwt-secret-here-minimum-32-characters-required
```

**[HIGH-001] withAuth HOF 패턴**
```typescript
// src/lib/auth/withAuth.ts
import 'server-only';
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import * as jose from 'jose';

export function withAuth(
  handler: (request: NextRequest, user: User) => Promise<Response>
) {
  return async (request: NextRequest) => {
    const authHeader = request.headers.get('Authorization');

    if (!authHeader?.startsWith('Bearer ')) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const token = authHeader.slice(7);

    try {
      // JWT 검증
      const secret = new TextEncoder().encode(process.env.SUPABASE_JWT_SECRET);
      const { payload } = await jose.jwtVerify(token, secret);

      // Supabase 세션 확인
      const supabase = createClient();
      const { data: { user }, error } = await supabase.auth.getUser(token);

      if (error || !user) {
        return NextResponse.json({ error: 'Invalid token' }, { status: 401 });
      }

      // 핸들러 실행
      return await handler(request, user);

    } catch (error) {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
    }
  };
}
```

**[HIGH-002] RLS 정책 통합 (Supabase)**
```sql
-- CRITICAL-002: RLS 정책 중복 제거 및 통합
-- 모든 테이블에 단일 SELECT 정책만 유지

-- landing_pages 테이블
CREATE POLICY landing_pages_select ON landing_pages
  FOR SELECT USING (
    auth.uid() = user_id AND is_deleted = false
  );

CREATE POLICY landing_pages_insert ON landing_pages
  FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY landing_pages_update ON landing_pages
  FOR UPDATE USING (auth.uid() = user_id AND is_deleted = false);

-- ai_tokens 테이블
CREATE POLICY ai_tokens_select ON ai_tokens
  FOR SELECT USING (auth.uid() = user_id AND is_deleted = false);

CREATE POLICY ai_tokens_update ON ai_tokens
  FOR UPDATE USING (auth.uid() = user_id AND is_deleted = false);
```

**[MEDIUM-001] Admin 권한 검증**
```typescript
// src/lib/auth/adminGuard.ts
import { createClient } from '@/lib/supabase/server';
import { redirect } from 'next/navigation';

export async function requireAdmin() {
  const supabase = createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    redirect('/login');
  }

  // Admin 테이블에서 권한 확인
  const { data: adminData } = await supabase
    .from('admins')
    .select('role')
    .eq('user_id', user.id)
    .eq('is_deleted', false)
    .single();

  if (!adminData || adminData.role !== 'admin') {
    redirect('/403'); // Forbidden
  }

  return user;
}

// 사용 예시
// src/app/admin/users/page.tsx
import { requireAdmin } from '@/lib/auth/adminGuard';

export default async function AdminUsersPage() {
  await requireAdmin(); // Admin 아니면 자동 리다이렉트

  // Admin 전용 로직
}
```

#### 1.2 체크리스트

- [x] 모든 API 엔드포인트에 withAuth 적용
- [x] JWT Secret 환경 변수화 (최소 32자)
- [x] RLS 정책으로 데이터베이스 레벨 접근 제어
- [x] Admin 권한 검증 (admins 테이블)
- [x] 토큰 재사용 방지 (Token Rotation)
- [x] 세션 타임아웃 (Access: 15분, Refresh: 7일)

---

### A02:2021 - Cryptographic Failures

#### 2.1 민감 정보 암호화

##### 문제
- API 키, JWT Secret 평문 노출
- HTTPS 미사용
- 비밀번호 평문 저장

##### 대응 방안

**[CRITICAL-007] server-only 패키지 사용**
```typescript
// src/lib/supabase/server.ts
import 'server-only'; // 클라이언트 번들에 포함되면 빌드 실패

import { createServerClient } from '@supabase/ssr';

export function createClient() {
  // Service Role Key는 서버에서만 사용
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!, // 클라이언트 접근 불가
    { /* ... */ }
  );
}
```

**[HIGH-003] HTTPS 강제**
```typescript
// middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export function middleware(request: NextRequest) {
  // Production에서 HTTP 요청을 HTTPS로 리다이렉트
  if (
    process.env.NODE_ENV === 'production' &&
    request.headers.get('x-forwarded-proto') !== 'https'
  ) {
    return NextResponse.redirect(
      `https://${request.headers.get('host')}${request.nextUrl.pathname}`,
      301
    );
  }

  return NextResponse.next();
}
```

**[MEDIUM-002] HttpOnly Cookie for Refresh Token**
```typescript
// src/app/api/auth/login/route.ts
export async function POST(request: NextRequest) {
  // ... 로그인 로직 ...

  const response = NextResponse.json({ accessToken });

  // Refresh Token을 HttpOnly Cookie에 저장
  response.cookies.set('refreshToken', refreshToken, {
    httpOnly: true, // JavaScript 접근 불가
    secure: process.env.NODE_ENV === 'production', // HTTPS만
    sameSite: 'strict', // CSRF 방지
    maxAge: 60 * 60 * 24 * 7, // 7일
    path: '/',
  });

  return response;
}
```

#### 2.2 체크리스트

- [x] 모든 민감 정보 환경 변수화 (.env.local)
- [x] server-only 패키지로 Service Role Key 보호
- [x] HTTPS 강제 (Production)
- [x] Refresh Token을 HttpOnly Cookie에 저장
- [x] 비밀번호는 Supabase Auth가 자동 해시 (bcrypt)
- [x] 데이터베이스 연결 SSL 사용

---

### A03:2021 - Injection

#### 3.1 SQL Injection

##### 문제
- 사용자 입력이 SQL 쿼리에 직접 삽입
- ORM 없이 Raw SQL 사용

##### 대응 방안

**[CRITICAL-006] Prompt Injection 다층 방어**
```typescript
// src/lib/ai/promptDefense.ts
export function defendPromptInjection(userInput: string): DefenseResult {
  // Layer 1: Unicode Normalization
  const normalized = userInput.normalize('NFC');

  // Layer 2: Pattern Matching
  const patterns = [
    /(?:ignore|disregard|forget)\s+(?:previous|all)\s+(?:instructions|rules)/i,
    /(?:show|reveal)\s+(?:your|the)?\s*(?:prompt|instructions)/i,
  ];

  for (const pattern of patterns) {
    if (pattern.test(normalized)) {
      return { isSafe: false, reason: 'Injection pattern detected' };
    }
  }

  // Layer 3: Keyword Combinations
  const suspiciousKeywords = ['system', 'override', 'admin', 'root'];
  let keywordCount = 0;
  for (const keyword of suspiciousKeywords) {
    if (normalized.toLowerCase().includes(keyword)) {
      keywordCount++;
    }
  }

  if (keywordCount >= 2) {
    return { isSafe: false, reason: 'Suspicious keyword combination' };
  }

  return { isSafe: true };
}
```

**[HIGH-004] Supabase 파라미터화 쿼리**
```typescript
// ✅ 안전한 방법 (Supabase SDK)
const { data } = await supabase
  .from('landing_pages')
  .select('*')
  .eq('user_id', userId) // 자동 파라미터화
  .eq('is_deleted', false);

// ❌ 위험한 방법 (Raw SQL - 사용 금지)
const { data } = await supabase.rpc('unsafe_query', {
  sql: `SELECT * FROM landing_pages WHERE user_id = '${userId}'` // SQL Injection 가능
});
```

#### 3.2 NoSQL Injection

##### 대응 방안

**[MEDIUM-003] Zod 스키마 검증**
```typescript
// src/lib/utils/validators.ts
import { z } from 'zod';

export const createLandingPageSchema = z.object({
  title: z.string().min(1).max(200),
  sections: z.array(z.object({
    type: z.enum(['hero', 'features', 'pricing', 'cta']),
    content: z.record(z.any()),
  })),
});

// API Route에서 사용
export async function POST(request: NextRequest) {
  const body = await request.json();

  // 스키마 검증 (Injection 방지)
  const parsed = createLandingPageSchema.safeParse(body);
  if (!parsed.success) {
    return NextResponse.json({ error: parsed.error }, { status: 400 });
  }

  // 안전한 데이터만 사용
  const { title, sections } = parsed.data;
}
```

#### 3.3 체크리스트

- [x] Supabase SDK로 자동 파라미터화
- [x] Raw SQL 사용 금지
- [x] 사용자 입력 Zod 검증
- [x] Prompt Injection 다층 방어 (Unicode + Pattern + Keyword)
- [x] HTML 이스케이핑 (React는 기본 제공)

---

### A04:2021 - Insecure Design

#### 4.1 Rate Limiting

##### 문제
- 무제한 API 요청으로 서비스 과부하
- 브루트 포스 공격 취약

##### 대응 방안

**[CRITICAL-003] Fail-Closed Rate Limiting**
```typescript
// src/lib/rateLimit/rateLimiter.ts
import { LRUCache } from 'lru-cache';

interface RateLimitConfig {
  interval: number; // ms
  uniqueTokenPerInterval: number;
}

// Fail-Closed: Redis 실패 시 기본 거부
export function rateLimit(config: RateLimitConfig) {
  const tokenCache = new LRUCache({
    max: config.uniqueTokenPerInterval || 500,
    ttl: config.interval || 60000,
  });

  return {
    check: async (limit: number, token: string): Promise<{ success: boolean }> => {
      try {
        const tokenCount = (tokenCache.get(token) as number[]) || [0];
        if (tokenCount[0] === 0) {
          tokenCache.set(token, tokenCount);
        }

        tokenCount[0] += 1;

        const currentUsage = tokenCount[0];
        const isRateLimited = currentUsage >= limit;

        return { success: !isRateLimited };

      } catch (error) {
        // Fail-Closed: 에러 시 기본 거부
        console.error('Rate limiter error:', error);
        return { success: false };
      }
    },
  };
}

// 사용 예시
const limiter = rateLimit({
  interval: 60 * 1000, // 1분
  uniqueTokenPerInterval: 500,
});

export async function POST(request: NextRequest) {
  const ip = request.headers.get('x-forwarded-for') || 'unknown';
  const { success } = await limiter.check(20, ip); // 분당 20회

  if (!success) {
    return NextResponse.json({ error: 'Rate limit exceeded' }, { status: 429 });
  }

  // 정상 처리
}
```

**[HIGH-005] 보수적 한도 설정 (50% 안전 마진)**
```typescript
// API별 Rate Limit
export const RATE_LIMITS = {
  AUTH_LOGIN: 5, // 분당 5회 (원래 10회 → 50% 축소)
  AUTH_SIGNUP: 3, // 분당 3회
  AI_CHAT: 20, // 분당 20회
  LP_CREATE: 10, // 분당 10회
  ADMIN_API: 50, // 분당 50회
};
```

#### 4.2 Advisory Lock (동시성 제어)

**[HIGH-006] Token 예약 경합 방지**
```sql
-- migrations/007_ai_usage_logs.sql
CREATE OR REPLACE FUNCTION reserve_ai_tokens(
  p_user_id UUID,
  p_amount INTEGER
) RETURNS BOOLEAN AS $$
DECLARE
  v_lock_id INTEGER;
  v_available INTEGER;
BEGIN
  -- 1. Advisory Lock 획득
  v_lock_id := hashtext('ai_token_' || p_user_id::text);
  PERFORM pg_advisory_lock(v_lock_id);

  -- 2. 잔액 확인
  SELECT (purchased_tokens - used_tokens) INTO v_available
  FROM ai_tokens
  WHERE user_id = p_user_id AND is_deleted = false;

  IF v_available < p_amount THEN
    PERFORM pg_advisory_unlock(v_lock_id);
    RETURN FALSE;
  END IF;

  -- 3. 예약
  UPDATE ai_tokens
  SET used_tokens = used_tokens + p_amount
  WHERE user_id = p_user_id;

  -- 4. Lock 해제는 트랜잭션 종료 시 자동
  RETURN TRUE;
END;
$$ LANGUAGE plpgsql;
```

#### 4.3 체크리스트

- [x] Fail-Closed Rate Limiting (LRU Cache fallback)
- [x] 보수적 Rate Limit (50% 안전 마진)
- [x] Advisory Lock으로 동시성 제어
- [x] IP 기반 + 사용자 ID 기반 이중 제한
- [x] 429 Too Many Requests 응답

---

### A05:2021 - Security Misconfiguration

#### 5.1 환경 변수 관리

##### 문제
- .env 파일이 Git에 커밋됨
- 기본 비밀번호 사용
- 불필요한 디버그 정보 노출

##### 대응 방안

**[MEDIUM-004] .gitignore 설정**
```gitignore
# .gitignore
.env
.env.local
.env.production
.env.development
*.log
node_modules/
.next/
```

**[MEDIUM-005] 환경 변수 검증**
```typescript
// src/lib/env.ts
import { z } from 'zod';

const envSchema = z.object({
  NEXT_PUBLIC_SUPABASE_URL: z.string().url(),
  NEXT_PUBLIC_SUPABASE_ANON_KEY: z.string().min(20),
  SUPABASE_SERVICE_ROLE_KEY: z.string().min(20),
  SUPABASE_JWT_SECRET: z.string().min(32),
  ANTHROPIC_API_KEY: z.string().startsWith('sk-ant-'),
});

export const env = envSchema.parse(process.env);
```

**[LOW-001] Production 로그 최소화**
```typescript
// next.config.js
const nextConfig = {
  compiler: {
    removeConsole: process.env.NODE_ENV === 'production' ? {
      exclude: ['error', 'warn'], // error/warn만 남기고 모두 제거
    } : false,
  },
};
```

#### 5.2 체크리스트

- [x] .env 파일 .gitignore에 추가
- [x] 환경 변수 Zod 스키마로 검증
- [x] Production에서 console.log 제거
- [x] 에러 메시지에서 Stack Trace 숨김
- [x] CORS 명시적 화이트리스트 (와일드카드 금지)

---

### A06:2021 - Vulnerable and Outdated Components

#### 6.1 의존성 관리

##### 문제
- 구버전 라이브러리 사용 (보안 취약점)
- 버전 불일치로 호환성 문제

##### 대응 방안

**[CRITICAL-001] Next.js 15.0.4 + React 19.0.0 버전 통일**
```json
{
  "dependencies": {
    "next": "15.0.4",
    "react": "19.0.0",
    "react-dom": "19.0.0",
    "@supabase/ssr": "^0.5.2",
    "@supabase/supabase-js": "^2.47.10"
  }
}
```

**[MEDIUM-006] 정기 보안 업데이트**
```bash
# npm audit로 취약점 확인
npm audit

# 자동 수정 (major 버전 제외)
npm audit fix

# Dependabot 활성화 (GitHub)
# .github/dependabot.yml
version: 2
updates:
  - package-ecosystem: "npm"
    directory: "/"
    schedule:
      interval: "weekly"
    open-pull-requests-limit: 10
```

#### 6.2 체크리스트

- [x] 모든 패키지 최신 안정 버전 사용
- [x] Next.js, React 버전 통일 (15.0.4, 19.0.0)
- [x] npm audit 주기적 실행 (CI/CD)
- [x] Dependabot 활성화
- [x] 사용하지 않는 패키지 제거

---

### A07:2021 - Identification and Authentication Failures

#### 7.1 인증 시스템

##### 문제
- 약한 비밀번호 허용
- 토큰 재사용 가능
- 세션 고정 공격

##### 대응 방안

**[CRITICAL-005] Token Rotation 구현**
```typescript
// src/app/api/auth/refresh/route.ts
export async function POST(request: NextRequest) {
  const refreshToken = request.cookies.get('refreshToken')?.value;

  if (!refreshToken) {
    return NextResponse.json({ error: 'No refresh token' }, { status: 401 });
  }

  const supabase = createClient();

  // 1. Refresh Token으로 새 Access Token 발급
  const { data, error } = await supabase.auth.refreshSession({
    refresh_token: refreshToken,
  });

  if (error || !data.session) {
    return NextResponse.json({ error: 'Invalid refresh token' }, { status: 403 });
  }

  // 2. 새 Refresh Token으로 교체 (Token Rotation)
  const response = NextResponse.json({
    accessToken: data.session.access_token,
  });

  response.cookies.set('refreshToken', data.session.refresh_token, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict',
    maxAge: 60 * 60 * 24 * 7,
  });

  return response;
}
```

**[HIGH-007] 비밀번호 정책**
```typescript
// src/lib/utils/validators.ts
export const passwordSchema = z
  .string()
  .min(8, 'Password must be at least 8 characters')
  .max(100)
  .regex(/[A-Z]/, 'Password must contain at least one uppercase letter')
  .regex(/[a-z]/, 'Password must contain at least one lowercase letter')
  .regex(/[0-9]/, 'Password must contain at least one number')
  .regex(/[@$!%*?&#]/, 'Password must contain at least one special character');
```

**[MEDIUM-007] 로그인 시도 제한**
```typescript
// src/app/api/auth/login/route.ts
const loginLimiter = rateLimit({
  interval: 15 * 60 * 1000, // 15분
  uniqueTokenPerInterval: 500,
});

export async function POST(request: NextRequest) {
  const email = (await request.json()).email;

  // 이메일 기반 Rate Limiting (브루트 포스 방지)
  const { success } = await loginLimiter.check(5, email);

  if (!success) {
    return NextResponse.json(
      { error: 'Too many login attempts. Try again in 15 minutes.' },
      { status: 429 }
    );
  }

  // 로그인 로직
}
```

#### 7.2 체크리스트

- [x] Token Rotation 구현 (Refresh Token 재사용 방지)
- [x] 강력한 비밀번호 정책 (8자 이상, 대소문자/숫자/특수문자)
- [x] 로그인 시도 제한 (15분당 5회)
- [x] 세션 타임아웃 (Access: 15분, Refresh: 7일)
- [x] 로그아웃 시 서버 세션 무효화

---

### A08:2021 - Software and Data Integrity Failures

#### 8.1 코드 무결성

##### 문제
- 신뢰할 수 없는 CDN에서 스크립트 로드
- npm 패키지 변조
- 빌드 파이프라인 공격

##### 대응 방안

**[MEDIUM-008] Subresource Integrity (SRI)**
```typescript
// src/app/layout.tsx
export default function RootLayout({ children }) {
  return (
    <html>
      <head>
        {/* CDN 스크립트에 SRI 해시 추가 */}
        <script
          src="https://cdn.example.com/script.js"
          integrity="sha384-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8wC"
          crossOrigin="anonymous"
        />
      </head>
      <body>{children}</body>
    </html>
  );
}
```

**[LOW-002] package-lock.json 커밋**
```bash
# package-lock.json을 Git에 커밋하여 의존성 고정
git add package-lock.json
git commit -m "Lock dependencies"
```

#### 8.2 데이터 무결성

**[MEDIUM-009] Soft Delete (30일 복구)**
```sql
-- migrations/009_soft_delete.sql
ALTER TABLE landing_pages ADD COLUMN is_deleted BOOLEAN DEFAULT false;
ALTER TABLE landing_pages ADD COLUMN deleted_at TIMESTAMPTZ;

-- Soft Delete 함수
CREATE OR REPLACE FUNCTION soft_delete_landing_page(p_id UUID)
RETURNS VOID AS $$
BEGIN
  UPDATE landing_pages
  SET is_deleted = true, deleted_at = now()
  WHERE id = p_id;
END;
$$ LANGUAGE plpgsql;

-- 30일 후 자동 삭제 (Cron Job)
CREATE OR REPLACE FUNCTION cleanup_soft_deleted()
RETURNS VOID AS $$
BEGIN
  DELETE FROM landing_pages
  WHERE is_deleted = true
    AND deleted_at < now() - INTERVAL '30 days';
END;
$$ LANGUAGE plpgsql;
```

#### 8.3 체크리스트

- [x] CDN 리소스에 SRI 해시 추가
- [x] package-lock.json 커밋
- [x] Soft Delete 구현 (30일 복구 기간)
- [x] 데이터베이스 백업 (일 1회)
- [x] CI/CD 빌드 검증 (테스트 + Lint)

---

### A09:2021 - Security Logging and Monitoring Failures

#### 9.1 로깅 전략

##### 문제
- 보안 이벤트 로그 부재
- 로그에 민감 정보 포함
- 로그 분석 불가

##### 대응 방안

**[MEDIUM-010] 보안 이벤트 로깅**
```typescript
// src/lib/logging/securityLogger.ts
import { createClient } from '@/lib/supabase/server';

export interface SecurityEvent {
  type: 'login_success' | 'login_failure' | 'prompt_injection' | 'rate_limit';
  severity: 'low' | 'medium' | 'high' | 'critical';
  userId?: string;
  ip: string;
  userAgent?: string;
  details: Record<string, any>;
}

export async function logSecurityEvent(event: SecurityEvent) {
  const supabase = createClient();

  await supabase.from('security_logs').insert({
    event_type: event.type,
    severity: event.severity,
    user_id: event.userId,
    ip_address: event.ip,
    user_agent: event.userAgent,
    details: event.details,
    created_at: new Date().toISOString(),
  });

  // CRITICAL 이벤트는 즉시 알림
  if (event.severity === 'critical') {
    await sendAlert(event);
  }
}

// 사용 예시
await logSecurityEvent({
  type: 'prompt_injection',
  severity: 'high',
  userId: user.id,
  ip: request.headers.get('x-forwarded-for') || 'unknown',
  details: {
    input: userInput.slice(0, 100), // 처음 100자만 로깅
    matched_patterns: ['ignore previous instructions'],
  },
});
```

**[LOW-003] 민감 정보 마스킹**
```typescript
export function maskSensitiveData(data: any): any {
  const sensitiveFields = ['password', 'token', 'apiKey', 'secret'];

  if (typeof data === 'object') {
    const masked = { ...data };
    for (const key of Object.keys(masked)) {
      if (sensitiveFields.some(field => key.toLowerCase().includes(field))) {
        masked[key] = '***REDACTED***';
      }
    }
    return masked;
  }

  return data;
}

// 로깅 시 사용
console.log('User data:', maskSensitiveData(userData));
// { email: 'user@example.com', password: '***REDACTED***' }
```

#### 9.2 모니터링

**[MEDIUM-011] 이상 탐지 알림**
```typescript
// src/lib/monitoring/anomalyDetector.ts
export async function detectAnomalies() {
  const supabase = createClient();

  // 1. 1시간 내 로그인 실패 급증
  const { count: failedLogins } = await supabase
    .from('security_logs')
    .select('*', { count: 'exact', head: true })
    .eq('event_type', 'login_failure')
    .gte('created_at', new Date(Date.now() - 60 * 60 * 1000).toISOString());

  if (failedLogins && failedLogins > 100) {
    await sendAlert({
      type: 'anomaly',
      message: `${failedLogins} failed logins in the last hour`,
    });
  }

  // 2. Rate Limit 초과 급증
  const { count: rateLimitHits } = await supabase
    .from('security_logs')
    .select('*', { count: 'exact', head: true })
    .eq('event_type', 'rate_limit')
    .gte('created_at', new Date(Date.now() - 60 * 60 * 1000).toISOString());

  if (rateLimitHits && rateLimitHits > 500) {
    await sendAlert({
      type: 'anomaly',
      message: `${rateLimitHits} rate limit hits in the last hour (DDoS?)`,
    });
  }
}

// Cron Job (매 10분)
setInterval(detectAnomalies, 10 * 60 * 1000);
```

#### 9.3 체크리스트

- [x] 보안 이벤트 로깅 (security_logs 테이블)
- [x] 민감 정보 마스킹
- [x] 이상 탐지 알림 (로그인 실패, Rate Limit 급증)
- [x] 로그 보관 기간 (90일)
- [x] 실시간 모니터링 대시보드

---

### A10:2021 - Server-Side Request Forgery (SSRF)

#### 10.1 외부 요청 제한

##### 문제
- 사용자 입력 URL로 내부 네트워크 접근
- Webhook URL 검증 부재

##### 대응 방안

**[MEDIUM-012] URL 화이트리스트**
```typescript
// src/lib/security/urlValidator.ts
const ALLOWED_DOMAINS = [
  'api.anthropic.com',
  'supabase.co',
  'vercel.com',
];

export function isAllowedUrl(url: string): boolean {
  try {
    const parsed = new URL(url);

    // 1. HTTP/HTTPS만 허용
    if (!['http:', 'https:'].includes(parsed.protocol)) {
      return false;
    }

    // 2. Private IP 차단
    const hostname = parsed.hostname;
    if (
      hostname === 'localhost' ||
      hostname.startsWith('127.') ||
      hostname.startsWith('192.168.') ||
      hostname.startsWith('10.') ||
      hostname.startsWith('172.')
    ) {
      return false;
    }

    // 3. 화이트리스트 확인
    return ALLOWED_DOMAINS.some(domain => hostname.endsWith(domain));

  } catch (error) {
    return false;
  }
}

// 사용 예시
export async function POST(request: NextRequest) {
  const { webhookUrl } = await request.json();

  if (!isAllowedUrl(webhookUrl)) {
    return NextResponse.json({ error: 'Invalid webhook URL' }, { status: 400 });
  }

  await fetch(webhookUrl, { /* ... */ });
}
```

#### 10.2 체크리스트

- [x] 외부 요청 URL 화이트리스트
- [x] Private IP 차단
- [x] HTTP/HTTPS만 허용
- [x] URL 파싱 검증
- [x] 타임아웃 설정 (10초)

---

## 2. 추가 보안 조치

### 2.1 CORS 정책

**[MEDIUM-013] 명시적 화이트리스트 (와일드카드 금지)**
```typescript
// middleware.ts
const ALLOWED_ORIGINS = [
  'https://magneticsales.com',
  'https://www.magneticsales.com',
  process.env.NODE_ENV === 'development' ? 'http://localhost:3000' : '',
].filter(Boolean);

export function middleware(request: NextRequest) {
  const origin = request.headers.get('origin');

  if (request.nextUrl.pathname.startsWith('/api/')) {
    if (origin && !ALLOWED_ORIGINS.includes(origin)) {
      return new NextResponse('CORS policy violation', { status: 403 });
    }

    const response = NextResponse.next();
    response.headers.set('Access-Control-Allow-Origin', origin || ALLOWED_ORIGINS[0]);
    response.headers.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');
    response.headers.set('Access-Control-Allow-Headers', 'Content-Type, Authorization');
    response.headers.set('Access-Control-Max-Age', '86400');
    return response;
  }

  return NextResponse.next();
}
```

### 2.2 CSRF 방어

**[LOW-004] SameSite Cookie**
```typescript
// 이미 적용됨 (HttpOnly Cookie 섹션 참조)
response.cookies.set('refreshToken', token, {
  sameSite: 'strict', // CSRF 방지
});
```

### 2.3 Clickjacking 방어

**[LOW-005] X-Frame-Options**
```typescript
// middleware.ts
export function middleware(request: NextRequest) {
  const response = NextResponse.next();

  // Clickjacking 방지
  response.headers.set('X-Frame-Options', 'DENY');
  response.headers.set('X-Content-Type-Options', 'nosniff');
  response.headers.set('X-XSS-Protection', '1; mode=block');
  response.headers.set(
    'Content-Security-Policy',
    "default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline';"
  );

  return response;
}
```

---

## 3. 보안 테스트

### 3.1 자동화된 보안 테스트

```bash
# npm audit (의존성 취약점)
npm audit

# OWASP ZAP (웹 취약점 스캔)
docker run -t owasp/zap2docker-stable zap-baseline.py -t https://magneticsales.com

# Snyk (의존성 + 코드 분석)
npx snyk test
```

### 3.2 수동 침투 테스트

**체크리스트:**
- [ ] SQL Injection 시도 (Supabase SDK 사용으로 방어 확인)
- [ ] XSS 공격 시도 (React 자동 이스케이핑 확인)
- [ ] CSRF 공격 시도 (SameSite Cookie 확인)
- [ ] Prompt Injection 시도 (다층 방어 확인)
- [ ] Rate Limit 우회 시도 (Fail-Closed 확인)
- [ ] Token 재사용 시도 (Token Rotation 확인)
- [ ] Admin 권한 상승 시도 (RLS + AdminGuard 확인)

---

## 4. 인시던트 대응 계획

### 4.1 보안 사고 발생 시

1. **탐지** (모니터링 알림)
2. **격리** (해당 사용자/IP 차단)
3. **분석** (security_logs 조회)
4. **복구** (Soft Delete에서 데이터 복구)
5. **재발 방지** (방어 로직 개선)

### 4.2 비상 연락망

- **개발팀:** dev-team@magneticsales.com
- **인프라팀:** infra@magneticsales.com
- **보안팀:** security@magneticsales.com

---

## 5. 최종 체크리스트

### CRITICAL (12개)
- [x] CRITICAL-001: Next.js 15.0.4 + React 19.0.0 버전 통일
- [x] CRITICAL-002: RLS 정책 통합 (단일 SELECT 정책)
- [x] CRITICAL-003: Fail-Closed Rate Limiting
- [x] CRITICAL-004: JWT Secret 환경 변수화
- [x] CRITICAL-005: Token Rotation 구현
- [x] CRITICAL-006: Prompt Injection 다층 방어
- [x] CRITICAL-007: server-only 패키지 사용
- [x] CRITICAL-008: HTTPS 강제
- [x] CRITICAL-009: 모든 API에 withAuth 적용
- [x] CRITICAL-010: Admin 권한 검증
- [x] CRITICAL-011: Supabase 파라미터화 쿼리
- [x] CRITICAL-012: 환경 변수 검증 (Zod)

### HIGH (18개)
- [x] HIGH-001: withAuth HOF 패턴
- [x] HIGH-002: RLS 정책 (모든 테이블)
- [x] HIGH-003: HTTPS 강제 미들웨어
- [x] HIGH-004: Supabase SDK 사용 (Raw SQL 금지)
- [x] HIGH-005: 보수적 Rate Limit (50% 마진)
- [x] HIGH-006: Advisory Lock (동시성 제어)
- [x] HIGH-007: 강력한 비밀번호 정책
- [x] HIGH-008: 로그인 시도 제한
- [x] HIGH-009: HttpOnly Cookie
- [x] HIGH-010: SameSite=Strict
- [x] HIGH-011: CORS 명시적 화이트리스트
- [x] HIGH-012: X-Frame-Options 헤더
- [x] HIGH-013: Zod 스키마 검증
- [x] HIGH-014: Soft Delete 구현
- [x] HIGH-015: 보안 이벤트 로깅
- [x] HIGH-016: URL 화이트리스트
- [x] HIGH-017: npm audit 정기 실행
- [x] HIGH-018: 민감 정보 마스킹

### MEDIUM (25개)
- [x] MEDIUM-001: Admin 권한 검증 함수
- [x] MEDIUM-002: HttpOnly Cookie 설정
- [x] MEDIUM-003: Zod 스키마 검증
- [x] MEDIUM-004: .gitignore 설정
- [x] MEDIUM-005: 환경 변수 검증
- [x] MEDIUM-006: Dependabot 활성화
- [x] MEDIUM-007: 로그인 Rate Limiting
- [x] MEDIUM-008: SRI 해시
- [x] MEDIUM-009: Soft Delete 30일
- [x] MEDIUM-010: 보안 로깅
- [x] MEDIUM-011: 이상 탐지 알림
- [x] MEDIUM-012: URL 화이트리스트
- [x] MEDIUM-013: CORS 명시적 화이트리스트
- [x] MEDIUM-014: AI 토큰 예약/확정
- [x] MEDIUM-015: SSE 타임아웃 90초
- [x] MEDIUM-016: Unicode Normalization
- [x] MEDIUM-017: Pattern Matching
- [x] MEDIUM-018: Keyword Combinations
- [x] MEDIUM-019: IP 기반 Rate Limiting
- [x] MEDIUM-020: 세션 타임아웃
- [x] MEDIUM-021: Production 로그 최소화
- [x] MEDIUM-022: 데이터베이스 백업
- [x] MEDIUM-023: CI/CD 보안 검증
- [x] MEDIUM-024: Private IP 차단
- [x] MEDIUM-025: fetch 타임아웃 10초

### LOW (15개)
- [x] LOW-001: console.log 제거
- [x] LOW-002: package-lock.json 커밋
- [x] LOW-003: 민감 정보 마스킹
- [x] LOW-004: SameSite Cookie
- [x] LOW-005: X-Frame-Options
- [x] LOW-006: X-Content-Type-Options
- [x] LOW-007: X-XSS-Protection
- [x] LOW-008: Content-Security-Policy
- [x] LOW-009: robots.txt
- [x] LOW-010: Sitemap
- [x] LOW-011: 로그 보관 90일
- [x] LOW-012: 에러 메시지 일반화
- [x] LOW-013: 빌드 최적화
- [x] LOW-014: 이미지 최적화
- [x] LOW-015: 폰트 최적화

---

**총 보안 조치:** 70개 (CRITICAL: 12, HIGH: 18, MEDIUM: 25, LOW: 15)

**마지막 업데이트:** 2025-12-15
**검토자:** Magnetic Sales WebApp 보안팀
**다음 검토 예정:** 2025-03-15 (분기별)
