# 보안 및 인증 설계 - 마그네틱 세일즈 웹앱

## 문서 정보
| 항목 | 내용 |
|------|------|
| 버전 | 1.0 |
| 작성일 | 2025-12-15 |
| 작성자 | Security Analyst Agent (80_security_analyst_v8) |
| 참조 | DEC-003 (수동 승인 방식), 04_상세페이지빌더_분석.md |

---

## 1. 인증 아키텍처

### 1.1 Supabase Auth 기반 JWT 인증

```
┌─────────────────────────────────────────────────────────────────────┐
│                        인증 아키텍처 개요                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   [클라이언트]                    [Supabase]                         │
│       │                              │                              │
│       │  1. 회원가입 요청            │                              │
│       │  (email, password)           │                              │
│       │─────────────────────────────▶│                              │
│       │                              │                              │
│       │  2. JWT Access Token         │                              │
│       │  + Refresh Token 발급        │                              │
│       │◀─────────────────────────────│                              │
│       │                              │                              │
│       │  3. API 요청 (Bearer Token)  │                              │
│       │─────────────────────────────▶│  4. JWT 검증                 │
│       │                              │     + approved 체크          │
│       │  5. 응답 (성공/실패)          │                              │
│       │◀─────────────────────────────│                              │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 1.2 JWT 토큰 구조

```typescript
interface JWTPayload {
  sub: string;           // 사용자 UUID
  email: string;         // 이메일
  role: string;          // 'authenticated' | 'anon'
  aud: string;           // 'authenticated'
  exp: number;           // 만료 시간 (Unix timestamp)
  iat: number;           // 발급 시간
  app_metadata: {
    provider: string;    // 'email'
  };
  user_metadata: {
    name?: string;
    approved?: boolean;  // 승인 상태 (커스텀)
  };
}
```

### 1.3 토큰 관리 정책

| 항목 | 설정값 | 근거 |
|------|--------|------|
| Access Token 만료 | 1시간 (3600초) | 보안/사용성 균형 |
| Refresh Token 만료 | 7일 | 재로그인 빈도 감소 |
| 자동 갱신 | Access Token 만료 5분 전 | 세션 끊김 방지 |

---

## 2. 수동 승인 플로우 상세 설계

### 2.1 전체 플로우 다이어그램

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                           수동 승인 플로우                                     │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  [사용자]                    [시스템]                    [관리자]              │
│     │                          │                          │                  │
│     │  1. 회원가입              │                          │                  │
│     │  (이메일/비밀번호)        │                          │                  │
│     │─────────────────────────▶│                          │                  │
│     │                          │                          │                  │
│     │                          │  2. auth.users 생성      │                  │
│     │                          │     approved=false 저장  │                  │
│     │                          │                          │                  │
│     │  3. 승인 대기 화면 표시   │                          │                  │
│     │◀─────────────────────────│                          │                  │
│     │                          │                          │                  │
│     │                          │  4. 신규 가입 알림       │                  │
│     │                          │     (이메일/슬랙)        │                  │
│     │                          │─────────────────────────▶│                  │
│     │                          │                          │                  │
│     │                          │  5. 수강생 확인 후       │                  │
│     │                          │     approved=true 변경   │                  │
│     │                          │◀─────────────────────────│                  │
│     │                          │                          │                  │
│     │  6. 승인 완료 알림       │                          │                  │
│     │     (이메일)             │                          │                  │
│     │◀─────────────────────────│                          │                  │
│     │                          │                          │                  │
│     │  7. 로그인               │                          │                  │
│     │─────────────────────────▶│  8. approved 체크        │                  │
│     │                          │     (RLS 정책)           │                  │
│     │  9. 대시보드 접근        │                          │                  │
│     │◀─────────────────────────│                          │                  │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 데이터베이스 스키마

```sql
-- 사용자 프로필 테이블 (auth.users와 연결)
CREATE TABLE public.user_profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  email TEXT NOT NULL,
  name TEXT,
  approved BOOLEAN DEFAULT FALSE,
  approved_at TIMESTAMPTZ,
  approved_by UUID REFERENCES auth.users(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 승인 기록 테이블 (감사 로그)
CREATE TABLE public.approval_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.user_profiles(id),
  action TEXT NOT NULL CHECK (action IN ('approved', 'rejected', 'revoked')),
  admin_id UUID NOT NULL REFERENCES auth.users(id),
  reason TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 인덱스
CREATE INDEX idx_user_profiles_approved ON public.user_profiles(approved);
CREATE INDEX idx_user_profiles_email ON public.user_profiles(email);
CREATE INDEX idx_approval_logs_user_id ON public.approval_logs(user_id);
```

### 2.3 회원가입 트리거

```sql
-- 회원가입 시 자동으로 user_profiles 생성
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.user_profiles (id, email, name, approved)
  VALUES (
    NEW.id,
    NEW.email,
    NEW.raw_user_meta_data->>'name',
    FALSE  -- 항상 미승인 상태로 시작
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_new_user();
```

---

## 3. 회원가입/로그인 플로우

### 3.1 회원가입 플로우

```typescript
// services/authService.ts

interface SignUpData {
  email: string;
  password: string;
  name: string;
}

interface SignUpResult {
  success: boolean;
  message: string;
  requiresApproval: boolean;
}

export async function signUp(data: SignUpData): Promise<SignUpResult> {
  try {
    // 1. Supabase Auth 회원가입
    const { data: authData, error: authError } = await supabase.auth.signUp({
      email: data.email,
      password: data.password,
      options: {
        data: {
          name: data.name,
        },
      },
    });

    if (authError) {
      throw authError;
    }

    // 2. 트리거가 자동으로 user_profiles에 approved=false로 생성

    // 3. 관리자에게 알림 발송 (Edge Function 호출)
    await supabase.functions.invoke('notify-new-signup', {
      body: {
        userId: authData.user?.id,
        email: data.email,
        name: data.name,
      },
    });

    return {
      success: true,
      message: '회원가입이 완료되었습니다. 관리자 승인을 기다려주세요.',
      requiresApproval: true,
    };
  } catch (error) {
    return {
      success: false,
      message: error instanceof Error ? error.message : '회원가입에 실패했습니다.',
      requiresApproval: false,
    };
  }
}
```

### 3.2 로그인 플로우 (승인 체크 포함)

```typescript
// services/authService.ts

interface LoginResult {
  success: boolean;
  message: string;
  approved: boolean;
  user?: User;
}

export async function login(email: string, password: string): Promise<LoginResult> {
  try {
    // 1. Supabase Auth 로그인
    const { data: authData, error: authError } = await supabase.auth.signInWithPassword({
      email,
      password,
    });

    if (authError) {
      throw authError;
    }

    // 2. 승인 상태 확인
    const { data: profile, error: profileError } = await supabase
      .from('user_profiles')
      .select('approved, name')
      .eq('id', authData.user.id)
      .single();

    if (profileError) {
      throw profileError;
    }

    // 3. 미승인 사용자 처리
    if (!profile.approved) {
      // 세션은 유지하되 접근 제한
      return {
        success: true,
        message: '관리자 승인을 기다리고 있습니다.',
        approved: false,
        user: authData.user,
      };
    }

    return {
      success: true,
      message: '로그인 성공',
      approved: true,
      user: authData.user,
    };
  } catch (error) {
    return {
      success: false,
      message: error instanceof Error ? error.message : '로그인에 실패했습니다.',
      approved: false,
    };
  }
}
```

### 3.3 미승인 사용자 리다이렉트

```typescript
// hooks/useAuthGuard.ts

import { useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuthStore } from '@/stores/authStore';

export function useAuthGuard() {
  const navigate = useNavigate();
  const { user, isApproved, isLoading } = useAuthStore();

  useEffect(() => {
    if (isLoading) return;

    // 로그인되지 않은 경우
    if (!user) {
      navigate('/login');
      return;
    }

    // 미승인 사용자
    if (!isApproved) {
      navigate('/pending-approval');
      return;
    }
  }, [user, isApproved, isLoading, navigate]);

  return { user, isApproved, isLoading };
}
```

---

## 4. 권한 레벨 정의

### 4.1 권한 체계

```typescript
// types/auth.ts

export enum UserRole {
  UNAPPROVED = 'unapproved',  // 미승인 사용자
  USER = 'user',              // 승인된 일반 사용자
  ADMIN = 'admin',            // 관리자
}

export interface UserPermissions {
  canAccessDashboard: boolean;
  canCreateLandingPage: boolean;
  canUseChatbot: boolean;
  canViewHistory: boolean;
  canApproveUsers: boolean;
  canViewAllUsers: boolean;
  canModifySettings: boolean;
}

export const ROLE_PERMISSIONS: Record<UserRole, UserPermissions> = {
  [UserRole.UNAPPROVED]: {
    canAccessDashboard: false,
    canCreateLandingPage: false,
    canUseChatbot: false,
    canViewHistory: false,
    canApproveUsers: false,
    canViewAllUsers: false,
    canModifySettings: false,
  },
  [UserRole.USER]: {
    canAccessDashboard: true,
    canCreateLandingPage: true,
    canUseChatbot: true,
    canViewHistory: true,
    canApproveUsers: false,
    canViewAllUsers: false,
    canModifySettings: false,
  },
  [UserRole.ADMIN]: {
    canAccessDashboard: true,
    canCreateLandingPage: true,
    canUseChatbot: true,
    canViewHistory: true,
    canApproveUsers: true,
    canViewAllUsers: true,
    canModifySettings: true,
  },
};
```

### 4.2 권한별 접근 가능 리소스

| 리소스 | 미승인 사용자 | 승인된 사용자 | 관리자 |
|--------|-------------|--------------|--------|
| 승인 대기 화면 | O | - | - |
| 대시보드 | X | O | O |
| AI 기획 도우미 | X | O | O |
| 랜딩페이지 빌더 | X | O | O |
| 마그네틱 세일즈 챗봇 | X | O | O |
| 내 프로젝트 목록 | X | O | O |
| 사용자 관리 | X | X | O |
| 전체 사용자 조회 | X | X | O |
| 시스템 설정 | X | X | O |

### 4.3 관리자 설정

```sql
-- 관리자 역할 추가 테이블
CREATE TABLE public.admin_users (
  user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  role TEXT NOT NULL DEFAULT 'admin' CHECK (role IN ('admin', 'super_admin')),
  granted_by UUID REFERENCES auth.users(id),
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 관리자 확인 함수
CREATE OR REPLACE FUNCTION public.is_admin(user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.admin_users WHERE admin_users.user_id = $1
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

---

## 5. Row Level Security (RLS) 정책

### 5.1 user_profiles 테이블

```sql
-- RLS 활성화
ALTER TABLE public.user_profiles ENABLE ROW LEVEL SECURITY;

-- 자기 프로필 읽기
CREATE POLICY "Users can read own profile"
  ON public.user_profiles
  FOR SELECT
  USING (auth.uid() = id);

-- 자기 프로필 수정 (approved 제외)
CREATE POLICY "Users can update own profile (except approved)"
  ON public.user_profiles
  FOR UPDATE
  USING (auth.uid() = id)
  WITH CHECK (
    auth.uid() = id
    AND (
      -- approved 필드 변경 방지 (관리자만 가능)
      OLD.approved = NEW.approved
      OR public.is_admin(auth.uid())
    )
  );

-- 관리자: 모든 프로필 읽기
CREATE POLICY "Admins can read all profiles"
  ON public.user_profiles
  FOR SELECT
  USING (public.is_admin(auth.uid()));

-- 관리자: 모든 프로필 수정
CREATE POLICY "Admins can update all profiles"
  ON public.user_profiles
  FOR UPDATE
  USING (public.is_admin(auth.uid()));
```

### 5.2 projects 테이블 (랜딩페이지/상세페이지)

```sql
-- 테이블 정의
CREATE TABLE public.projects (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  type TEXT NOT NULL CHECK (type IN ('landing', 'detail')),
  content JSONB,
  status TEXT DEFAULT 'draft' CHECK (status IN ('draft', 'published', 'archived')),
  published_url TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- RLS 활성화
ALTER TABLE public.projects ENABLE ROW LEVEL SECURITY;

-- 승인된 사용자만 자기 프로젝트 CRUD 가능
CREATE POLICY "Approved users can CRUD own projects"
  ON public.projects
  FOR ALL
  USING (
    auth.uid() = user_id
    AND EXISTS (
      SELECT 1 FROM public.user_profiles
      WHERE id = auth.uid() AND approved = TRUE
    )
  )
  WITH CHECK (
    auth.uid() = user_id
    AND EXISTS (
      SELECT 1 FROM public.user_profiles
      WHERE id = auth.uid() AND approved = TRUE
    )
  );

-- 관리자: 모든 프로젝트 읽기
CREATE POLICY "Admins can read all projects"
  ON public.projects
  FOR SELECT
  USING (public.is_admin(auth.uid()));
```

### 5.3 chat_conversations 테이블

```sql
-- 테이블 정의
CREATE TABLE public.chat_conversations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  type TEXT NOT NULL CHECK (type IN ('planner', 'sales_chatbot')),
  title TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE public.chat_messages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  conversation_id UUID NOT NULL REFERENCES public.chat_conversations(id) ON DELETE CASCADE,
  role TEXT NOT NULL CHECK (role IN ('user', 'assistant', 'system')),
  content TEXT NOT NULL,
  metadata JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- RLS 활성화
ALTER TABLE public.chat_conversations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.chat_messages ENABLE ROW LEVEL SECURITY;

-- 승인된 사용자만 자기 대화 접근
CREATE POLICY "Approved users can access own conversations"
  ON public.chat_conversations
  FOR ALL
  USING (
    auth.uid() = user_id
    AND EXISTS (
      SELECT 1 FROM public.user_profiles
      WHERE id = auth.uid() AND approved = TRUE
    )
  );

CREATE POLICY "Approved users can access own messages"
  ON public.chat_messages
  FOR ALL
  USING (
    EXISTS (
      SELECT 1 FROM public.chat_conversations
      WHERE id = chat_messages.conversation_id
      AND user_id = auth.uid()
    )
    AND EXISTS (
      SELECT 1 FROM public.user_profiles
      WHERE id = auth.uid() AND approved = TRUE
    )
  );
```

### 5.4 uploaded_images 테이블

```sql
-- 테이블 정의
CREATE TABLE public.uploaded_images (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  project_id UUID REFERENCES public.projects(id) ON DELETE SET NULL,
  bucket TEXT NOT NULL,
  path TEXT NOT NULL,
  filename TEXT NOT NULL,
  mime_type TEXT NOT NULL,
  size_bytes INTEGER NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- RLS 활성화
ALTER TABLE public.uploaded_images ENABLE ROW LEVEL SECURITY;

-- 승인된 사용자만 자기 이미지 접근
CREATE POLICY "Approved users can CRUD own images"
  ON public.uploaded_images
  FOR ALL
  USING (
    auth.uid() = user_id
    AND EXISTS (
      SELECT 1 FROM public.user_profiles
      WHERE id = auth.uid() AND approved = TRUE
    )
  );
```

---

## 6. API 보안

### 6.1 Edge Function 인증 검증

```typescript
// supabase/functions/ai-chat/index.ts

import { serve } from 'https://deno.land/std@0.177.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',  // 프로덕션에서는 특정 도메인으로 제한
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req) => {
  // CORS Preflight
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    // 1. Authorization 헤더에서 JWT 추출
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response(
        JSON.stringify({ error: '인증이 필요합니다.' }),
        { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // 2. Supabase 클라이언트 생성 및 사용자 검증
    const supabase = createClient(
      Deno.env.get('SUPABASE_URL')!,
      Deno.env.get('SUPABASE_ANON_KEY')!,
      {
        global: { headers: { Authorization: authHeader } },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      return new Response(
        JSON.stringify({ error: '유효하지 않은 토큰입니다.' }),
        { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // 3. 승인 상태 확인
    const { data: profile, error: profileError } = await supabase
      .from('user_profiles')
      .select('approved')
      .eq('id', user.id)
      .single();

    if (profileError || !profile?.approved) {
      return new Response(
        JSON.stringify({ error: '승인되지 않은 사용자입니다.' }),
        { status: 403, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // 4. Rate Limiting 체크 (아래 섹션 참조)
    const rateLimitResult = await checkRateLimit(user.id);
    if (!rateLimitResult.allowed) {
      return new Response(
        JSON.stringify({
          error: '요청 한도를 초과했습니다.',
          retryAfter: rateLimitResult.retryAfter
        }),
        {
          status: 429,
          headers: {
            ...corsHeaders,
            'Content-Type': 'application/json',
            'Retry-After': String(rateLimitResult.retryAfter)
          }
        }
      );
    }

    // 5. 비즈니스 로직 실행 (Claude API 호출 등)
    const body = await req.json();
    const result = await processAIRequest(body, user.id);

    return new Response(
      JSON.stringify(result),
      { status: 200, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );

  } catch (error) {
    console.error('Edge Function Error:', error);
    return new Response(
      JSON.stringify({ error: '서버 오류가 발생했습니다.' }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
});
```

### 6.2 Claude API 키 보호

```typescript
// supabase/functions/_shared/claudeClient.ts

// API 키는 환경변수에서만 접근 (클라이언트에 절대 노출 금지)
const CLAUDE_API_KEY = Deno.env.get('CLAUDE_API_KEY');

if (!CLAUDE_API_KEY) {
  throw new Error('CLAUDE_API_KEY is not configured');
}

export async function callClaudeAPI(
  messages: Array<{ role: string; content: string }>,
  systemPrompt: string
) {
  const response = await fetch('https://api.anthropic.com/v1/messages', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'x-api-key': CLAUDE_API_KEY,
      'anthropic-version': '2023-06-01',
    },
    body: JSON.stringify({
      model: 'claude-3-5-sonnet-20241022',
      max_tokens: 4096,
      system: systemPrompt,
      messages,
    }),
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(`Claude API Error: ${error.error?.message || 'Unknown error'}`);
  }

  return response.json();
}
```

### 6.3 Rate Limiting

```typescript
// supabase/functions/_shared/rateLimit.ts

interface RateLimitConfig {
  windowMs: number;      // 시간 윈도우 (밀리초)
  maxRequests: number;   // 최대 요청 수
}

const RATE_LIMITS: Record<string, RateLimitConfig> = {
  'ai-chat': { windowMs: 60000, maxRequests: 20 },        // 분당 20회
  'ai-generate': { windowMs: 60000, maxRequests: 10 },    // 분당 10회
  'image-upload': { windowMs: 3600000, maxRequests: 50 }, // 시간당 50회
};

export async function checkRateLimit(
  userId: string,
  endpoint: string = 'ai-chat'
): Promise<{ allowed: boolean; retryAfter: number }> {
  const config = RATE_LIMITS[endpoint] || RATE_LIMITS['ai-chat'];
  const key = `rate_limit:${endpoint}:${userId}`;
  const now = Date.now();
  const windowStart = now - config.windowMs;

  // Redis 또는 Supabase 테이블로 구현
  // 여기서는 간단한 Supabase 테이블 예시

  const { data: requests, error } = await supabase
    .from('rate_limit_logs')
    .select('created_at')
    .eq('user_id', userId)
    .eq('endpoint', endpoint)
    .gte('created_at', new Date(windowStart).toISOString());

  if (error) {
    console.error('Rate limit check error:', error);
    return { allowed: true, retryAfter: 0 }; // 에러 시 통과 (fail-open)
  }

  if (requests.length >= config.maxRequests) {
    const oldestRequest = new Date(requests[0].created_at).getTime();
    const retryAfter = Math.ceil((oldestRequest + config.windowMs - now) / 1000);
    return { allowed: false, retryAfter };
  }

  // 요청 기록
  await supabase.from('rate_limit_logs').insert({
    user_id: userId,
    endpoint,
    created_at: new Date().toISOString(),
  });

  return { allowed: true, retryAfter: 0 };
}
```

### 6.4 Rate Limit 테이블

```sql
-- Rate Limit 로그 테이블
CREATE TABLE public.rate_limit_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id),
  endpoint TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 인덱스 (빠른 조회를 위해)
CREATE INDEX idx_rate_limit_user_endpoint_time
  ON public.rate_limit_logs(user_id, endpoint, created_at DESC);

-- 오래된 로그 자동 삭제 (cron job 또는 pg_cron)
-- 24시간 이상 된 로그 삭제
CREATE OR REPLACE FUNCTION public.cleanup_rate_limit_logs()
RETURNS void AS $$
BEGIN
  DELETE FROM public.rate_limit_logs
  WHERE created_at < NOW() - INTERVAL '24 hours';
END;
$$ LANGUAGE plpgsql;
```

---

## 7. 프론트엔드 보안

### 7.1 XSS (Cross-Site Scripting) 방지

```typescript
// utils/sanitize.ts

import DOMPurify from 'dompurify';

/**
 * HTML 문자열 살균 (XSS 방지)
 * 사용자 입력을 HTML로 렌더링할 때 반드시 사용
 */
export function sanitizeHTML(dirty: string): string {
  return DOMPurify.sanitize(dirty, {
    ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'p', 'br', 'ul', 'ol', 'li', 'a'],
    ALLOWED_ATTR: ['href', 'target', 'rel'],
    ALLOW_DATA_ATTR: false,
  });
}

/**
 * 일반 텍스트용 이스케이프
 */
export function escapeHTML(text: string): string {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// 사용 예시 (React 컴포넌트)
function UserContent({ html }: { html: string }) {
  return (
    <div
      dangerouslySetInnerHTML={{
        __html: sanitizeHTML(html)
      }}
    />
  );
}
```

### 7.2 입력 검증

```typescript
// utils/validation.ts

import { z } from 'zod';

// 회원가입 스키마
export const signUpSchema = z.object({
  email: z.string()
    .email('유효한 이메일을 입력해주세요.')
    .max(255, '이메일이 너무 깁니다.'),
  password: z.string()
    .min(8, '비밀번호는 최소 8자 이상이어야 합니다.')
    .max(72, '비밀번호는 72자를 초과할 수 없습니다.')
    .regex(
      /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/,
      '비밀번호는 대문자, 소문자, 숫자를 포함해야 합니다.'
    ),
  name: z.string()
    .min(2, '이름은 최소 2자 이상이어야 합니다.')
    .max(50, '이름이 너무 깁니다.')
    .regex(/^[가-힣a-zA-Z\s]+$/, '이름에 특수문자를 사용할 수 없습니다.'),
});

// 프로젝트 생성 스키마
export const projectSchema = z.object({
  name: z.string()
    .min(1, '프로젝트 이름을 입력해주세요.')
    .max(100, '프로젝트 이름이 너무 깁니다.'),
  type: z.enum(['landing', 'detail']),
  content: z.object({}).passthrough().optional(),
});

// 채팅 메시지 스키마
export const chatMessageSchema = z.object({
  content: z.string()
    .min(1, '메시지를 입력해주세요.')
    .max(10000, '메시지가 너무 깁니다.'),
});
```

### 7.3 CSRF 방지

```typescript
// Supabase는 기본적으로 JWT 기반 인증을 사용하므로
// CSRF 토큰이 필요하지 않음 (쿠키 기반이 아님)

// 하지만 추가 보안을 위해 Origin/Referer 검증 가능

// supabase/functions/_shared/csrfCheck.ts
export function validateOrigin(req: Request): boolean {
  const origin = req.headers.get('Origin');
  const referer = req.headers.get('Referer');

  const allowedOrigins = [
    'https://magnetic-sales.vercel.app',
    'http://localhost:5173', // 개발 환경
  ];

  if (origin && !allowedOrigins.includes(origin)) {
    return false;
  }

  if (referer) {
    const refererUrl = new URL(referer);
    if (!allowedOrigins.some(o => referer.startsWith(o))) {
      return false;
    }
  }

  return true;
}
```

### 7.4 민감 정보 로컬 저장 금지

```typescript
// stores/authStore.ts

import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';

interface AuthState {
  user: User | null;
  isApproved: boolean;
  // 주의: 토큰은 저장하지 않음 (Supabase가 관리)
  setUser: (user: User | null) => void;
  setApproved: (approved: boolean) => void;
  logout: () => void;
}

export const useAuthStore = create<AuthState>()(
  persist(
    (set) => ({
      user: null,
      isApproved: false,
      setUser: (user) => set({ user }),
      setApproved: (approved) => set({ isApproved: approved }),
      logout: () => {
        set({ user: null, isApproved: false });
        // Supabase 세션도 클리어
        supabase.auth.signOut();
      },
    }),
    {
      name: 'auth-storage',
      storage: createJSONStorage(() => sessionStorage), // localStorage 대신 sessionStorage
      partialize: (state) => ({
        // 민감하지 않은 정보만 저장
        isApproved: state.isApproved,
        // user 객체에서 민감 정보 제외
        user: state.user ? {
          id: state.user.id,
          email: state.user.email,
        } : null,
      }),
    }
  )
);

// 절대 저장하지 말아야 할 것들:
// - JWT 토큰 (Supabase가 자동 관리)
// - 비밀번호
// - API 키
// - 개인 식별 정보 (주민번호, 카드번호 등)
```

### 7.5 보안 헤더 설정 (Vercel)

```json
// vercel.json
{
  "headers": [
    {
      "source": "/(.*)",
      "headers": [
        {
          "key": "X-Content-Type-Options",
          "value": "nosniff"
        },
        {
          "key": "X-Frame-Options",
          "value": "DENY"
        },
        {
          "key": "X-XSS-Protection",
          "value": "1; mode=block"
        },
        {
          "key": "Referrer-Policy",
          "value": "strict-origin-when-cross-origin"
        },
        {
          "key": "Content-Security-Policy",
          "value": "default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data: blob: https:; connect-src 'self' https://*.supabase.co https://api.anthropic.com; frame-ancestors 'none';"
        },
        {
          "key": "Permissions-Policy",
          "value": "camera=(), microphone=(), geolocation=()"
        }
      ]
    }
  ]
}
```

---

## 8. 이미지 업로드 보안

### 8.1 파일 타입 검증

```typescript
// utils/imageValidation.ts

// 허용된 MIME 타입
const ALLOWED_MIME_TYPES = [
  'image/jpeg',
  'image/png',
  'image/gif',
  'image/webp',
];

// 허용된 확장자
const ALLOWED_EXTENSIONS = ['.jpg', '.jpeg', '.png', '.gif', '.webp'];

// 매직 바이트 시그니처 (파일 헤더)
const MAGIC_BYTES: Record<string, number[]> = {
  'image/jpeg': [0xFF, 0xD8, 0xFF],
  'image/png': [0x89, 0x50, 0x4E, 0x47],
  'image/gif': [0x47, 0x49, 0x46],
  'image/webp': [0x52, 0x49, 0x46, 0x46], // RIFF
};

export interface ImageValidationResult {
  valid: boolean;
  error?: string;
}

export async function validateImage(file: File): Promise<ImageValidationResult> {
  // 1. MIME 타입 검증
  if (!ALLOWED_MIME_TYPES.includes(file.type)) {
    return {
      valid: false,
      error: `허용되지 않은 파일 형식입니다. (${ALLOWED_MIME_TYPES.join(', ')} 만 가능)`,
    };
  }

  // 2. 확장자 검증
  const extension = file.name.toLowerCase().slice(file.name.lastIndexOf('.'));
  if (!ALLOWED_EXTENSIONS.includes(extension)) {
    return {
      valid: false,
      error: '허용되지 않은 파일 확장자입니다.',
    };
  }

  // 3. 매직 바이트 검증 (실제 파일 내용 확인)
  const buffer = await file.slice(0, 12).arrayBuffer();
  const bytes = new Uint8Array(buffer);

  const expectedMagic = MAGIC_BYTES[file.type];
  if (expectedMagic) {
    const matches = expectedMagic.every((byte, i) => bytes[i] === byte);
    if (!matches) {
      return {
        valid: false,
        error: '파일 내용이 확장자와 일치하지 않습니다.',
      };
    }
  }

  return { valid: true };
}
```

### 8.2 파일 크기 제한

```typescript
// utils/imageValidation.ts (계속)

// 파일 크기 제한
const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB
const MAX_TOTAL_SIZE_PER_USER = 100 * 1024 * 1024; // 100MB

export function validateFileSize(file: File): ImageValidationResult {
  if (file.size > MAX_FILE_SIZE) {
    return {
      valid: false,
      error: `파일 크기가 너무 큽니다. (최대 ${MAX_FILE_SIZE / 1024 / 1024}MB)`,
    };
  }
  return { valid: true };
}

// 사용자별 총 용량 체크
export async function checkUserStorageQuota(userId: string): Promise<{
  used: number;
  limit: number;
  remaining: number;
  canUpload: (fileSize: number) => boolean;
}> {
  const { data, error } = await supabase
    .from('uploaded_images')
    .select('size_bytes')
    .eq('user_id', userId);

  if (error) {
    throw error;
  }

  const used = data.reduce((sum, img) => sum + img.size_bytes, 0);
  const remaining = MAX_TOTAL_SIZE_PER_USER - used;

  return {
    used,
    limit: MAX_TOTAL_SIZE_PER_USER,
    remaining,
    canUpload: (fileSize: number) => fileSize <= remaining,
  };
}
```

### 8.3 이미지 업로드 서비스

```typescript
// services/imageUploadService.ts

import { validateImage, validateFileSize, checkUserStorageQuota } from '@/utils/imageValidation';

export interface UploadResult {
  success: boolean;
  url?: string;
  error?: string;
}

export async function uploadImage(file: File, userId: string, projectId?: string): Promise<UploadResult> {
  try {
    // 1. 클라이언트 측 검증
    const typeValidation = await validateImage(file);
    if (!typeValidation.valid) {
      return { success: false, error: typeValidation.error };
    }

    const sizeValidation = validateFileSize(file);
    if (!sizeValidation.valid) {
      return { success: false, error: sizeValidation.error };
    }

    // 2. 용량 체크
    const quota = await checkUserStorageQuota(userId);
    if (!quota.canUpload(file.size)) {
      return {
        success: false,
        error: `저장 공간이 부족합니다. (남은 용량: ${(quota.remaining / 1024 / 1024).toFixed(1)}MB)`,
      };
    }

    // 3. 파일명 생성 (UUID + 원본 확장자)
    const extension = file.name.slice(file.name.lastIndexOf('.'));
    const fileName = `${crypto.randomUUID()}${extension}`;
    const filePath = `${userId}/${projectId || 'general'}/${fileName}`;

    // 4. Supabase Storage 업로드
    const { data, error } = await supabase.storage
      .from('images')
      .upload(filePath, file, {
        cacheControl: '3600',
        upsert: false,
        contentType: file.type,
      });

    if (error) {
      throw error;
    }

    // 5. 공개 URL 생성
    const { data: { publicUrl } } = supabase.storage
      .from('images')
      .getPublicUrl(filePath);

    // 6. 메타데이터 저장
    await supabase.from('uploaded_images').insert({
      user_id: userId,
      project_id: projectId,
      bucket: 'images',
      path: filePath,
      filename: file.name,
      mime_type: file.type,
      size_bytes: file.size,
    });

    return { success: true, url: publicUrl };

  } catch (error) {
    console.error('Image upload error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : '이미지 업로드에 실패했습니다.',
    };
  }
}
```

### 8.4 Supabase Storage 보안 정책

```sql
-- Storage 버킷 정책 (Supabase Dashboard에서 설정)

-- images 버킷 생성
INSERT INTO storage.buckets (id, name, public)
VALUES ('images', 'images', true);

-- 업로드 정책: 승인된 사용자만 자기 폴더에 업로드
CREATE POLICY "Approved users can upload to own folder"
ON storage.objects FOR INSERT
WITH CHECK (
  bucket_id = 'images'
  AND auth.uid()::text = (storage.foldername(name))[1]
  AND EXISTS (
    SELECT 1 FROM public.user_profiles
    WHERE id = auth.uid() AND approved = TRUE
  )
);

-- 읽기 정책: 공개 (배포된 랜딩페이지용)
CREATE POLICY "Public read access"
ON storage.objects FOR SELECT
USING (bucket_id = 'images');

-- 삭제 정책: 소유자만 삭제 가능
CREATE POLICY "Users can delete own images"
ON storage.objects FOR DELETE
USING (
  bucket_id = 'images'
  AND auth.uid()::text = (storage.foldername(name))[1]
);
```

---

## 9. 보안 체크리스트

### 9.1 OWASP Top 10 대응

| # | 취약점 | 대응 방안 | 상태 |
|---|--------|----------|------|
| A01 | Broken Access Control | RLS 정책, 권한 레벨 시스템, approved 체크 | 적용됨 |
| A02 | Cryptographic Failures | Supabase 기본 암호화, HTTPS 강제 | 적용됨 |
| A03 | Injection | 입력 검증 (Zod), 파라미터화된 쿼리 (Supabase) | 적용됨 |
| A04 | Insecure Design | 수동 승인 플로우, 권한 분리 | 적용됨 |
| A05 | Security Misconfiguration | 보안 헤더, CORS 설정, 환경변수 관리 | 적용됨 |
| A06 | Vulnerable Components | npm audit, 의존성 업데이트 | 운영 시 |
| A07 | Auth Failures | Supabase Auth, JWT, 비밀번호 정책 | 적용됨 |
| A08 | Data Integrity Failures | 서명된 JWT, 입력 검증 | 적용됨 |
| A09 | Logging Failures | Edge Function 로깅, approval_logs | 적용됨 |
| A10 | SSRF | Edge Function에서 URL 검증 | 적용됨 |

### 9.2 상세페이지 빌더 보안 이슈 해결

기존 상세페이지 빌더에서 발견된 보안 문제와 해결 방안:

| 문제 | 기존 코드 | 해결 방안 |
|------|----------|----------|
| API 키 클라이언트 노출 | `Vite define`으로 빌드 시 주입 | Supabase Edge Function에서만 API 키 사용 |
| 환경변수 노출 | `.env.local`을 클라이언트에서 직접 사용 | 서버 사이드 환경변수로 이동 |
| 인증 없음 | 누구나 API 호출 가능 | JWT 인증 + approved 체크 필수 |
| Rate Limiting 없음 | 무제한 API 호출 | 사용자별/엔드포인트별 제한 적용 |

```typescript
// 기존 문제 코드 (상세페이지 빌더)
// vite.config.ts
export default defineConfig({
  define: {
    'process.env.GEMINI_API_KEY': JSON.stringify(env.VITE_GEMINI_API_KEY),
  },
});

// 수정된 아키텍처 (마그네틱 세일즈 웹앱)
// 클라이언트 → Edge Function → Claude API
// API 키는 Edge Function의 환경변수에만 존재
```

### 9.3 배포 전 보안 체크리스트

```markdown
## 배포 전 체크리스트

### 인증/인가
- [ ] 모든 API 엔드포인트에 인증 필수
- [ ] 미승인 사용자 접근 차단 확인
- [ ] 관리자 권한 분리 확인
- [ ] RLS 정책 테스트 완료

### API 보안
- [ ] Claude API 키가 서버 사이드에만 존재
- [ ] Rate Limiting 동작 확인
- [ ] CORS 설정 확인
- [ ] 에러 메시지에 민감 정보 미포함

### 프론트엔드
- [ ] XSS 방지 (DOMPurify 적용)
- [ ] 입력 검증 (Zod 스키마)
- [ ] 보안 헤더 설정
- [ ] localStorage에 민감 정보 미저장

### 이미지 업로드
- [ ] 파일 타입 검증
- [ ] 파일 크기 제한
- [ ] 사용자별 용량 제한
- [ ] Storage 정책 설정

### 인프라
- [ ] HTTPS 적용
- [ ] 환경변수 설정 확인
- [ ] 로깅 활성화
- [ ] 백업 설정
```

---

## 10. 부록

### 10.1 환경변수 목록

```bash
# .env (프론트엔드 - Vercel)
VITE_SUPABASE_URL=https://xxx.supabase.co
VITE_SUPABASE_ANON_KEY=eyJxxx...

# Supabase Edge Functions 환경변수
CLAUDE_API_KEY=sk-ant-xxx...
SUPABASE_SERVICE_ROLE_KEY=eyJxxx...  # RLS 우회용 (관리 작업)

# 절대 클라이언트에 노출되면 안 되는 키:
# - CLAUDE_API_KEY
# - SUPABASE_SERVICE_ROLE_KEY
```

### 10.2 보안 관련 npm 패키지

```json
{
  "dependencies": {
    "@supabase/supabase-js": "^2.x",
    "dompurify": "^3.x",
    "zod": "^3.x"
  },
  "devDependencies": {
    "@types/dompurify": "^3.x"
  }
}
```

### 10.3 참고 문서

- [Supabase Auth 문서](https://supabase.com/docs/guides/auth)
- [Supabase RLS 가이드](https://supabase.com/docs/guides/auth/row-level-security)
- [OWASP Top 10](https://owasp.org/Top10/)
- [Claude API 문서](https://docs.anthropic.com/claude/reference/getting-started-with-the-api)

---

## 문서 이력

| 버전 | 날짜 | 변경 내용 | 작성자 |
|------|------|----------|--------|
| 1.0 | 2025-12-15 | 초안 작성 | Security Analyst Agent |
