# 데이터베이스 PRD

## 문서 정보

| 항목 | 내용 |
|------|------|
| 버전 | PRD v1.0 |
| 작성일 | 2025-01-15 |
| 관련 기획 | 기획_v2/04_DB_설계_v2.md |
| 데이터베이스 | PostgreSQL 15 (Supabase) |

---

## 1. 개요

### 1.1 ER 다이어그램

```
┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│   profiles   │────<│landing_pages │────<│  qa_sessions │
└──────────────┘     └──────────────┘     └──────────────┘
       │                    │
       │                    │
       ├────────────────────┼─────────────────────────────┐
       │                    │                             │
       ▼                    ▼                             ▼
┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│ token_usage  │     │   audit_logs │     │ user_sessions│
└──────────────┘     └──────────────┘     └──────────────┘
       │
       ▼
┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│token_reserv. │     │refresh_tokens│     │ rate_limits  │
└──────────────┘     └──────────────┘     └──────────────┘
```

### 1.2 테이블 목록

| 테이블명 | 설명 | v2 상태 |
|----------|------|---------|
| profiles | 사용자 프로필 | deleted_at 추가 |
| landing_pages | 랜딩페이지 | deleted_at 추가 |
| qa_sessions | Q&A 세션 | deleted_at 추가 |
| token_usage | 토큰 사용 기록 | 기존 |
| token_reservations | 토큰 예약 | **신규** |
| refresh_tokens | 리프레시 토큰 | **신규** |
| audit_logs | 감사 로그 | **신규** |
| user_sessions | 사용자 세션 | **신규** |
| rate_limits | Rate Limit | **신규** |

---

## 2. 마이그레이션 파일

### 2.1 파일 구조

```
supabase/
└── migrations/
    ├── 001_initial_schema.sql
    ├── 002_soft_delete.sql
    ├── 003_refresh_tokens.sql
    ├── 004_audit_logs.sql
    ├── 005_rate_limits.sql
    ├── 006_token_reservations.sql
    └── 007_functions_triggers.sql
```

### 2.2 001_initial_schema.sql

```sql
-- ============================================
-- 001_initial_schema.sql
-- 기본 테이블 생성
-- ============================================

-- updated_at 자동 갱신 함수
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- profiles 테이블
-- ============================================
CREATE TABLE IF NOT EXISTS profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT NOT NULL,
    tier TEXT NOT NULL DEFAULT 'FREE' CHECK (tier IN ('FREE', 'PRO', 'ENTERPRISE')),
    is_approved BOOLEAN NOT NULL DEFAULT FALSE,
    agree_marketing BOOLEAN NOT NULL DEFAULT FALSE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 인덱스
CREATE INDEX IF NOT EXISTS idx_profiles_email ON profiles(email);
CREATE INDEX IF NOT EXISTS idx_profiles_tier ON profiles(tier);
CREATE INDEX IF NOT EXISTS idx_profiles_is_approved ON profiles(is_approved);

-- updated_at 트리거
CREATE TRIGGER update_profiles_updated_at
    BEFORE UPDATE ON profiles
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- RLS 활성화
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;

-- RLS 정책
CREATE POLICY "Users can view own profile"
    ON profiles FOR SELECT
    USING (auth.uid() = id);

CREATE POLICY "Users can update own profile"
    ON profiles FOR UPDATE
    USING (auth.uid() = id)
    WITH CHECK (auth.uid() = id);

-- ============================================
-- landing_pages 테이블
-- ============================================
CREATE TABLE IF NOT EXISTS landing_pages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
    qa_session_id UUID,
    title TEXT NOT NULL,
    content JSONB NOT NULL DEFAULT '{}',
    status TEXT NOT NULL DEFAULT 'draft' CHECK (status IN ('draft', 'published', 'archived')),
    slug TEXT UNIQUE,
    published_url TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 인덱스
CREATE INDEX IF NOT EXISTS idx_landing_pages_user_id ON landing_pages(user_id);
CREATE INDEX IF NOT EXISTS idx_landing_pages_status ON landing_pages(status);
CREATE INDEX IF NOT EXISTS idx_landing_pages_slug ON landing_pages(slug);

-- updated_at 트리거
CREATE TRIGGER update_landing_pages_updated_at
    BEFORE UPDATE ON landing_pages
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- RLS 활성화
ALTER TABLE landing_pages ENABLE ROW LEVEL SECURITY;

-- RLS 정책
CREATE POLICY "Users can view own landing pages"
    ON landing_pages FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can create landing pages"
    ON landing_pages FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update own landing pages"
    ON landing_pages FOR UPDATE
    USING (user_id = auth.uid())
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Anyone can view published landing pages"
    ON landing_pages FOR SELECT
    USING (status = 'published');

-- ============================================
-- qa_sessions 테이블
-- ============================================
CREATE TABLE IF NOT EXISTS qa_sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
    landing_page_id UUID REFERENCES landing_pages(id) ON DELETE SET NULL,
    answers JSONB NOT NULL DEFAULT '{}',
    current_step INTEGER NOT NULL DEFAULT 1 CHECK (current_step BETWEEN 1 AND 40),
    status TEXT NOT NULL DEFAULT 'in_progress' CHECK (status IN ('in_progress', 'completed', 'abandoned')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- landing_pages FK 추가
ALTER TABLE landing_pages
ADD CONSTRAINT fk_landing_pages_qa_session
FOREIGN KEY (qa_session_id) REFERENCES qa_sessions(id) ON DELETE SET NULL;

-- 인덱스
CREATE INDEX IF NOT EXISTS idx_qa_sessions_user_id ON qa_sessions(user_id);
CREATE INDEX IF NOT EXISTS idx_qa_sessions_status ON qa_sessions(status);

-- updated_at 트리거
CREATE TRIGGER update_qa_sessions_updated_at
    BEFORE UPDATE ON qa_sessions
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- RLS 활성화
ALTER TABLE qa_sessions ENABLE ROW LEVEL SECURITY;

-- RLS 정책
CREATE POLICY "Users can view own sessions"
    ON qa_sessions FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can create sessions"
    ON qa_sessions FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update own sessions"
    ON qa_sessions FOR UPDATE
    USING (user_id = auth.uid())
    WITH CHECK (user_id = auth.uid());

-- ============================================
-- token_usage 테이블
-- ============================================
CREATE TABLE IF NOT EXISTS token_usage (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
    tokens_used INTEGER NOT NULL CHECK (tokens_used > 0),
    action TEXT NOT NULL CHECK (action IN ('generate', 'regenerate', 'edit')),
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 인덱스
CREATE INDEX IF NOT EXISTS idx_token_usage_user_id ON token_usage(user_id);
CREATE INDEX IF NOT EXISTS idx_token_usage_created_at ON token_usage(created_at);
CREATE INDEX IF NOT EXISTS idx_token_usage_user_date ON token_usage(user_id, DATE(created_at));

-- RLS 활성화
ALTER TABLE token_usage ENABLE ROW LEVEL SECURITY;

-- RLS 정책
CREATE POLICY "Users can view own token usage"
    ON token_usage FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "System can insert token usage"
    ON token_usage FOR INSERT
    WITH CHECK (user_id = auth.uid());
```

### 2.3 002_soft_delete.sql

```sql
-- ============================================
-- 002_soft_delete.sql
-- Soft Delete 컬럼 추가
-- ============================================

-- profiles에 deleted_at 추가
ALTER TABLE profiles ADD COLUMN IF NOT EXISTS deleted_at TIMESTAMPTZ;
CREATE INDEX IF NOT EXISTS idx_profiles_deleted_at ON profiles(deleted_at) WHERE deleted_at IS NULL;

-- landing_pages에 deleted_at 추가
ALTER TABLE landing_pages ADD COLUMN IF NOT EXISTS deleted_at TIMESTAMPTZ;
CREATE INDEX IF NOT EXISTS idx_landing_pages_deleted_at ON landing_pages(deleted_at) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_landing_pages_user_deleted ON landing_pages(user_id, deleted_at);

-- qa_sessions에 deleted_at 추가
ALTER TABLE qa_sessions ADD COLUMN IF NOT EXISTS deleted_at TIMESTAMPTZ;
CREATE INDEX IF NOT EXISTS idx_qa_sessions_deleted_at ON qa_sessions(deleted_at) WHERE deleted_at IS NULL;

-- ============================================
-- RLS 정책 업데이트 (deleted_at 조건 추가)
-- ============================================

-- profiles 정책 업데이트
DROP POLICY IF EXISTS "Users can view own profile" ON profiles;
CREATE POLICY "Users can view own profile"
    ON profiles FOR SELECT
    USING (
        auth.uid() = id
        AND deleted_at IS NULL
    );

DROP POLICY IF EXISTS "Users can update own profile" ON profiles;
CREATE POLICY "Users can update own profile"
    ON profiles FOR UPDATE
    USING (
        auth.uid() = id
        AND deleted_at IS NULL
    )
    WITH CHECK (
        auth.uid() = id
        AND deleted_at IS NULL
    );

-- 관리자 정책
CREATE POLICY "Admins can view all profiles"
    ON profiles FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM profiles
            WHERE id = auth.uid()
            AND tier = 'ENTERPRISE'
            AND deleted_at IS NULL
        )
    );

CREATE POLICY "Admins can update approval status"
    ON profiles FOR UPDATE
    USING (
        EXISTS (
            SELECT 1 FROM profiles
            WHERE id = auth.uid()
            AND tier = 'ENTERPRISE'
            AND deleted_at IS NULL
        )
    );

-- landing_pages 정책 업데이트
DROP POLICY IF EXISTS "Users can view own landing pages" ON landing_pages;
CREATE POLICY "Users can view own active landing pages"
    ON landing_pages FOR SELECT
    USING (
        user_id = auth.uid()
        AND deleted_at IS NULL
    );

-- 삭제된 항목 조회 (복구용)
CREATE POLICY "Users can view own deleted landing pages for recovery"
    ON landing_pages FOR SELECT
    USING (
        user_id = auth.uid()
        AND deleted_at IS NOT NULL
        AND deleted_at > NOW() - INTERVAL '30 days'
    );

DROP POLICY IF EXISTS "Users can update own landing pages" ON landing_pages;
CREATE POLICY "Users can update own active landing pages"
    ON landing_pages FOR UPDATE
    USING (
        user_id = auth.uid()
        AND deleted_at IS NULL
    )
    WITH CHECK (user_id = auth.uid());

-- Soft Delete용 UPDATE 정책
CREATE POLICY "Users can soft delete own landing pages"
    ON landing_pages FOR UPDATE
    USING (user_id = auth.uid())
    WITH CHECK (user_id = auth.uid());

DROP POLICY IF EXISTS "Anyone can view published landing pages" ON landing_pages;
CREATE POLICY "Anyone can view published landing pages"
    ON landing_pages FOR SELECT
    USING (
        status = 'published'
        AND deleted_at IS NULL
    );

-- qa_sessions 정책 업데이트
DROP POLICY IF EXISTS "Users can view own sessions" ON qa_sessions;
CREATE POLICY "Users can view own active sessions"
    ON qa_sessions FOR SELECT
    USING (
        user_id = auth.uid()
        AND deleted_at IS NULL
    );

DROP POLICY IF EXISTS "Users can update own sessions" ON qa_sessions;
CREATE POLICY "Users can update own active sessions"
    ON qa_sessions FOR UPDATE
    USING (
        user_id = auth.uid()
        AND deleted_at IS NULL
    )
    WITH CHECK (user_id = auth.uid());
```

### 2.4 003_refresh_tokens.sql

```sql
-- ============================================
-- 003_refresh_tokens.sql
-- Refresh Token 관리 테이블
-- ============================================

CREATE TABLE IF NOT EXISTS refresh_tokens (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
    token_hash TEXT NOT NULL,
    revoked BOOLEAN NOT NULL DEFAULT FALSE,
    revoked_at TIMESTAMPTZ,
    expires_at TIMESTAMPTZ NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- 유니크 제약 (해시 충돌 방지)
    CONSTRAINT unique_token_hash UNIQUE (token_hash)
);

-- 인덱스
CREATE INDEX IF NOT EXISTS idx_refresh_tokens_user_id ON refresh_tokens(user_id);
CREATE INDEX IF NOT EXISTS idx_refresh_tokens_token_hash ON refresh_tokens(token_hash);
CREATE INDEX IF NOT EXISTS idx_refresh_tokens_expires_at ON refresh_tokens(expires_at);
CREATE INDEX IF NOT EXISTS idx_refresh_tokens_user_active ON refresh_tokens(user_id, revoked)
    WHERE revoked = FALSE;

-- RLS 활성화 (서버 사이드 전용)
ALTER TABLE refresh_tokens ENABLE ROW LEVEL SECURITY;

-- 서버 사이드에서만 접근 (service role)
-- 클라이언트 직접 접근 불가

-- ============================================
-- user_sessions 테이블
-- ============================================

CREATE TABLE IF NOT EXISTS user_sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
    ip_address INET,
    user_agent TEXT,
    invalidated_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 인덱스
CREATE INDEX IF NOT EXISTS idx_user_sessions_user_id ON user_sessions(user_id);
CREATE INDEX IF NOT EXISTS idx_user_sessions_user_active ON user_sessions(user_id, invalidated_at)
    WHERE invalidated_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_user_sessions_created_at ON user_sessions(created_at);

-- RLS 활성화
ALTER TABLE user_sessions ENABLE ROW LEVEL SECURITY;

-- RLS 정책
CREATE POLICY "Users can view own sessions"
    ON user_sessions FOR SELECT
    USING (user_id = auth.uid());
```

### 2.5 004_audit_logs.sql

```sql
-- ============================================
-- 004_audit_logs.sql
-- 감사 로그 테이블
-- ============================================

CREATE TABLE IF NOT EXISTS audit_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES profiles(id) ON DELETE SET NULL,
    action TEXT NOT NULL,
    details JSONB DEFAULT '{}',
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 인덱스
CREATE INDEX IF NOT EXISTS idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_action ON audit_logs(action);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON audit_logs(created_at);
CREATE INDEX IF NOT EXISTS idx_audit_logs_ip_address ON audit_logs(ip_address);

-- RLS 활성화
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;

-- 일반 사용자: 자신의 로그만 조회
CREATE POLICY "Users can view own audit logs"
    ON audit_logs FOR SELECT
    USING (user_id = auth.uid());

-- 관리자: 모든 로그 조회
CREATE POLICY "Admins can view all audit logs"
    ON audit_logs FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM profiles
            WHERE id = auth.uid()
            AND tier = 'ENTERPRISE'
            AND deleted_at IS NULL
        )
    );

-- 감사 대상 액션 정의
COMMENT ON TABLE audit_logs IS '
감사 대상 액션:
- signup: 회원가입
- login: 로그인
- login_failed: 로그인 실패
- logout: 로그아웃
- password_change: 비밀번호 변경
- profile_update: 프로필 수정
- approval_change: 승인 상태 변경
- sessions_invalidated: 세션 무효화
- token_reuse_detected: 토큰 재사용 감지 (CRITICAL)
- landing_page_created: LP 생성
- landing_page_updated: LP 수정
- landing_page_deleted: LP 삭제 (soft)
- landing_page_restored: LP 복구
- landing_page_permanently_deleted: LP 영구 삭제
- ai_generation: AI 생성 요청
- ai_generation_failed: AI 생성 실패
- rate_limit_exceeded: Rate Limit 초과
- cors_blocked: CORS 차단
- error: 일반 에러
';
```

### 2.6 005_rate_limits.sql

```sql
-- ============================================
-- 005_rate_limits.sql
-- Rate Limiting 테이블 및 함수
-- ============================================

CREATE TABLE IF NOT EXISTS rate_limits (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL,
    endpoint TEXT NOT NULL,
    request_count INTEGER NOT NULL DEFAULT 1,
    window_start TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- 복합 유니크 키
    CONSTRAINT unique_rate_limit UNIQUE (identifier, endpoint, window_start)
);

-- 인덱스
CREATE INDEX IF NOT EXISTS idx_rate_limits_identifier ON rate_limits(identifier);
CREATE INDEX IF NOT EXISTS idx_rate_limits_endpoint ON rate_limits(endpoint);
CREATE INDEX IF NOT EXISTS idx_rate_limits_window_start ON rate_limits(window_start);
CREATE INDEX IF NOT EXISTS idx_rate_limits_lookup ON rate_limits(identifier, endpoint, window_start);

-- RLS 활성화 (서버 사이드 전용)
ALTER TABLE rate_limits ENABLE ROW LEVEL SECURITY;

-- ============================================
-- Rate Limit 체크 함수
-- ============================================

CREATE OR REPLACE FUNCTION check_rate_limit(
    p_identifier TEXT,
    p_endpoint TEXT,
    p_limit INTEGER,
    p_window_seconds INTEGER
)
RETURNS JSONB AS $$
DECLARE
    v_window_start TIMESTAMPTZ;
    v_current_count INTEGER;
BEGIN
    -- 윈도우 시작 시간 계산 (슬라이딩 윈도우)
    v_window_start := DATE_TRUNC('second', NOW())
        - (EXTRACT(EPOCH FROM NOW())::INTEGER % p_window_seconds) * INTERVAL '1 second';

    -- 현재 카운트 조회 및 증가
    INSERT INTO rate_limits (identifier, endpoint, request_count, window_start)
    VALUES (p_identifier, p_endpoint, 1, v_window_start)
    ON CONFLICT (identifier, endpoint, window_start)
    DO UPDATE SET request_count = rate_limits.request_count + 1
    RETURNING request_count INTO v_current_count;

    -- 제한 초과 확인
    IF v_current_count > p_limit THEN
        RETURN jsonb_build_object(
            'allowed', FALSE,
            'current', v_current_count,
            'limit', p_limit,
            'reset_at', v_window_start + (p_window_seconds * INTERVAL '1 second')
        );
    END IF;

    RETURN jsonb_build_object(
        'allowed', TRUE,
        'current', v_current_count,
        'limit', p_limit,
        'remaining', p_limit - v_current_count
    );
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- 오래된 Rate Limit 정리 함수
-- ============================================

CREATE OR REPLACE FUNCTION cleanup_old_rate_limits()
RETURNS INTEGER AS $$
DECLARE
    v_count INTEGER;
BEGIN
    DELETE FROM rate_limits
    WHERE window_start < NOW() - INTERVAL '1 hour';

    GET DIAGNOSTICS v_count = ROW_COUNT;
    RETURN v_count;
END;
$$ LANGUAGE plpgsql;
```

### 2.7 006_token_reservations.sql

```sql
-- ============================================
-- 006_token_reservations.sql
-- 토큰 예약 테이블 및 함수
-- ============================================

CREATE TABLE IF NOT EXISTS token_reservations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
    estimated_tokens INTEGER NOT NULL CHECK (estimated_tokens > 0),
    actual_tokens INTEGER,
    status TEXT NOT NULL DEFAULT 'reserved' CHECK (status IN ('reserved', 'confirmed', 'cancelled', 'expired')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    confirmed_at TIMESTAMPTZ
);

-- 인덱스
CREATE INDEX IF NOT EXISTS idx_token_reservations_user_id ON token_reservations(user_id);
CREATE INDEX IF NOT EXISTS idx_token_reservations_status ON token_reservations(status);
CREATE INDEX IF NOT EXISTS idx_token_reservations_created_at ON token_reservations(created_at);
CREATE INDEX IF NOT EXISTS idx_token_reservations_user_pending ON token_reservations(user_id, status)
    WHERE status = 'reserved';

-- RLS 활성화
ALTER TABLE token_reservations ENABLE ROW LEVEL SECURITY;

-- RLS 정책
CREATE POLICY "Users can view own reservations"
    ON token_reservations FOR SELECT
    USING (user_id = auth.uid());

-- ============================================
-- 토큰 예약 함수 (Advisory Lock 사용)
-- ============================================

CREATE OR REPLACE FUNCTION check_and_reserve_tokens(
    p_user_id UUID,
    p_estimated_tokens INTEGER
)
RETURNS JSONB AS $$
DECLARE
    v_tier TEXT;
    v_daily_limit INTEGER;
    v_used_today INTEGER;
    v_reserved_pending INTEGER;
    v_available INTEGER;
    v_reservation_id UUID;
BEGIN
    -- Advisory Lock 획득 (사용자별 직렬화)
    PERFORM pg_advisory_xact_lock(hashtext(p_user_id::text));

    -- 사용자 티어 확인
    SELECT tier INTO v_tier
    FROM profiles
    WHERE id = p_user_id AND deleted_at IS NULL;

    IF v_tier IS NULL THEN
        RETURN jsonb_build_object(
            'success', FALSE,
            'error', 'user_not_found'
        );
    END IF;

    -- 티어별 일일 한도
    v_daily_limit := CASE v_tier
        WHEN 'FREE' THEN 100000
        WHEN 'PRO' THEN 500000
        WHEN 'ENTERPRISE' THEN 2000000
        ELSE 100000
    END;

    -- 오늘 사용량 조회
    SELECT COALESCE(SUM(tokens_used), 0) INTO v_used_today
    FROM token_usage
    WHERE user_id = p_user_id
      AND created_at >= DATE_TRUNC('day', NOW());

    -- 대기 중인 예약량 조회 (10분 이내)
    SELECT COALESCE(SUM(estimated_tokens), 0) INTO v_reserved_pending
    FROM token_reservations
    WHERE user_id = p_user_id
      AND status = 'reserved'
      AND created_at > NOW() - INTERVAL '10 minutes';

    -- 사용 가능 토큰 계산
    v_available := v_daily_limit - v_used_today - v_reserved_pending;

    IF v_available < p_estimated_tokens THEN
        RETURN jsonb_build_object(
            'success', FALSE,
            'error', 'insufficient_tokens',
            'available', v_available,
            'requested', p_estimated_tokens,
            'daily_limit', v_daily_limit,
            'used_today', v_used_today,
            'reserved', v_reserved_pending
        );
    END IF;

    -- 예약 생성
    INSERT INTO token_reservations (user_id, estimated_tokens, status)
    VALUES (p_user_id, p_estimated_tokens, 'reserved')
    RETURNING id INTO v_reservation_id;

    RETURN jsonb_build_object(
        'success', TRUE,
        'reservation_id', v_reservation_id,
        'available_after', v_available - p_estimated_tokens,
        'daily_limit', v_daily_limit
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- 토큰 확정 함수
-- ============================================

CREATE OR REPLACE FUNCTION confirm_token_usage(
    p_reservation_id UUID,
    p_actual_tokens INTEGER
)
RETURNS JSONB AS $$
DECLARE
    v_reservation RECORD;
BEGIN
    -- 예약 조회 및 업데이트
    UPDATE token_reservations
    SET
        status = 'confirmed',
        actual_tokens = p_actual_tokens,
        confirmed_at = NOW()
    WHERE id = p_reservation_id AND status = 'reserved'
    RETURNING * INTO v_reservation;

    IF v_reservation IS NULL THEN
        RETURN jsonb_build_object(
            'success', FALSE,
            'error', 'reservation_not_found'
        );
    END IF;

    -- token_usage에 실제 사용량 기록
    INSERT INTO token_usage (user_id, tokens_used, action, metadata)
    VALUES (
        v_reservation.user_id,
        p_actual_tokens,
        'generate',
        jsonb_build_object('reservation_id', p_reservation_id)
    );

    RETURN jsonb_build_object(
        'success', TRUE,
        'estimated', v_reservation.estimated_tokens,
        'actual', p_actual_tokens,
        'difference', v_reservation.estimated_tokens - p_actual_tokens
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- 토큰 예약 취소 함수
-- ============================================

CREATE OR REPLACE FUNCTION cancel_token_reservation(
    p_reservation_id UUID
)
RETURNS JSONB AS $$
DECLARE
    v_updated INTEGER;
BEGIN
    UPDATE token_reservations
    SET status = 'cancelled'
    WHERE id = p_reservation_id AND status = 'reserved';

    GET DIAGNOSTICS v_updated = ROW_COUNT;

    IF v_updated = 0 THEN
        RETURN jsonb_build_object(
            'success', FALSE,
            'error', 'reservation_not_found'
        );
    END IF;

    RETURN jsonb_build_object('success', TRUE);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- 만료된 예약 정리 함수
-- ============================================

CREATE OR REPLACE FUNCTION cleanup_expired_reservations()
RETURNS INTEGER AS $$
DECLARE
    v_count INTEGER;
BEGIN
    UPDATE token_reservations
    SET status = 'expired'
    WHERE status = 'reserved'
      AND created_at < NOW() - INTERVAL '10 minutes';

    GET DIAGNOSTICS v_count = ROW_COUNT;
    RETURN v_count;
END;
$$ LANGUAGE plpgsql;
```

### 2.8 007_functions_triggers.sql

```sql
-- ============================================
-- 007_functions_triggers.sql
-- 세션 무효화 트리거 및 기타 함수
-- ============================================

-- ============================================
-- 승인 상태 변경 시 세션 무효화 트리거
-- ============================================

CREATE OR REPLACE FUNCTION invalidate_user_sessions()
RETURNS TRIGGER AS $$
BEGIN
    -- is_approved가 변경된 경우
    IF OLD.is_approved IS DISTINCT FROM NEW.is_approved THEN
        -- 모든 Refresh Token 폐기
        UPDATE refresh_tokens
        SET revoked = TRUE, revoked_at = NOW()
        WHERE user_id = NEW.id AND revoked = FALSE;

        -- 세션 무효화
        UPDATE user_sessions
        SET invalidated_at = NOW()
        WHERE user_id = NEW.id AND invalidated_at IS NULL;

        -- 감사 로그
        INSERT INTO audit_logs (user_id, action, details)
        VALUES (
            NEW.id,
            'sessions_invalidated',
            jsonb_build_object(
                'reason', 'approval_status_changed',
                'old_status', OLD.is_approved,
                'new_status', NEW.is_approved
            )
        );
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 트리거 생성
DROP TRIGGER IF EXISTS on_approval_change ON profiles;
CREATE TRIGGER on_approval_change
    AFTER UPDATE ON profiles
    FOR EACH ROW
    EXECUTE FUNCTION invalidate_user_sessions();

-- ============================================
-- 사용자 토큰 사용량 조회 함수
-- ============================================

CREATE OR REPLACE FUNCTION get_user_token_usage(p_user_id UUID)
RETURNS JSONB AS $$
DECLARE
    v_tier TEXT;
    v_daily_limit INTEGER;
    v_used_today INTEGER;
    v_reserved INTEGER;
BEGIN
    -- 사용자 티어 확인
    SELECT tier INTO v_tier
    FROM profiles
    WHERE id = p_user_id AND deleted_at IS NULL;

    IF v_tier IS NULL THEN
        RETURN jsonb_build_object('error', 'user_not_found');
    END IF;

    -- 티어별 일일 한도
    v_daily_limit := CASE v_tier
        WHEN 'FREE' THEN 100000
        WHEN 'PRO' THEN 500000
        WHEN 'ENTERPRISE' THEN 2000000
        ELSE 100000
    END;

    -- 오늘 사용량
    SELECT COALESCE(SUM(tokens_used), 0) INTO v_used_today
    FROM token_usage
    WHERE user_id = p_user_id
      AND created_at >= DATE_TRUNC('day', NOW());

    -- 대기 중인 예약량
    SELECT COALESCE(SUM(estimated_tokens), 0) INTO v_reserved
    FROM token_reservations
    WHERE user_id = p_user_id
      AND status = 'reserved'
      AND created_at > NOW() - INTERVAL '10 minutes';

    RETURN jsonb_build_object(
        'tier', v_tier,
        'daily_limit', v_daily_limit,
        'used_today', v_used_today,
        'reserved', v_reserved,
        'available', v_daily_limit - v_used_today - v_reserved,
        'reset_at', DATE_TRUNC('day', NOW() + INTERVAL '1 day')
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- 오래된 감사 로그 정리 함수 (90일 이전)
-- ============================================

CREATE OR REPLACE FUNCTION cleanup_old_audit_logs()
RETURNS INTEGER AS $$
DECLARE
    v_count INTEGER;
BEGIN
    DELETE FROM audit_logs
    WHERE created_at < NOW() - INTERVAL '90 days';

    GET DIAGNOSTICS v_count = ROW_COUNT;
    RETURN v_count;
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- 30일 초과 삭제 데이터 영구 삭제 함수
-- ============================================

CREATE OR REPLACE FUNCTION permanently_delete_expired_data()
RETURNS JSONB AS $$
DECLARE
    v_profiles INTEGER;
    v_landing_pages INTEGER;
    v_qa_sessions INTEGER;
BEGIN
    -- 30일 초과 삭제된 qa_sessions 먼저 삭제 (FK 때문에)
    DELETE FROM qa_sessions
    WHERE deleted_at IS NOT NULL
      AND deleted_at < NOW() - INTERVAL '30 days';
    GET DIAGNOSTICS v_qa_sessions = ROW_COUNT;

    -- 30일 초과 삭제된 landing_pages 삭제
    DELETE FROM landing_pages
    WHERE deleted_at IS NOT NULL
      AND deleted_at < NOW() - INTERVAL '30 days';
    GET DIAGNOSTICS v_landing_pages = ROW_COUNT;

    -- 30일 초과 삭제된 profiles 삭제 (auth.users도 함께 삭제됨 - CASCADE)
    DELETE FROM profiles
    WHERE deleted_at IS NOT NULL
      AND deleted_at < NOW() - INTERVAL '30 days';
    GET DIAGNOSTICS v_profiles = ROW_COUNT;

    RETURN jsonb_build_object(
        'profiles_deleted', v_profiles,
        'landing_pages_deleted', v_landing_pages,
        'qa_sessions_deleted', v_qa_sessions
    );
END;
$$ LANGUAGE plpgsql;
```

---

## 3. TypeScript 타입 정의

```typescript
// src/types/database.ts

export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[];

export interface Database {
  public: {
    Tables: {
      profiles: {
        Row: {
          id: string;
          email: string;
          full_name: string;
          tier: 'FREE' | 'PRO' | 'ENTERPRISE';
          is_approved: boolean;
          agree_marketing: boolean;
          deleted_at: string | null;
          created_at: string;
          updated_at: string;
        };
        Insert: {
          id: string;
          email: string;
          full_name: string;
          tier?: 'FREE' | 'PRO' | 'ENTERPRISE';
          is_approved?: boolean;
          agree_marketing?: boolean;
          deleted_at?: string | null;
          created_at?: string;
          updated_at?: string;
        };
        Update: {
          id?: string;
          email?: string;
          full_name?: string;
          tier?: 'FREE' | 'PRO' | 'ENTERPRISE';
          is_approved?: boolean;
          agree_marketing?: boolean;
          deleted_at?: string | null;
          updated_at?: string;
        };
      };
      landing_pages: {
        Row: {
          id: string;
          user_id: string;
          qa_session_id: string | null;
          title: string;
          content: Json;
          status: 'draft' | 'published' | 'archived';
          slug: string | null;
          published_url: string | null;
          deleted_at: string | null;
          created_at: string;
          updated_at: string;
        };
        Insert: {
          id?: string;
          user_id: string;
          qa_session_id?: string | null;
          title: string;
          content?: Json;
          status?: 'draft' | 'published' | 'archived';
          slug?: string | null;
          published_url?: string | null;
          deleted_at?: string | null;
          created_at?: string;
          updated_at?: string;
        };
        Update: {
          user_id?: string;
          qa_session_id?: string | null;
          title?: string;
          content?: Json;
          status?: 'draft' | 'published' | 'archived';
          slug?: string | null;
          published_url?: string | null;
          deleted_at?: string | null;
          updated_at?: string;
        };
      };
      qa_sessions: {
        Row: {
          id: string;
          user_id: string;
          landing_page_id: string | null;
          answers: Json;
          current_step: number;
          status: 'in_progress' | 'completed' | 'abandoned';
          deleted_at: string | null;
          created_at: string;
          updated_at: string;
        };
        Insert: {
          id?: string;
          user_id: string;
          landing_page_id?: string | null;
          answers?: Json;
          current_step?: number;
          status?: 'in_progress' | 'completed' | 'abandoned';
          deleted_at?: string | null;
          created_at?: string;
          updated_at?: string;
        };
        Update: {
          user_id?: string;
          landing_page_id?: string | null;
          answers?: Json;
          current_step?: number;
          status?: 'in_progress' | 'completed' | 'abandoned';
          deleted_at?: string | null;
          updated_at?: string;
        };
      };
      token_usage: {
        Row: {
          id: string;
          user_id: string;
          tokens_used: number;
          action: 'generate' | 'regenerate' | 'edit';
          metadata: Json;
          created_at: string;
        };
        Insert: {
          id?: string;
          user_id: string;
          tokens_used: number;
          action: 'generate' | 'regenerate' | 'edit';
          metadata?: Json;
          created_at?: string;
        };
        Update: never; // 수정 불가
      };
      token_reservations: {
        Row: {
          id: string;
          user_id: string;
          estimated_tokens: number;
          actual_tokens: number | null;
          status: 'reserved' | 'confirmed' | 'cancelled' | 'expired';
          created_at: string;
          confirmed_at: string | null;
        };
        Insert: {
          id?: string;
          user_id: string;
          estimated_tokens: number;
          actual_tokens?: number | null;
          status?: 'reserved' | 'confirmed' | 'cancelled' | 'expired';
          created_at?: string;
          confirmed_at?: string | null;
        };
        Update: {
          actual_tokens?: number | null;
          status?: 'reserved' | 'confirmed' | 'cancelled' | 'expired';
          confirmed_at?: string | null;
        };
      };
      refresh_tokens: {
        Row: {
          id: string;
          user_id: string;
          token_hash: string;
          revoked: boolean;
          revoked_at: string | null;
          expires_at: string;
          created_at: string;
        };
        Insert: {
          id?: string;
          user_id: string;
          token_hash: string;
          revoked?: boolean;
          revoked_at?: string | null;
          expires_at: string;
          created_at?: string;
        };
        Update: {
          revoked?: boolean;
          revoked_at?: string | null;
        };
      };
      audit_logs: {
        Row: {
          id: string;
          user_id: string | null;
          action: string;
          details: Json;
          ip_address: string | null;
          user_agent: string | null;
          created_at: string;
        };
        Insert: {
          id?: string;
          user_id?: string | null;
          action: string;
          details?: Json;
          ip_address?: string | null;
          user_agent?: string | null;
          created_at?: string;
        };
        Update: never; // 수정 불가
      };
      user_sessions: {
        Row: {
          id: string;
          user_id: string;
          ip_address: string | null;
          user_agent: string | null;
          invalidated_at: string | null;
          created_at: string;
        };
        Insert: {
          id?: string;
          user_id: string;
          ip_address?: string | null;
          user_agent?: string | null;
          invalidated_at?: string | null;
          created_at?: string;
        };
        Update: {
          invalidated_at?: string | null;
        };
      };
      rate_limits: {
        Row: {
          id: string;
          identifier: string;
          endpoint: string;
          request_count: number;
          window_start: string;
          created_at: string;
        };
        Insert: {
          id?: string;
          identifier: string;
          endpoint: string;
          request_count?: number;
          window_start?: string;
          created_at?: string;
        };
        Update: {
          request_count?: number;
        };
      };
    };
    Functions: {
      check_rate_limit: {
        Args: {
          p_identifier: string;
          p_endpoint: string;
          p_limit: number;
          p_window_seconds: number;
        };
        Returns: Json;
      };
      check_and_reserve_tokens: {
        Args: {
          p_user_id: string;
          p_estimated_tokens: number;
        };
        Returns: Json;
      };
      confirm_token_usage: {
        Args: {
          p_reservation_id: string;
          p_actual_tokens: number;
        };
        Returns: Json;
      };
      cancel_token_reservation: {
        Args: {
          p_reservation_id: string;
        };
        Returns: Json;
      };
      get_user_token_usage: {
        Args: {
          p_user_id: string;
        };
        Returns: Json;
      };
    };
  };
}
```

---

## 4. 마이그레이션 실행

### 4.1 Supabase CLI 사용

```bash
# 1. Supabase 로컬 시작
npx supabase start

# 2. 마이그레이션 적용
npx supabase db push

# 3. 마이그레이션 상태 확인
npx supabase db status

# 4. 타입 생성
npx supabase gen types typescript --local > src/types/database.ts
```

### 4.2 롤백 스크립트

```sql
-- rollback.sql
-- 모든 v2 변경 사항 롤백

BEGIN;

-- 1. 신규 테이블 삭제
DROP TABLE IF EXISTS token_reservations;
DROP TABLE IF EXISTS refresh_tokens;
DROP TABLE IF EXISTS audit_logs;
DROP TABLE IF EXISTS user_sessions;
DROP TABLE IF EXISTS rate_limits;

-- 2. deleted_at 컬럼 삭제
ALTER TABLE profiles DROP COLUMN IF EXISTS deleted_at;
ALTER TABLE landing_pages DROP COLUMN IF EXISTS deleted_at;
ALTER TABLE qa_sessions DROP COLUMN IF EXISTS deleted_at;

-- 3. 트리거 삭제
DROP TRIGGER IF EXISTS on_approval_change ON profiles;
DROP FUNCTION IF EXISTS invalidate_user_sessions();

-- 4. 함수 삭제
DROP FUNCTION IF EXISTS check_and_reserve_tokens(UUID, INTEGER);
DROP FUNCTION IF EXISTS confirm_token_usage(UUID, INTEGER);
DROP FUNCTION IF EXISTS cancel_token_reservation(UUID);
DROP FUNCTION IF EXISTS check_rate_limit(TEXT, TEXT, INTEGER, INTEGER);
DROP FUNCTION IF EXISTS get_user_token_usage(UUID);
DROP FUNCTION IF EXISTS cleanup_expired_reservations();
DROP FUNCTION IF EXISTS cleanup_old_rate_limits();
DROP FUNCTION IF EXISTS cleanup_old_audit_logs();
DROP FUNCTION IF EXISTS permanently_delete_expired_data();

COMMIT;
```

---

## 5. 구현 체크리스트

### 5.1 마이그레이션 파일

- [ ] 001_initial_schema.sql
- [ ] 002_soft_delete.sql
- [ ] 003_refresh_tokens.sql
- [ ] 004_audit_logs.sql
- [ ] 005_rate_limits.sql
- [ ] 006_token_reservations.sql
- [ ] 007_functions_triggers.sql

### 5.2 RLS 정책

- [ ] profiles (deleted_at 조건)
- [ ] landing_pages (deleted_at + 복구용 정책)
- [ ] qa_sessions (deleted_at 조건)
- [ ] token_reservations
- [ ] refresh_tokens (서버 전용)
- [ ] audit_logs (사용자 + 관리자)
- [ ] user_sessions
- [ ] rate_limits (서버 전용)

### 5.3 함수

- [ ] check_rate_limit
- [ ] check_and_reserve_tokens (Advisory Lock)
- [ ] confirm_token_usage
- [ ] cancel_token_reservation
- [ ] get_user_token_usage
- [ ] invalidate_user_sessions (트리거)

### 5.4 정리 작업 (pg_cron)

- [ ] cleanup_expired_reservations (매 분)
- [ ] cleanup_old_rate_limits (매 시간)
- [ ] cleanup_old_audit_logs (매일)
- [ ] permanently_delete_expired_data (매일)

---

**이전 문서**: [01_인증_시스템.md](./01_인증_시스템.md)
**다음 문서**: [03_API_엔드포인트.md](./03_API_엔드포인트.md)
