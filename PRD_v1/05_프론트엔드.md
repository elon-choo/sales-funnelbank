# 마그네틱 세일즈 웹앱 - 프론트엔드 PRD

## 문서 정보
| 항목 | 내용 |
|------|------|
| 문서명 | 프론트엔드 PRD |
| 버전 | 1.0 |
| 작성일 | 2025-01-15 |
| 기반 문서 | 기획_v2/02_UX_플로우_v2.md, 기획_v2/03_기능_정의_v2.md |

---

## 1. 개요

### 1.1 목적
Next.js 15 App Router 기반의 마그네틱 세일즈 웹앱 프론트엔드를 구현한다.

### 1.2 핵심 요구사항
- **반응형 디자인** (Mobile-First)
- **인증 상태 관리** (Zustand + HttpOnly Cookie)
- **SSE 스트리밍** 기반 AI 생성 진행률 표시
- **WCAG 2.1 AA** 접근성 준수
- **에러 메시지 일반화** (보안 강화)

### 1.3 브레이크포인트
| 디바이스 | 너비 | 레이아웃 |
|----------|------|----------|
| Mobile | < 640px | 1 컬럼 |
| Tablet | 640px - 1024px | 2 컬럼 |
| Desktop | > 1024px | 3 컬럼 |

---

## 2. 기술 스택

```yaml
Framework: Next.js 15 (App Router)
Language: TypeScript 5.x
Styling: Tailwind CSS 3.4+
UI Components: shadcn/ui
State Management: Zustand
Form Validation: react-hook-form + zod
HTTP Client: 내장 fetch (with interceptors)
Icons: lucide-react
Animation: framer-motion
```

---

## 3. 상세 구현

### 3.1 프로젝트 구조

```
src/
├── app/                          # Next.js App Router
│   ├── (auth)/                   # 인증 관련 페이지 그룹
│   │   ├── login/
│   │   │   └── page.tsx
│   │   ├── signup/
│   │   │   └── page.tsx
│   │   ├── forgot-password/
│   │   │   └── page.tsx
│   │   └── pending-approval/
│   │       └── page.tsx
│   ├── (dashboard)/              # 대시보드 페이지 그룹
│   │   ├── layout.tsx
│   │   ├── page.tsx              # 메인 대시보드
│   │   ├── qa/                   # Q&A 세션
│   │   │   ├── page.tsx          # 세션 목록
│   │   │   ├── new/
│   │   │   │   └── page.tsx      # 새 세션 시작
│   │   │   └── [sessionId]/
│   │   │       └── page.tsx      # 질문 답변
│   │   ├── landing-pages/        # 랜딩페이지 관리
│   │   │   ├── page.tsx          # LP 목록
│   │   │   ├── [pageId]/
│   │   │   │   ├── page.tsx      # LP 상세
│   │   │   │   ├── edit/
│   │   │   │   │   └── page.tsx  # LP 편집
│   │   │   │   └── preview/
│   │   │   │       └── page.tsx  # LP 미리보기
│   │   │   └── generate/
│   │   │       └── page.tsx      # AI 생성 화면
│   │   ├── settings/
│   │   │   └── page.tsx          # 설정
│   │   └── trash/
│   │       └── page.tsx          # 휴지통 (Soft Delete)
│   ├── (public)/                 # 공개 페이지
│   │   ├── p/                    # 배포된 LP
│   │   │   └── [...slug]/
│   │   │       └── page.tsx
│   │   └── page.tsx              # 랜딩페이지
│   ├── api/                      # API Routes
│   │   └── ...
│   ├── layout.tsx                # 루트 레이아웃
│   ├── loading.tsx               # 글로벌 로딩
│   ├── error.tsx                 # 글로벌 에러
│   └── not-found.tsx             # 404 페이지
├── components/
│   ├── ui/                       # shadcn/ui 컴포넌트
│   ├── auth/                     # 인증 관련 컴포넌트
│   ├── dashboard/                # 대시보드 컴포넌트
│   ├── qa/                       # Q&A 컴포넌트
│   ├── landing-page/             # LP 관련 컴포넌트
│   └── common/                   # 공통 컴포넌트
├── hooks/                        # 커스텀 훅
├── lib/                          # 유틸리티
├── stores/                       # Zustand 스토어
├── types/                        # TypeScript 타입
└── styles/                       # 글로벌 스타일
```

---

### 3.2 인증 스토어

**파일**: `src/stores/auth-store.ts`

```typescript
// src/stores/auth-store.ts
import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';

/**
 * 사용자 정보 타입
 */
interface User {
  id: string;
  email: string;
  name: string;
  tier: 'FREE' | 'PRO' | 'ENTERPRISE';
  isApproved: boolean;
  createdAt: string;
}

/**
 * 토큰 사용량 타입
 */
interface TokenUsage {
  tier: string;
  dailyLimit: number;
  usedToday: number;
  available: number;
  percentage: number;
}

/**
 * 인증 스토어 상태 타입
 */
interface AuthState {
  // 상태
  user: User | null;
  accessToken: string | null;
  tokenUsage: TokenUsage | null;
  isLoading: boolean;
  isInitialized: boolean;

  // 액션
  setUser: (user: User | null) => void;
  setAccessToken: (token: string | null) => void;
  setTokenUsage: (usage: TokenUsage | null) => void;
  setLoading: (loading: boolean) => void;
  setInitialized: (initialized: boolean) => void;
  logout: () => void;
  reset: () => void;
}

/**
 * 초기 상태
 */
const initialState = {
  user: null,
  accessToken: null,
  tokenUsage: null,
  isLoading: false,
  isInitialized: false,
};

/**
 * 인증 스토어
 * - Access Token은 메모리에만 저장 (persist 제외)
 * - Refresh Token은 HttpOnly Cookie로 서버에서 관리
 */
export const useAuthStore = create<AuthState>()(
  persist(
    (set) => ({
      ...initialState,

      setUser: (user) => set({ user }),

      setAccessToken: (accessToken) => set({ accessToken }),

      setTokenUsage: (tokenUsage) => set({ tokenUsage }),

      setLoading: (isLoading) => set({ isLoading }),

      setInitialized: (isInitialized) => set({ isInitialized }),

      logout: () => {
        set(initialState);
        // HttpOnly Cookie는 서버에서 제거됨
      },

      reset: () => set(initialState),
    }),
    {
      name: 'auth-storage',
      storage: createJSONStorage(() => sessionStorage),
      // Access Token은 persist하지 않음 (메모리만)
      partialize: (state) => ({
        user: state.user,
        tokenUsage: state.tokenUsage,
      }),
    }
  )
);

/**
 * Access Token 선택자 (비persist)
 */
export const selectAccessToken = (state: AuthState) => state.accessToken;

/**
 * 인증 여부 선택자
 */
export const selectIsAuthenticated = (state: AuthState) =>
  !!state.accessToken && !!state.user?.isApproved;

/**
 * 로딩 선택자
 */
export const selectIsLoading = (state: AuthState) => state.isLoading;
```

---

### 3.3 인증 Provider

**파일**: `src/components/providers/auth-provider.tsx`

```typescript
// src/components/providers/auth-provider.tsx
'use client';

import { useEffect, useCallback, useRef } from 'react';
import { useRouter, usePathname } from 'next/navigation';
import { useAuthStore } from '@/stores/auth-store';

/**
 * 공개 경로 목록
 */
const PUBLIC_PATHS = [
  '/',
  '/login',
  '/signup',
  '/forgot-password',
  '/pending-approval',
];

/**
 * 경로가 공개 경로인지 확인
 */
function isPublicPath(pathname: string): boolean {
  // 배포된 LP 페이지는 공개
  if (pathname.startsWith('/p/')) {
    return true;
  }
  return PUBLIC_PATHS.includes(pathname);
}

/**
 * 토큰 갱신 간격 (분)
 */
const TOKEN_REFRESH_INTERVAL = 14; // Access Token 만료 1분 전

interface AuthProviderProps {
  children: React.ReactNode;
}

/**
 * 인증 Provider
 * - 앱 초기화 시 토큰 검증
 * - 자동 토큰 갱신
 * - 인증 상태 변경 감지
 */
export function AuthProvider({ children }: AuthProviderProps) {
  const router = useRouter();
  const pathname = usePathname();
  const refreshTimerRef = useRef<NodeJS.Timeout | null>(null);

  const {
    accessToken,
    isInitialized,
    setUser,
    setAccessToken,
    setTokenUsage,
    setLoading,
    setInitialized,
    logout,
  } = useAuthStore();

  /**
   * 토큰 갱신
   */
  const refreshToken = useCallback(async (): Promise<boolean> => {
    try {
      const response = await fetch('/api/auth/refresh', {
        method: 'POST',
        credentials: 'include', // HttpOnly Cookie 포함
      });

      if (!response.ok) {
        return false;
      }

      const data = await response.json();

      if (data.accessToken) {
        setAccessToken(data.accessToken);
        return true;
      }

      return false;
    } catch (error) {
      console.error('[AuthProvider] Refresh failed:', error);
      return false;
    }
  }, [setAccessToken]);

  /**
   * 사용자 정보 조회
   */
  const fetchUser = useCallback(async () => {
    try {
      const response = await fetch('/api/auth/me', {
        headers: {
          Authorization: `Bearer ${useAuthStore.getState().accessToken}`,
        },
      });

      if (!response.ok) {
        throw new Error('Failed to fetch user');
      }

      const data = await response.json();
      setUser(data.user);

      // 승인되지 않은 사용자 처리
      if (!data.user.isApproved) {
        router.replace('/pending-approval');
        return false;
      }

      return true;
    } catch (error) {
      console.error('[AuthProvider] Fetch user failed:', error);
      return false;
    }
  }, [setUser, router]);

  /**
   * 토큰 사용량 조회
   */
  const fetchTokenUsage = useCallback(async () => {
    try {
      const response = await fetch('/api/user/tokens', {
        headers: {
          Authorization: `Bearer ${useAuthStore.getState().accessToken}`,
        },
      });

      if (response.ok) {
        const data = await response.json();
        setTokenUsage(data.data);
      }
    } catch (error) {
      console.error('[AuthProvider] Fetch token usage failed:', error);
    }
  }, [setTokenUsage]);

  /**
   * 자동 갱신 타이머 설정
   */
  const setupRefreshTimer = useCallback(() => {
    // 기존 타이머 제거
    if (refreshTimerRef.current) {
      clearInterval(refreshTimerRef.current);
    }

    // 새 타이머 설정
    refreshTimerRef.current = setInterval(
      async () => {
        const success = await refreshToken();
        if (!success) {
          logout();
          router.replace('/login?error=session_expired');
        }
      },
      TOKEN_REFRESH_INTERVAL * 60 * 1000
    );
  }, [refreshToken, logout, router]);

  /**
   * 초기화
   */
  useEffect(() => {
    const initialize = async () => {
      setLoading(true);

      try {
        // 토큰 갱신 시도
        const refreshed = await refreshToken();

        if (refreshed) {
          // 사용자 정보 조회
          const userFetched = await fetchUser();

          if (userFetched) {
            // 토큰 사용량 조회
            await fetchTokenUsage();

            // 자동 갱신 타이머 설정
            setupRefreshTimer();
          }
        } else if (!isPublicPath(pathname)) {
          // 비공개 페이지에서 토큰 없으면 로그인으로
          router.replace('/login');
        }
      } catch (error) {
        console.error('[AuthProvider] Initialize failed:', error);
      } finally {
        setLoading(false);
        setInitialized(true);
      }
    };

    if (!isInitialized) {
      initialize();
    }

    // 클린업
    return () => {
      if (refreshTimerRef.current) {
        clearInterval(refreshTimerRef.current);
      }
    };
  }, [
    isInitialized,
    pathname,
    refreshToken,
    fetchUser,
    fetchTokenUsage,
    setupRefreshTimer,
    setLoading,
    setInitialized,
    router,
  ]);

  /**
   * 인증 상태 변경 감지
   */
  useEffect(() => {
    if (!isInitialized) return;

    const isAuth = !!accessToken;
    const isPublic = isPublicPath(pathname);

    if (!isAuth && !isPublic) {
      router.replace('/login');
    }
  }, [accessToken, pathname, isInitialized, router]);

  return <>{children}</>;
}
```

---

### 3.4 로그인 페이지

**파일**: `src/app/(auth)/login/page.tsx`

```typescript
// src/app/(auth)/login/page.tsx
'use client';

import { useState } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import Link from 'next/link';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { Eye, EyeOff, Loader2, AlertCircle } from 'lucide-react';

import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Checkbox } from '@/components/ui/checkbox';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { useAuthStore } from '@/stores/auth-store';

/**
 * 로그인 폼 스키마
 */
const loginSchema = z.object({
  email: z.string().email('올바른 이메일 형식을 입력해주세요'),
  password: z.string().min(1, '비밀번호를 입력해주세요'),
  rememberMe: z.boolean().default(false),
});

type LoginFormData = z.infer<typeof loginSchema>;

/**
 * 에러 코드별 메시지 (일반화)
 */
const ERROR_MESSAGES: Record<string, string> = {
  ERR_AUTH_1001: '이메일 또는 비밀번호가 올바르지 않습니다',
  ERR_AUTH_1002: '관리자 승인 대기 중입니다',
  ERR_AUTH_1003: '계정이 일시적으로 잠겼습니다. 잠시 후 다시 시도해주세요',
  ERR_AUTH_1004: '요청이 너무 많습니다. 잠시 후 다시 시도해주세요',
  session_expired: '세션이 만료되었습니다. 다시 로그인해주세요',
  default: '로그인에 실패했습니다. 잠시 후 다시 시도해주세요',
};

export default function LoginPage() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [showPassword, setShowPassword] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const { setUser, setAccessToken, setTokenUsage } = useAuthStore();

  // URL 파라미터에서 에러 확인
  const urlError = searchParams.get('error');

  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<LoginFormData>({
    resolver: zodResolver(loginSchema),
    defaultValues: {
      email: '',
      password: '',
      rememberMe: false,
    },
  });

  /**
   * 로그인 제출
   */
  const onSubmit = async (data: LoginFormData) => {
    setIsSubmitting(true);
    setError(null);

    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
        credentials: 'include', // HttpOnly Cookie 수신
      });

      const result = await response.json();

      if (!response.ok) {
        const errorCode = result.error?.code || 'default';
        setError(ERROR_MESSAGES[errorCode] || ERROR_MESSAGES.default);
        return;
      }

      // Access Token 저장 (메모리)
      setAccessToken(result.accessToken);
      setUser(result.user);

      // 토큰 사용량 조회
      const tokenResponse = await fetch('/api/user/tokens', {
        headers: { Authorization: `Bearer ${result.accessToken}` },
      });
      if (tokenResponse.ok) {
        const tokenData = await tokenResponse.json();
        setTokenUsage(tokenData.data);
      }

      // 대시보드로 이동
      router.push('/');
    } catch (err) {
      console.error('[Login] Error:', err);
      setError(ERROR_MESSAGES.default);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 px-4">
      <div className="w-full max-w-md">
        {/* 로고/타이틀 */}
        <div className="text-center mb-8">
          <h1 className="text-2xl font-bold text-gray-900">
            마그네틱 세일즈 웹앱
          </h1>
          <p className="mt-2 text-gray-600">
            AI로 전환율 높은 랜딩페이지를 만드세요
          </p>
        </div>

        {/* 카드 */}
        <div className="bg-white rounded-lg shadow-md p-6">
          <h2 className="text-xl font-semibold mb-6">로그인</h2>

          {/* URL 에러 알림 */}
          {urlError && (
            <Alert variant="destructive" className="mb-4">
              <AlertCircle className="h-4 w-4" />
              <AlertDescription>
                {ERROR_MESSAGES[urlError] || ERROR_MESSAGES.default}
              </AlertDescription>
            </Alert>
          )}

          {/* 폼 에러 알림 */}
          {error && (
            <Alert variant="destructive" className="mb-4">
              <AlertCircle className="h-4 w-4" />
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}

          <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
            {/* 이메일 */}
            <div className="space-y-2">
              <Label htmlFor="email">이메일</Label>
              <Input
                id="email"
                type="email"
                placeholder="example@email.com"
                autoComplete="email"
                disabled={isSubmitting}
                aria-invalid={!!errors.email}
                aria-describedby={errors.email ? 'email-error' : undefined}
                {...register('email')}
              />
              {errors.email && (
                <p id="email-error" className="text-sm text-red-500">
                  {errors.email.message}
                </p>
              )}
            </div>

            {/* 비밀번호 */}
            <div className="space-y-2">
              <Label htmlFor="password">비밀번호</Label>
              <div className="relative">
                <Input
                  id="password"
                  type={showPassword ? 'text' : 'password'}
                  placeholder="비밀번호를 입력하세요"
                  autoComplete="current-password"
                  disabled={isSubmitting}
                  aria-invalid={!!errors.password}
                  aria-describedby={
                    errors.password ? 'password-error' : undefined
                  }
                  {...register('password')}
                />
                <button
                  type="button"
                  className="absolute right-3 top-1/2 -translate-y-1/2 text-gray-500 hover:text-gray-700"
                  onClick={() => setShowPassword(!showPassword)}
                  aria-label={showPassword ? '비밀번호 숨기기' : '비밀번호 보기'}
                >
                  {showPassword ? (
                    <EyeOff className="h-4 w-4" />
                  ) : (
                    <Eye className="h-4 w-4" />
                  )}
                </button>
              </div>
              {errors.password && (
                <p id="password-error" className="text-sm text-red-500">
                  {errors.password.message}
                </p>
              )}
            </div>

            {/* 로그인 유지 & 비밀번호 찾기 */}
            <div className="flex items-center justify-between">
              <div className="flex items-center space-x-2">
                <Checkbox id="rememberMe" {...register('rememberMe')} />
                <Label htmlFor="rememberMe" className="text-sm cursor-pointer">
                  로그인 유지
                </Label>
              </div>
              <Link
                href="/forgot-password"
                className="text-sm text-blue-600 hover:underline"
              >
                비밀번호를 잊으셨나요?
              </Link>
            </div>

            {/* 제출 버튼 */}
            <Button
              type="submit"
              className="w-full"
              disabled={isSubmitting}
            >
              {isSubmitting ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  로그인 중...
                </>
              ) : (
                '로그인'
              )}
            </Button>
          </form>

          {/* 회원가입 링크 */}
          <p className="mt-6 text-center text-sm text-gray-600">
            아직 계정이 없으신가요?{' '}
            <Link href="/signup" className="text-blue-600 hover:underline">
              회원가입
            </Link>
          </p>
        </div>
      </div>
    </div>
  );
}
```

---

### 3.5 대시보드 레이아웃

**파일**: `src/app/(dashboard)/layout.tsx`

```typescript
// src/app/(dashboard)/layout.tsx
'use client';

import { ReactNode } from 'react';
import Link from 'next/link';
import { usePathname } from 'next/navigation';
import {
  Home,
  FileText,
  MessageSquare,
  Settings,
  Trash2,
  LogOut,
  Menu,
  X,
  Zap,
} from 'lucide-react';
import { useState } from 'react';

import { Button } from '@/components/ui/button';
import { Progress } from '@/components/ui/progress';
import { useAuthStore } from '@/stores/auth-store';

/**
 * 네비게이션 항목
 */
const NAV_ITEMS = [
  { href: '/', label: '대시보드', icon: Home },
  { href: '/qa', label: 'Q&A 세션', icon: MessageSquare },
  { href: '/landing-pages', label: '랜딩페이지', icon: FileText },
  { href: '/trash', label: '휴지통', icon: Trash2 },
  { href: '/settings', label: '설정', icon: Settings },
];

interface DashboardLayoutProps {
  children: ReactNode;
}

export default function DashboardLayout({ children }: DashboardLayoutProps) {
  const pathname = usePathname();
  const [isSidebarOpen, setIsSidebarOpen] = useState(false);

  const { user, tokenUsage, logout } = useAuthStore();

  /**
   * 로그아웃 처리
   */
  const handleLogout = async () => {
    try {
      await fetch('/api/auth/logout', {
        method: 'POST',
        credentials: 'include',
      });
    } catch (error) {
      console.error('[Layout] Logout error:', error);
    } finally {
      logout();
      window.location.href = '/login';
    }
  };

  return (
    <div className="min-h-screen bg-gray-50">
      {/* 모바일 헤더 */}
      <header className="lg:hidden bg-white border-b px-4 py-3 flex items-center justify-between">
        <h1 className="font-semibold text-lg">마그네틱 세일즈</h1>
        <button
          onClick={() => setIsSidebarOpen(!isSidebarOpen)}
          className="p-2 hover:bg-gray-100 rounded-md"
          aria-label={isSidebarOpen ? '메뉴 닫기' : '메뉴 열기'}
        >
          {isSidebarOpen ? (
            <X className="h-6 w-6" />
          ) : (
            <Menu className="h-6 w-6" />
          )}
        </button>
      </header>

      <div className="flex">
        {/* 사이드바 */}
        <aside
          className={`
            fixed inset-y-0 left-0 z-50 w-64 bg-white border-r transform transition-transform duration-200 ease-in-out
            lg:translate-x-0 lg:static lg:inset-auto
            ${isSidebarOpen ? 'translate-x-0' : '-translate-x-full'}
          `}
        >
          {/* 로고 */}
          <div className="hidden lg:flex h-16 items-center px-6 border-b">
            <h1 className="font-bold text-xl">마그네틱 세일즈</h1>
          </div>

          {/* 사용자 정보 */}
          <div className="p-4 border-b">
            <div className="flex items-center space-x-3">
              <div className="w-10 h-10 rounded-full bg-blue-100 flex items-center justify-center">
                <span className="text-blue-600 font-medium">
                  {user?.name?.[0] || 'U'}
                </span>
              </div>
              <div className="flex-1 min-w-0">
                <p className="font-medium truncate">{user?.name || '사용자'}</p>
                <p className="text-sm text-gray-500 truncate">{user?.email}</p>
              </div>
            </div>
          </div>

          {/* 토큰 사용량 */}
          {tokenUsage && (
            <div className="p-4 border-b">
              <div className="flex items-center justify-between text-sm mb-2">
                <span className="flex items-center text-gray-600">
                  <Zap className="h-4 w-4 mr-1" />
                  토큰 사용량
                </span>
                <span className="font-medium">
                  {tokenUsage.percentage}%
                </span>
              </div>
              <Progress value={tokenUsage.percentage} className="h-2" />
              <p className="text-xs text-gray-500 mt-1">
                {tokenUsage.usedToday.toLocaleString()} /{' '}
                {tokenUsage.dailyLimit.toLocaleString()}
              </p>
            </div>
          )}

          {/* 네비게이션 */}
          <nav className="p-4 space-y-1">
            {NAV_ITEMS.map((item) => {
              const Icon = item.icon;
              const isActive = pathname === item.href;

              return (
                <Link
                  key={item.href}
                  href={item.href}
                  className={`
                    flex items-center space-x-3 px-3 py-2 rounded-md transition-colors
                    ${
                      isActive
                        ? 'bg-blue-50 text-blue-700'
                        : 'text-gray-700 hover:bg-gray-100'
                    }
                  `}
                  onClick={() => setIsSidebarOpen(false)}
                >
                  <Icon className="h-5 w-5" />
                  <span>{item.label}</span>
                </Link>
              );
            })}
          </nav>

          {/* 로그아웃 */}
          <div className="absolute bottom-0 left-0 right-0 p-4 border-t bg-white">
            <Button
              variant="ghost"
              className="w-full justify-start text-gray-700"
              onClick={handleLogout}
            >
              <LogOut className="h-5 w-5 mr-3" />
              로그아웃
            </Button>
          </div>
        </aside>

        {/* 오버레이 (모바일) */}
        {isSidebarOpen && (
          <div
            className="fixed inset-0 bg-black/50 z-40 lg:hidden"
            onClick={() => setIsSidebarOpen(false)}
          />
        )}

        {/* 메인 콘텐츠 */}
        <main className="flex-1 min-h-screen lg:ml-0">
          <div className="p-4 lg:p-8">{children}</div>
        </main>
      </div>
    </div>
  );
}
```

---

### 3.6 Q&A 질문 답변 페이지

**파일**: `src/app/(dashboard)/qa/[sessionId]/page.tsx`

```typescript
// src/app/(dashboard)/qa/[sessionId]/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import { useParams, useRouter } from 'next/navigation';
import {
  ChevronLeft,
  ChevronRight,
  Save,
  Loader2,
  HelpCircle,
  CheckCircle,
} from 'lucide-react';

import { Button } from '@/components/ui/button';
import { Textarea } from '@/components/ui/textarea';
import { Progress } from '@/components/ui/progress';
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from '@/components/ui/tooltip';
import { useAuthStore } from '@/stores/auth-store';
import { QUESTION_CATEGORIES, Question } from '@/lib/ai/questions';

/**
 * 모든 질문 플랫 배열
 */
const ALL_QUESTIONS = QUESTION_CATEGORIES.flatMap((c) => c.questions);

/**
 * 현재 질문의 카테고리 찾기
 */
function findCategory(questionId: number) {
  return QUESTION_CATEGORIES.find((c) =>
    c.questions.some((q) => q.id === questionId)
  );
}

export default function QASessionPage() {
  const params = useParams();
  const router = useRouter();
  const sessionId = params.sessionId as string;

  const { accessToken } = useAuthStore();

  // 상태
  const [isLoading, setIsLoading] = useState(true);
  const [isSaving, setIsSaving] = useState(false);
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
  const [answers, setAnswers] = useState<Record<string, string>>({});
  const [lastSaved, setLastSaved] = useState<Date | null>(null);

  const currentQuestion = ALL_QUESTIONS[currentQuestionIndex];
  const currentCategory = findCategory(currentQuestion?.id);
  const answerKey = `q${currentQuestion?.id}`;
  const currentAnswer = answers[answerKey] || '';

  // 진행률 계산
  const answeredCount = Object.values(answers).filter(
    (a) => a.trim().length > 0
  ).length;
  const progressPercent = Math.round(
    (answeredCount / ALL_QUESTIONS.length) * 100
  );

  /**
   * 세션 데이터 로드
   */
  useEffect(() => {
    const loadSession = async () => {
      try {
        const response = await fetch(`/api/qa-sessions/${sessionId}`, {
          headers: { Authorization: `Bearer ${accessToken}` },
        });

        if (!response.ok) {
          throw new Error('Session not found');
        }

        const data = await response.json();
        setAnswers(data.answers || {});

        // 마지막 답변한 질문으로 이동
        const lastAnsweredIndex = ALL_QUESTIONS.findIndex(
          (q) => !data.answers?.[`q${q.id}`]?.trim()
        );
        if (lastAnsweredIndex > 0) {
          setCurrentQuestionIndex(lastAnsweredIndex);
        }
      } catch (error) {
        console.error('[QA] Load session error:', error);
        router.push('/qa');
      } finally {
        setIsLoading(false);
      }
    };

    loadSession();
  }, [sessionId, accessToken, router]);

  /**
   * 자동 저장 (debounced)
   */
  const saveAnswers = useCallback(
    async (newAnswers: Record<string, string>) => {
      setIsSaving(true);
      try {
        await fetch(`/api/qa-sessions/${sessionId}`, {
          method: 'PATCH',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${accessToken}`,
          },
          body: JSON.stringify({ answers: newAnswers }),
        });
        setLastSaved(new Date());
      } catch (error) {
        console.error('[QA] Save error:', error);
      } finally {
        setIsSaving(false);
      }
    },
    [sessionId, accessToken]
  );

  /**
   * 답변 변경 (3초 후 자동 저장)
   */
  const handleAnswerChange = (value: string) => {
    const newAnswers = { ...answers, [answerKey]: value };
    setAnswers(newAnswers);

    // sessionStorage 백업
    sessionStorage.setItem(`qa-backup-${sessionId}`, JSON.stringify(newAnswers));
  };

  /**
   * 답변 blur 시 저장
   */
  const handleAnswerBlur = () => {
    if (currentAnswer.trim()) {
      saveAnswers(answers);
    }
  };

  /**
   * 이전 질문
   */
  const goToPrevious = () => {
    if (currentQuestionIndex > 0) {
      setCurrentQuestionIndex(currentQuestionIndex - 1);
    }
  };

  /**
   * 다음 질문
   */
  const goToNext = () => {
    // 현재 답변 저장
    if (currentAnswer.trim()) {
      saveAnswers(answers);
    }

    if (currentQuestionIndex < ALL_QUESTIONS.length - 1) {
      setCurrentQuestionIndex(currentQuestionIndex + 1);
    }
  };

  /**
   * 생성 페이지로 이동
   */
  const goToGenerate = async () => {
    // 최종 저장
    await saveAnswers(answers);

    // 필수 질문 체크
    const requiredIds = ALL_QUESTIONS.filter((q) => q.required).map((q) => q.id);
    const missingRequired = requiredIds.filter(
      (id) => !answers[`q${id}`]?.trim()
    );

    if (missingRequired.length > 0) {
      alert(`필수 질문 ${missingRequired.length}개에 답변이 필요합니다.`);
      // 첫 번째 미답변 필수 질문으로 이동
      const firstMissingIndex = ALL_QUESTIONS.findIndex(
        (q) => q.id === missingRequired[0]
      );
      setCurrentQuestionIndex(firstMissingIndex);
      return;
    }

    router.push(`/landing-pages/generate?sessionId=${sessionId}`);
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <Loader2 className="h-8 w-8 animate-spin text-gray-400" />
      </div>
    );
  }

  return (
    <div className="max-w-3xl mx-auto">
      {/* 헤더 */}
      <div className="mb-6">
        <h1 className="text-2xl font-bold">Q&A 세션</h1>
        <p className="text-gray-600 mt-1">
          질문에 답변하면 AI가 맞춤형 랜딩페이지를 생성합니다
        </p>
      </div>

      {/* 진행률 */}
      <div className="mb-8">
        <div className="flex items-center justify-between text-sm mb-2">
          <span>
            진행률: {currentQuestionIndex + 1}/{ALL_QUESTIONS.length}
          </span>
          <span className="font-medium">{progressPercent}%</span>
        </div>
        <Progress value={progressPercent} className="h-2" />
      </div>

      {/* 카테고리 표시 */}
      {currentCategory && (
        <div className="mb-4">
          <span className="inline-flex items-center px-3 py-1 rounded-full text-sm bg-blue-100 text-blue-800">
            {currentCategory.name}
          </span>
        </div>
      )}

      {/* 질문 카드 */}
      <div className="bg-white rounded-lg shadow-md p-6 mb-6">
        <div className="flex items-start justify-between mb-4">
          <h2 className="text-lg font-medium">
            Q{currentQuestion.id}. {currentQuestion.text}
            {currentQuestion.required && (
              <span className="text-red-500 ml-1">*</span>
            )}
          </h2>
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <button className="text-gray-400 hover:text-gray-600">
                  <HelpCircle className="h-5 w-5" />
                </button>
              </TooltipTrigger>
              <TooltipContent>
                <p>{currentQuestion.hint}</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        </div>

        <Textarea
          value={currentAnswer}
          onChange={(e) => handleAnswerChange(e.target.value)}
          onBlur={handleAnswerBlur}
          placeholder="답변을 입력하세요..."
          className="min-h-[150px] resize-none"
          maxLength={500}
        />

        <div className="flex items-center justify-between mt-2 text-sm text-gray-500">
          <span>
            {currentAnswer.length}/500자
          </span>
          {lastSaved && (
            <span className="flex items-center">
              {isSaving ? (
                <>
                  <Loader2 className="h-3 w-3 animate-spin mr-1" />
                  저장 중...
                </>
              ) : (
                <>
                  <CheckCircle className="h-3 w-3 text-green-500 mr-1" />
                  저장됨
                </>
              )}
            </span>
          )}
        </div>
      </div>

      {/* 네비게이션 */}
      <div className="flex items-center justify-between">
        <Button
          variant="outline"
          onClick={goToPrevious}
          disabled={currentQuestionIndex === 0}
        >
          <ChevronLeft className="h-4 w-4 mr-2" />
          이전
        </Button>

        <Button variant="outline" onClick={() => saveAnswers(answers)}>
          <Save className="h-4 w-4 mr-2" />
          저장
        </Button>

        {currentQuestionIndex === ALL_QUESTIONS.length - 1 ? (
          <Button onClick={goToGenerate}>
            랜딩페이지 생성
            <ChevronRight className="h-4 w-4 ml-2" />
          </Button>
        ) : (
          <Button onClick={goToNext}>
            다음
            <ChevronRight className="h-4 w-4 ml-2" />
          </Button>
        )}
      </div>

      {/* 질문 목록 (점 표시) */}
      <div className="mt-8 flex flex-wrap gap-2 justify-center">
        {ALL_QUESTIONS.map((q, index) => {
          const isAnswered = !!answers[`q${q.id}`]?.trim();
          const isCurrent = index === currentQuestionIndex;

          return (
            <button
              key={q.id}
              onClick={() => setCurrentQuestionIndex(index)}
              className={`
                w-3 h-3 rounded-full transition-colors
                ${isCurrent ? 'bg-blue-600' : isAnswered ? 'bg-green-500' : 'bg-gray-300'}
              `}
              aria-label={`질문 ${q.id}${isAnswered ? ' (답변 완료)' : ''}`}
            />
          );
        })}
      </div>
    </div>
  );
}
```

---

### 3.7 AI 생성 화면 (SSE 스트리밍)

**파일**: `src/app/(dashboard)/landing-pages/generate/page.tsx`

```typescript
// src/app/(dashboard)/landing-pages/generate/page.tsx
'use client';

import { useState, useEffect, useRef } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import { Loader2, CheckCircle, XCircle, AlertCircle } from 'lucide-react';

import { Button } from '@/components/ui/button';
import { Progress } from '@/components/ui/progress';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { useAuthStore } from '@/stores/auth-store';

/**
 * 생성 단계
 */
const GENERATION_STEPS = [
  { id: 1, label: '입력 검증', startProgress: 0 },
  { id: 2, label: '토큰 확인', startProgress: 20 },
  { id: 3, label: '프롬프트 생성', startProgress: 30 },
  { id: 4, label: 'AI 콘텐츠 생성', startProgress: 40 },
  { id: 5, label: '결과 검증', startProgress: 85 },
  { id: 6, label: '저장', startProgress: 90 },
];

/**
 * 진행률에서 현재 단계 찾기
 */
function getCurrentStep(progress: number) {
  for (let i = GENERATION_STEPS.length - 1; i >= 0; i--) {
    if (progress >= GENERATION_STEPS[i].startProgress) {
      return GENERATION_STEPS[i];
    }
  }
  return GENERATION_STEPS[0];
}

export default function GeneratePage() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const sessionId = searchParams.get('sessionId');

  const { accessToken } = useAuthStore();

  // 상태
  const [status, setStatus] = useState<'idle' | 'generating' | 'success' | 'error'>('idle');
  const [progress, setProgress] = useState(0);
  const [message, setMessage] = useState('');
  const [error, setError] = useState<string | null>(null);
  const [result, setResult] = useState<{
    id: string;
    title: string;
    tokensUsed: number;
  } | null>(null);

  // SSE 연결 ref
  const eventSourceRef = useRef<EventSource | null>(null);

  /**
   * 생성 시작
   */
  const startGeneration = async () => {
    if (!sessionId || !accessToken) {
      setError('세션 정보가 없습니다');
      return;
    }

    setStatus('generating');
    setProgress(0);
    setMessage('생성 준비 중...');
    setError(null);

    try {
      // SSE 연결
      const response = await fetch('/api/ai/generate', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${accessToken}`,
        },
        body: JSON.stringify({ qaSessionId: sessionId }),
      });

      if (!response.ok || !response.body) {
        throw new Error('생성 요청 실패');
      }

      // SSE 스트림 읽기
      const reader = response.body.getReader();
      const decoder = new TextDecoder();

      while (true) {
        const { done, value } = await reader.read();

        if (done) break;

        const chunk = decoder.decode(value);
        const lines = chunk.split('\n');

        for (const line of lines) {
          if (line.startsWith('event:')) {
            const eventType = line.slice(7).trim();
            continue;
          }

          if (line.startsWith('data:')) {
            try {
              const data = JSON.parse(line.slice(5));

              // 이벤트 처리
              if (data.progress !== undefined) {
                setProgress(data.progress);
                setMessage(data.message || '');
              }

              if (data.id) {
                // 완료
                setResult({
                  id: data.id,
                  title: data.title,
                  tokensUsed: data.tokensUsed,
                });
                setStatus('success');
                setProgress(100);
              }

              if (data.code) {
                // 에러
                setError(data.message || '생성에 실패했습니다');
                setStatus('error');
              }
            } catch (parseError) {
              // JSON 파싱 실패 무시
            }
          }
        }
      }
    } catch (err) {
      console.error('[Generate] Error:', err);
      setError('생성 중 오류가 발생했습니다');
      setStatus('error');
    }
  };

  /**
   * 세션 ID 확인 후 자동 시작
   */
  useEffect(() => {
    if (sessionId && status === 'idle') {
      startGeneration();
    }
  }, [sessionId]);

  /**
   * 클린업
   */
  useEffect(() => {
    return () => {
      if (eventSourceRef.current) {
        eventSourceRef.current.close();
      }
    };
  }, []);

  const currentStep = getCurrentStep(progress);

  // 세션 ID 없음
  if (!sessionId) {
    return (
      <div className="max-w-2xl mx-auto text-center py-12">
        <Alert variant="destructive">
          <AlertCircle className="h-4 w-4" />
          <AlertDescription>
            Q&A 세션을 먼저 완료해주세요
          </AlertDescription>
        </Alert>
        <Button className="mt-4" onClick={() => router.push('/qa')}>
          Q&A 세션으로 이동
        </Button>
      </div>
    );
  }

  return (
    <div className="max-w-2xl mx-auto">
      <div className="text-center py-8">
        {/* 상태별 아이콘 */}
        <div className="mb-6">
          {status === 'generating' && (
            <div className="w-20 h-20 mx-auto rounded-full bg-blue-100 flex items-center justify-center">
              <Loader2 className="h-10 w-10 text-blue-600 animate-spin" />
            </div>
          )}
          {status === 'success' && (
            <div className="w-20 h-20 mx-auto rounded-full bg-green-100 flex items-center justify-center">
              <CheckCircle className="h-10 w-10 text-green-600" />
            </div>
          )}
          {status === 'error' && (
            <div className="w-20 h-20 mx-auto rounded-full bg-red-100 flex items-center justify-center">
              <XCircle className="h-10 w-10 text-red-600" />
            </div>
          )}
        </div>

        {/* 제목 */}
        <h1 className="text-2xl font-bold mb-2">
          {status === 'generating' && 'AI 랜딩페이지 생성 중'}
          {status === 'success' && '생성 완료!'}
          {status === 'error' && '생성 실패'}
        </h1>

        {/* 메시지 */}
        <p className="text-gray-600 mb-6">
          {status === 'generating' && message}
          {status === 'success' && `"${result?.title}" 랜딩페이지가 생성되었습니다`}
          {status === 'error' && error}
        </p>

        {/* 진행률 바 */}
        {status === 'generating' && (
          <div className="max-w-md mx-auto mb-8">
            <Progress value={progress} className="h-3 mb-2" />
            <p className="text-sm text-gray-500">{progress}%</p>
          </div>
        )}

        {/* 단계 표시 */}
        {status === 'generating' && (
          <div className="bg-white rounded-lg shadow-md p-6 mb-6">
            <h3 className="text-sm font-medium text-gray-500 mb-4">진행 상황</h3>
            <div className="space-y-3">
              {GENERATION_STEPS.map((step) => {
                const isCompleted = progress > step.startProgress;
                const isCurrent = currentStep.id === step.id;

                return (
                  <div
                    key={step.id}
                    className="flex items-center space-x-3"
                  >
                    <div
                      className={`
                        w-6 h-6 rounded-full flex items-center justify-center text-xs font-medium
                        ${isCompleted ? 'bg-green-100 text-green-600' : isCurrent ? 'bg-blue-100 text-blue-600' : 'bg-gray-100 text-gray-400'}
                      `}
                    >
                      {isCompleted ? (
                        <CheckCircle className="h-4 w-4" />
                      ) : isCurrent ? (
                        <Loader2 className="h-4 w-4 animate-spin" />
                      ) : (
                        step.id
                      )}
                    </div>
                    <span
                      className={`text-sm ${
                        isCompleted
                          ? 'text-green-600'
                          : isCurrent
                          ? 'text-blue-600 font-medium'
                          : 'text-gray-400'
                      }`}
                    >
                      {step.label}
                    </span>
                  </div>
                );
              })}
            </div>
          </div>
        )}

        {/* 타임아웃 안내 */}
        {status === 'generating' && (
          <p className="text-sm text-gray-500 mb-6">
            복잡한 내용은 최대 90초까지 소요될 수 있습니다
          </p>
        )}

        {/* 성공 시 토큰 사용량 */}
        {status === 'success' && result && (
          <div className="bg-gray-50 rounded-lg p-4 mb-6 text-sm text-gray-600">
            <p>사용된 토큰: {result.tokensUsed.toLocaleString()}</p>
          </div>
        )}

        {/* 버튼 */}
        <div className="flex justify-center space-x-4">
          {status === 'generating' && (
            <Button
              variant="outline"
              onClick={() => router.push('/qa')}
            >
              취소
            </Button>
          )}

          {status === 'success' && result && (
            <>
              <Button
                variant="outline"
                onClick={() => router.push('/landing-pages')}
              >
                목록으로
              </Button>
              <Button
                onClick={() => router.push(`/landing-pages/${result.id}`)}
              >
                결과 확인
              </Button>
            </>
          )}

          {status === 'error' && (
            <>
              <Button variant="outline" onClick={() => router.push('/qa')}>
                Q&A로 돌아가기
              </Button>
              <Button onClick={startGeneration}>
                다시 시도
              </Button>
            </>
          )}
        </div>
      </div>
    </div>
  );
}
```

---

### 3.8 랜딩페이지 목록 (Soft Delete 포함)

**파일**: `src/app/(dashboard)/landing-pages/page.tsx`

```typescript
// src/app/(dashboard)/landing-pages/page.tsx
'use client';

import { useState, useEffect } from 'react';
import Link from 'next/link';
import {
  Plus,
  FileText,
  Eye,
  Edit,
  Trash2,
  MoreVertical,
  ExternalLink,
  Loader2,
} from 'lucide-react';

import { Button } from '@/components/ui/button';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog';
import { useAuthStore } from '@/stores/auth-store';

/**
 * 랜딩페이지 타입
 */
interface LandingPage {
  id: string;
  title: string;
  status: 'draft' | 'published';
  publishedUrl?: string;
  createdAt: string;
  updatedAt: string;
  viewCount?: number;
  clickCount?: number;
}

export default function LandingPagesPage() {
  const { accessToken } = useAuthStore();

  // 상태
  const [isLoading, setIsLoading] = useState(true);
  const [pages, setPages] = useState<LandingPage[]>([]);
  const [deleteTarget, setDeleteTarget] = useState<LandingPage | null>(null);
  const [isDeleting, setIsDeleting] = useState(false);

  /**
   * 랜딩페이지 목록 조회
   */
  useEffect(() => {
    const fetchPages = async () => {
      try {
        const response = await fetch('/api/landing-pages', {
          headers: { Authorization: `Bearer ${accessToken}` },
        });

        if (response.ok) {
          const data = await response.json();
          setPages(data.data || []);
        }
      } catch (error) {
        console.error('[LandingPages] Fetch error:', error);
      } finally {
        setIsLoading(false);
      }
    };

    fetchPages();
  }, [accessToken]);

  /**
   * 삭제 처리 (Soft Delete)
   */
  const handleDelete = async () => {
    if (!deleteTarget) return;

    setIsDeleting(true);
    try {
      const response = await fetch(`/api/landing-pages/${deleteTarget.id}`, {
        method: 'DELETE',
        headers: { Authorization: `Bearer ${accessToken}` },
      });

      if (response.ok) {
        // 목록에서 제거
        setPages(pages.filter((p) => p.id !== deleteTarget.id));
      }
    } catch (error) {
      console.error('[LandingPages] Delete error:', error);
    } finally {
      setIsDeleting(false);
      setDeleteTarget(null);
    }
  };

  /**
   * 상태 배지 색상
   */
  const getStatusBadge = (status: string) => {
    switch (status) {
      case 'published':
        return 'bg-green-100 text-green-800';
      case 'draft':
        return 'bg-gray-100 text-gray-800';
      default:
        return 'bg-gray-100 text-gray-800';
    }
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <Loader2 className="h-8 w-8 animate-spin text-gray-400" />
      </div>
    );
  }

  return (
    <div>
      {/* 헤더 */}
      <div className="flex items-center justify-between mb-6">
        <div>
          <h1 className="text-2xl font-bold">랜딩페이지</h1>
          <p className="text-gray-600 mt-1">
            생성된 랜딩페이지를 관리하세요
          </p>
        </div>
        <Link href="/qa/new">
          <Button>
            <Plus className="h-4 w-4 mr-2" />
            새 랜딩페이지 만들기
          </Button>
        </Link>
      </div>

      {/* 빈 상태 */}
      {pages.length === 0 ? (
        <div className="text-center py-12 bg-white rounded-lg shadow-sm">
          <FileText className="h-12 w-12 mx-auto text-gray-300 mb-4" />
          <h3 className="text-lg font-medium text-gray-900 mb-2">
            아직 랜딩페이지가 없습니다
          </h3>
          <p className="text-gray-500 mb-4">
            Q&A를 완료하고 첫 번째 랜딩페이지를 생성해보세요
          </p>
          <Link href="/qa/new">
            <Button>
              <Plus className="h-4 w-4 mr-2" />
              시작하기
            </Button>
          </Link>
        </div>
      ) : (
        /* 목록 */
        <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
          {pages.map((page) => (
            <div
              key={page.id}
              className="bg-white rounded-lg shadow-sm border hover:shadow-md transition-shadow"
            >
              <div className="p-4">
                {/* 제목 & 상태 */}
                <div className="flex items-start justify-between mb-3">
                  <h3 className="font-medium line-clamp-2">{page.title}</h3>
                  <span
                    className={`px-2 py-1 text-xs rounded-full ${getStatusBadge(
                      page.status
                    )}`}
                  >
                    {page.status === 'published' ? '배포됨' : '초안'}
                  </span>
                </div>

                {/* 메타 정보 */}
                <div className="text-sm text-gray-500 space-y-1 mb-4">
                  <p>
                    생성일:{' '}
                    {new Date(page.createdAt).toLocaleDateString('ko-KR')}
                  </p>
                  {page.status === 'published' && (
                    <p>조회수: {page.viewCount?.toLocaleString() || 0}</p>
                  )}
                </div>

                {/* 액션 버튼 */}
                <div className="flex items-center justify-between">
                  <div className="flex space-x-2">
                    <Link href={`/landing-pages/${page.id}/preview`}>
                      <Button variant="outline" size="sm">
                        <Eye className="h-4 w-4" />
                      </Button>
                    </Link>
                    <Link href={`/landing-pages/${page.id}/edit`}>
                      <Button variant="outline" size="sm">
                        <Edit className="h-4 w-4" />
                      </Button>
                    </Link>
                  </div>

                  <DropdownMenu>
                    <DropdownMenuTrigger asChild>
                      <Button variant="ghost" size="sm">
                        <MoreVertical className="h-4 w-4" />
                      </Button>
                    </DropdownMenuTrigger>
                    <DropdownMenuContent align="end">
                      {page.publishedUrl && (
                        <DropdownMenuItem asChild>
                          <a
                            href={page.publishedUrl}
                            target="_blank"
                            rel="noopener noreferrer"
                          >
                            <ExternalLink className="h-4 w-4 mr-2" />
                            배포 URL 열기
                          </a>
                        </DropdownMenuItem>
                      )}
                      <DropdownMenuItem
                        className="text-red-600"
                        onClick={() => setDeleteTarget(page)}
                      >
                        <Trash2 className="h-4 w-4 mr-2" />
                        삭제
                      </DropdownMenuItem>
                    </DropdownMenuContent>
                  </DropdownMenu>
                </div>
              </div>
            </div>
          ))}
        </div>
      )}

      {/* 삭제 확인 다이얼로그 */}
      <AlertDialog
        open={!!deleteTarget}
        onOpenChange={() => setDeleteTarget(null)}
      >
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>랜딩페이지 삭제</AlertDialogTitle>
            <AlertDialogDescription>
              "{deleteTarget?.title}"을(를) 삭제하시겠습니까?
              <br />
              <br />
              <strong>삭제된 랜딩페이지는 30일간 복구할 수 있습니다.</strong>
              <br />
              배포된 URL은 즉시 비활성화됩니다.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={isDeleting}>취소</AlertDialogCancel>
            <AlertDialogAction
              onClick={handleDelete}
              disabled={isDeleting}
              className="bg-red-600 hover:bg-red-700"
            >
              {isDeleting ? (
                <>
                  <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                  삭제 중...
                </>
              ) : (
                '삭제하기'
              )}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}
```

---

### 3.9 휴지통 (삭제된 항목 복구)

**파일**: `src/app/(dashboard)/trash/page.tsx`

```typescript
// src/app/(dashboard)/trash/page.tsx
'use client';

import { useState, useEffect } from 'react';
import { Trash2, RotateCcw, Loader2, AlertTriangle } from 'lucide-react';

import { Button } from '@/components/ui/button';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog';
import { useAuthStore } from '@/stores/auth-store';

/**
 * 삭제된 항목 타입
 */
interface DeletedItem {
  id: string;
  title: string;
  type: 'landing_page' | 'qa_session';
  deletedAt: string;
  daysRemaining: number;
}

export default function TrashPage() {
  const { accessToken } = useAuthStore();

  // 상태
  const [isLoading, setIsLoading] = useState(true);
  const [items, setItems] = useState<DeletedItem[]>([]);
  const [restoreTarget, setRestoreTarget] = useState<DeletedItem | null>(null);
  const [deleteTarget, setDeleteTarget] = useState<DeletedItem | null>(null);
  const [isProcessing, setIsProcessing] = useState(false);

  /**
   * 삭제된 항목 목록 조회
   */
  useEffect(() => {
    const fetchTrash = async () => {
      try {
        const response = await fetch('/api/trash', {
          headers: { Authorization: `Bearer ${accessToken}` },
        });

        if (response.ok) {
          const data = await response.json();
          setItems(data.data || []);
        }
      } catch (error) {
        console.error('[Trash] Fetch error:', error);
      } finally {
        setIsLoading(false);
      }
    };

    fetchTrash();
  }, [accessToken]);

  /**
   * 복구 처리
   */
  const handleRestore = async () => {
    if (!restoreTarget) return;

    setIsProcessing(true);
    try {
      const endpoint =
        restoreTarget.type === 'landing_page'
          ? `/api/landing-pages/${restoreTarget.id}/restore`
          : `/api/qa-sessions/${restoreTarget.id}/restore`;

      const response = await fetch(endpoint, {
        method: 'POST',
        headers: { Authorization: `Bearer ${accessToken}` },
      });

      if (response.ok) {
        setItems(items.filter((i) => i.id !== restoreTarget.id));
      }
    } catch (error) {
      console.error('[Trash] Restore error:', error);
    } finally {
      setIsProcessing(false);
      setRestoreTarget(null);
    }
  };

  /**
   * 영구 삭제 처리
   */
  const handlePermanentDelete = async () => {
    if (!deleteTarget) return;

    setIsProcessing(true);
    try {
      const endpoint =
        deleteTarget.type === 'landing_page'
          ? `/api/landing-pages/${deleteTarget.id}/permanent`
          : `/api/qa-sessions/${deleteTarget.id}/permanent`;

      const response = await fetch(endpoint, {
        method: 'DELETE',
        headers: { Authorization: `Bearer ${accessToken}` },
      });

      if (response.ok) {
        setItems(items.filter((i) => i.id !== deleteTarget.id));
      }
    } catch (error) {
      console.error('[Trash] Permanent delete error:', error);
    } finally {
      setIsProcessing(false);
      setDeleteTarget(null);
    }
  };

  /**
   * 타입 라벨
   */
  const getTypeLabel = (type: string) => {
    switch (type) {
      case 'landing_page':
        return '랜딩페이지';
      case 'qa_session':
        return 'Q&A 세션';
      default:
        return '항목';
    }
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <Loader2 className="h-8 w-8 animate-spin text-gray-400" />
      </div>
    );
  }

  return (
    <div>
      {/* 헤더 */}
      <div className="mb-6">
        <h1 className="text-2xl font-bold flex items-center">
          <Trash2 className="h-6 w-6 mr-2" />
          휴지통
        </h1>
        <p className="text-gray-600 mt-1">
          삭제된 항목은 30일 후 영구 삭제됩니다
        </p>
      </div>

      {/* 빈 상태 */}
      {items.length === 0 ? (
        <div className="text-center py-12 bg-white rounded-lg shadow-sm">
          <Trash2 className="h-12 w-12 mx-auto text-gray-300 mb-4" />
          <h3 className="text-lg font-medium text-gray-900 mb-2">
            휴지통이 비어있습니다
          </h3>
          <p className="text-gray-500">
            삭제된 항목이 여기에 표시됩니다
          </p>
        </div>
      ) : (
        /* 목록 */
        <div className="space-y-3">
          {items.map((item) => (
            <div
              key={item.id}
              className="bg-white rounded-lg shadow-sm border p-4 flex items-center justify-between"
            >
              <div>
                <div className="flex items-center space-x-2 mb-1">
                  <span className="text-xs bg-gray-100 text-gray-600 px-2 py-0.5 rounded">
                    {getTypeLabel(item.type)}
                  </span>
                  <h3 className="font-medium">{item.title}</h3>
                </div>
                <p className="text-sm text-gray-500">
                  삭제일:{' '}
                  {new Date(item.deletedAt).toLocaleDateString('ko-KR')} |{' '}
                  <span
                    className={
                      item.daysRemaining <= 7 ? 'text-red-500 font-medium' : ''
                    }
                  >
                    남은 기간: {item.daysRemaining}일
                  </span>
                </p>
              </div>

              <div className="flex space-x-2">
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => setRestoreTarget(item)}
                >
                  <RotateCcw className="h-4 w-4 mr-1" />
                  복구
                </Button>
                <Button
                  variant="outline"
                  size="sm"
                  className="text-red-600 hover:text-red-700"
                  onClick={() => setDeleteTarget(item)}
                >
                  <Trash2 className="h-4 w-4 mr-1" />
                  영구 삭제
                </Button>
              </div>
            </div>
          ))}
        </div>
      )}

      {/* 복구 확인 다이얼로그 */}
      <AlertDialog
        open={!!restoreTarget}
        onOpenChange={() => setRestoreTarget(null)}
      >
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>항목 복구</AlertDialogTitle>
            <AlertDialogDescription>
              "{restoreTarget?.title}"을(를) 복구하시겠습니까?
              <br />
              원래 위치로 복원됩니다.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={isProcessing}>취소</AlertDialogCancel>
            <AlertDialogAction onClick={handleRestore} disabled={isProcessing}>
              {isProcessing ? (
                <>
                  <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                  복구 중...
                </>
              ) : (
                '복구하기'
              )}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* 영구 삭제 확인 다이얼로그 */}
      <AlertDialog
        open={!!deleteTarget}
        onOpenChange={() => setDeleteTarget(null)}
      >
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle className="flex items-center text-red-600">
              <AlertTriangle className="h-5 w-5 mr-2" />
              영구 삭제
            </AlertDialogTitle>
            <AlertDialogDescription>
              "{deleteTarget?.title}"을(를) 영구 삭제하시겠습니까?
              <br />
              <br />
              <strong className="text-red-600">
                이 작업은 되돌릴 수 없습니다. 모든 데이터가 완전히 삭제됩니다.
              </strong>
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={isProcessing}>취소</AlertDialogCancel>
            <AlertDialogAction
              onClick={handlePermanentDelete}
              disabled={isProcessing}
              className="bg-red-600 hover:bg-red-700"
            >
              {isProcessing ? (
                <>
                  <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                  삭제 중...
                </>
              ) : (
                '영구 삭제'
              )}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}
```

---

### 3.10 에러 페이지

**파일**: `src/app/error.tsx`

```typescript
// src/app/error.tsx
'use client';

import { useEffect } from 'react';
import { AlertCircle, RefreshCw, Home } from 'lucide-react';

import { Button } from '@/components/ui/button';

/**
 * 에러 코드 생성 (사용자 문의용)
 */
function generateErrorCode(): string {
  const timestamp = Date.now().toString(36);
  const random = Math.random().toString(36).substring(2, 6);
  return `ERR-${timestamp}${random}`.toUpperCase();
}

interface ErrorPageProps {
  error: Error & { digest?: string };
  reset: () => void;
}

export default function ErrorPage({ error, reset }: ErrorPageProps) {
  const errorCode = generateErrorCode();

  useEffect(() => {
    // 에러 로깅 (Sentry 등)
    console.error('[Error Page]', {
      code: errorCode,
      message: error.message,
      digest: error.digest,
    });
  }, [error, errorCode]);

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 px-4">
      <div className="max-w-md w-full text-center">
        {/* 아이콘 */}
        <div className="w-16 h-16 mx-auto mb-6 rounded-full bg-red-100 flex items-center justify-center">
          <AlertCircle className="h-8 w-8 text-red-600" />
        </div>

        {/* 제목 */}
        <h1 className="text-2xl font-bold text-gray-900 mb-2">
          오류가 발생했습니다
        </h1>

        {/* 일반화된 메시지 (상세 정보 노출 X) */}
        <p className="text-gray-600 mb-6">
          서비스 이용에 불편을 드려 죄송합니다.
          <br />
          문제가 지속되면 고객센터에 문의해주세요.
        </p>

        {/* 에러 코드 (문의용) */}
        <div className="bg-gray-100 rounded-lg p-4 mb-6">
          <p className="text-sm text-gray-500 mb-1">오류 코드</p>
          <p className="font-mono font-medium">{errorCode}</p>
          <p className="text-xs text-gray-400 mt-2">
            발생 시간: {new Date().toLocaleString('ko-KR')}
          </p>
        </div>

        {/* 버튼 */}
        <div className="flex flex-col sm:flex-row gap-3 justify-center">
          <Button variant="outline" onClick={reset}>
            <RefreshCw className="h-4 w-4 mr-2" />
            다시 시도
          </Button>
          <Button onClick={() => (window.location.href = '/')}>
            <Home className="h-4 w-4 mr-2" />
            홈으로 돌아가기
          </Button>
        </div>

        {/* 고객센터 링크 */}
        <p className="mt-6 text-sm text-gray-500">
          문제가 계속되면{' '}
          <a href="mailto:support@example.com" className="text-blue-600 hover:underline">
            고객센터
          </a>
          에 문의해주세요
        </p>
      </div>
    </div>
  );
}
```

---

## 4. 환경 변수

```bash
# .env.local

# Next.js
NEXT_PUBLIC_APP_URL=http://localhost:3000

# Supabase
NEXT_PUBLIC_SUPABASE_URL=https://xxx.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=eyJxxxxx

# Feature Flags (Optional)
NEXT_PUBLIC_ENABLE_ANALYTICS=false
```

---

## 5. 접근성 체크리스트

### 5.1 WCAG 2.1 AA 준수
| 항목 | 기준 | 구현 |
|------|------|------|
| 색상 대비 | 4.5:1 이상 | Tailwind 기본 색상 사용 |
| 키보드 네비게이션 | 모든 기능 접근 | Tab/Enter/Escape 지원 |
| 스크린 리더 | ARIA 레이블 | aria-label, aria-describedby |
| 포커스 표시 | 명확한 시각적 표시 | focus:ring-2 |
| 에러 식별 | 색상 외 추가 표시 | 아이콘 + 텍스트 |
| 입력 도움말 | 명확한 레이블/안내 | Label + placeholder |

### 5.2 키보드 단축키
| 단축키 | 기능 | 페이지 |
|--------|------|--------|
| Tab | 다음 요소 | 전체 |
| Shift+Tab | 이전 요소 | 전체 |
| Enter | 버튼 클릭/폼 제출 | 전체 |
| Escape | 모달 닫기 | 모달 |
| Ctrl+S | 저장 | Q&A |

---

## 6. 구현 체크리스트

### 6.1 인증
- [ ] Zustand 인증 스토어
- [ ] Auth Provider (자동 토큰 갱신)
- [ ] 로그인 페이지
- [ ] 회원가입 페이지
- [ ] 비밀번호 재설정 페이지
- [ ] 승인 대기 페이지

### 6.2 대시보드
- [ ] 대시보드 레이아웃 (사이드바)
- [ ] 메인 대시보드 (토큰 사용량)
- [ ] 모바일 반응형

### 6.3 Q&A
- [ ] 세션 목록
- [ ] 새 세션 생성
- [ ] 질문 답변 UI
- [ ] 자동 저장
- [ ] 진행률 표시

### 6.4 랜딩페이지
- [ ] 목록 페이지
- [ ] AI 생성 화면 (SSE)
- [ ] 미리보기
- [ ] 편집
- [ ] 휴지통 (Soft Delete)
- [ ] 복구

### 6.5 공통
- [ ] 에러 페이지 (일반화)
- [ ] 404 페이지
- [ ] 로딩 상태
- [ ] Toast 알림

---

## 7. 성능 최적화

### 7.1 Next.js 최적화
```typescript
// next.config.js
const nextConfig = {
  // 이미지 최적화
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: '*.supabase.co',
      },
    ],
  },

  // 번들 분석 (선택)
  experimental: {
    optimizePackageImports: ['lucide-react', '@radix-ui/react-icons'],
  },
};
```

### 7.2 컴포넌트 최적화
```typescript
// 동적 임포트 예시
import dynamic from 'next/dynamic';

const HeavyEditor = dynamic(() => import('@/components/editor'), {
  loading: () => <EditorSkeleton />,
  ssr: false,
});
```

### 7.3 데이터 페칭 최적화
```typescript
// SWR 사용 예시
import useSWR from 'swr';

const fetcher = (url: string) =>
  fetch(url, {
    headers: { Authorization: `Bearer ${accessToken}` },
  }).then((res) => res.json());

const { data, error, isLoading } = useSWR(
  '/api/landing-pages',
  fetcher,
  {
    revalidateOnFocus: false,
    dedupingInterval: 5000,
  }
);
```
