# 09. 배포 가이드 (Deployment Guide)

## 목차
1. [배포 아키텍처 개요](#1-배포-아키텍처-개요)
2. [Vercel 프로젝트 설정](#2-vercel-프로젝트-설정)
3. [환경 변수 관리](#3-환경-변수-관리)
4. [CI/CD 파이프라인](#4-cicd-파이프라인)
5. [배포 전략](#5-배포-전략)
6. [데이터베이스 마이그레이션](#6-데이터베이스-마이그레이션)
7. [도메인 및 SSL 설정](#7-도메인-및-ssl-설정)
8. [Edge Functions 및 Middleware](#8-edge-functions-및-middleware)
9. [캐싱 전략](#9-캐싱-전략)
10. [모니터링 및 관측성](#10-모니터링-및-관측성)
11. [롤백 절차](#11-롤백-절차)
12. [배포 체크리스트](#12-배포-체크리스트)

---

## 1. 배포 아키텍처 개요

### 1.1 인프라 다이어그램

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              DEPLOYMENT ARCHITECTURE                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌──────────────┐     ┌──────────────┐     ┌──────────────┐                │
│  │   GitHub     │────▶│   Vercel     │────▶│   Preview    │                │
│  │  Repository  │     │   CI/CD      │     │   Deploy     │                │
│  └──────────────┘     └──────────────┘     └──────────────┘                │
│         │                    │                                              │
│         │                    ▼                                              │
│         │             ┌──────────────┐     ┌──────────────┐                │
│         │             │   Staging    │────▶│  Production  │                │
│         │             │   Deploy     │     │   Deploy     │                │
│         │             └──────────────┘     └──────────────┘                │
│         │                                         │                         │
│         ▼                                         ▼                         │
│  ┌──────────────────────────────────────────────────────────────┐          │
│  │                        VERCEL EDGE NETWORK                    │          │
│  │  ┌────────────┐  ┌────────────┐  ┌────────────┐              │          │
│  │  │   Edge     │  │   CDN      │  │  Serverless│              │          │
│  │  │  Functions │  │   Cache    │  │  Functions │              │          │
│  │  └────────────┘  └────────────┘  └────────────┘              │          │
│  └──────────────────────────────────────────────────────────────┘          │
│                              │                                              │
│         ┌────────────────────┼────────────────────┐                        │
│         ▼                    ▼                    ▼                         │
│  ┌──────────────┐     ┌──────────────┐     ┌──────────────┐                │
│  │   Supabase   │     │   Claude     │     │    Redis     │                │
│  │  PostgreSQL  │     │     API      │     │   (Upstash)  │                │
│  └──────────────┘     └──────────────┘     └──────────────┘                │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 1.2 배포 환경 구성

```typescript
// /src/config/deployment.ts
/**
 * 배포 환경 설정
 *
 * @description 각 환경별 설정을 정의
 * @dependencies 없음
 */

export type Environment = 'development' | 'preview' | 'staging' | 'production';

export interface EnvironmentConfig {
  name: Environment;
  apiUrl: string;
  supabaseUrl: string;
  features: {
    analytics: boolean;
    errorTracking: boolean;
    performanceMonitoring: boolean;
    debugMode: boolean;
  };
  limits: {
    maxProjects: number;
    maxQuestionsPerProject: number;
    aiGenerationsPerDay: number;
  };
}

const configs: Record<Environment, EnvironmentConfig> = {
  development: {
    name: 'development',
    apiUrl: 'http://localhost:3000',
    supabaseUrl: process.env.NEXT_PUBLIC_SUPABASE_URL || '',
    features: {
      analytics: false,
      errorTracking: false,
      performanceMonitoring: false,
      debugMode: true,
    },
    limits: {
      maxProjects: 100,
      maxQuestionsPerProject: 100,
      aiGenerationsPerDay: 1000,
    },
  },
  preview: {
    name: 'preview',
    apiUrl: process.env.VERCEL_URL ? `https://${process.env.VERCEL_URL}` : '',
    supabaseUrl: process.env.NEXT_PUBLIC_SUPABASE_URL || '',
    features: {
      analytics: false,
      errorTracking: true,
      performanceMonitoring: false,
      debugMode: true,
    },
    limits: {
      maxProjects: 10,
      maxQuestionsPerProject: 20,
      aiGenerationsPerDay: 50,
    },
  },
  staging: {
    name: 'staging',
    apiUrl: 'https://staging.magnetic-sales.app',
    supabaseUrl: process.env.NEXT_PUBLIC_SUPABASE_URL || '',
    features: {
      analytics: true,
      errorTracking: true,
      performanceMonitoring: true,
      debugMode: false,
    },
    limits: {
      maxProjects: 50,
      maxQuestionsPerProject: 50,
      aiGenerationsPerDay: 200,
    },
  },
  production: {
    name: 'production',
    apiUrl: 'https://magnetic-sales.app',
    supabaseUrl: process.env.NEXT_PUBLIC_SUPABASE_URL || '',
    features: {
      analytics: true,
      errorTracking: true,
      performanceMonitoring: true,
      debugMode: false,
    },
    limits: {
      maxProjects: 20,
      maxQuestionsPerProject: 30,
      aiGenerationsPerDay: 100,
    },
  },
};

export function getEnvironment(): Environment {
  if (process.env.VERCEL_ENV === 'production') return 'production';
  if (process.env.VERCEL_ENV === 'preview') {
    // staging 브랜치인 경우 staging 환경으로 처리
    if (process.env.VERCEL_GIT_COMMIT_REF === 'staging') return 'staging';
    return 'preview';
  }
  return 'development';
}

export function getConfig(): EnvironmentConfig {
  return configs[getEnvironment()];
}

export function isProduction(): boolean {
  return getEnvironment() === 'production';
}

export function isDevelopment(): boolean {
  return getEnvironment() === 'development';
}

export function isPreview(): boolean {
  return getEnvironment() === 'preview';
}
```

---

## 2. Vercel 프로젝트 설정

### 2.1 vercel.json 구성

```json
// /vercel.json
{
  "$schema": "https://openapi.vercel.sh/vercel.json",
  "framework": "nextjs",
  "buildCommand": "pnpm build",
  "devCommand": "pnpm dev",
  "installCommand": "pnpm install",
  "regions": ["icn1", "hnd1"],
  "functions": {
    "app/api/**/*.ts": {
      "maxDuration": 30,
      "memory": 1024
    },
    "app/api/ai/**/*.ts": {
      "maxDuration": 60,
      "memory": 1024
    }
  },
  "headers": [
    {
      "source": "/api/(.*)",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "no-store, max-age=0"
        }
      ]
    },
    {
      "source": "/(.*)",
      "headers": [
        {
          "key": "X-Content-Type-Options",
          "value": "nosniff"
        },
        {
          "key": "X-Frame-Options",
          "value": "DENY"
        },
        {
          "key": "X-XSS-Protection",
          "value": "1; mode=block"
        },
        {
          "key": "Referrer-Policy",
          "value": "strict-origin-when-cross-origin"
        },
        {
          "key": "Permissions-Policy",
          "value": "camera=(), microphone=(), geolocation=()"
        }
      ]
    },
    {
      "source": "/fonts/(.*)",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "public, max-age=31536000, immutable"
        }
      ]
    },
    {
      "source": "/_next/static/(.*)",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "public, max-age=31536000, immutable"
        }
      ]
    }
  ],
  "rewrites": [
    {
      "source": "/healthz",
      "destination": "/api/health"
    }
  ],
  "redirects": [
    {
      "source": "/login",
      "destination": "/auth/login",
      "permanent": true
    },
    {
      "source": "/signup",
      "destination": "/auth/register",
      "permanent": true
    }
  ],
  "crons": [
    {
      "path": "/api/cron/cleanup-expired-sessions",
      "schedule": "0 2 * * *"
    },
    {
      "path": "/api/cron/usage-report",
      "schedule": "0 0 * * 1"
    }
  ]
}
```

### 2.2 Next.js 프로덕션 설정

```typescript
// /next.config.ts
/**
 * Next.js 프로덕션 설정
 *
 * @description 빌드 및 런타임 최적화 설정
 * @dependencies @next/bundle-analyzer
 */

import type { NextConfig } from 'next';
import bundleAnalyzer from '@next/bundle-analyzer';

const withBundleAnalyzer = bundleAnalyzer({
  enabled: process.env.ANALYZE === 'true',
});

const securityHeaders = [
  {
    key: 'Content-Security-Policy',
    value: [
      "default-src 'self'",
      "script-src 'self' 'unsafe-eval' 'unsafe-inline' https://va.vercel-scripts.com",
      "style-src 'self' 'unsafe-inline'",
      "img-src 'self' data: https: blob:",
      "font-src 'self' data:",
      "connect-src 'self' https://*.supabase.co https://api.anthropic.com wss://*.supabase.co",
      "frame-ancestors 'none'",
      "base-uri 'self'",
      "form-action 'self'",
    ].join('; '),
  },
  {
    key: 'Strict-Transport-Security',
    value: 'max-age=63072000; includeSubDomains; preload',
  },
];

const nextConfig: NextConfig = {
  // 실험적 기능
  experimental: {
    serverActions: {
      bodySizeLimit: '2mb',
    },
    optimizePackageImports: ['lucide-react', '@radix-ui/react-icons'],
  },

  // 이미지 최적화
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: '*.supabase.co',
        pathname: '/storage/v1/object/public/**',
      },
    ],
    formats: ['image/avif', 'image/webp'],
    minimumCacheTTL: 60 * 60 * 24 * 7, // 7일
  },

  // 헤더 설정
  async headers() {
    return [
      {
        source: '/(.*)',
        headers: securityHeaders,
      },
    ];
  },

  // 리다이렉트
  async redirects() {
    return [
      {
        source: '/home',
        destination: '/',
        permanent: true,
      },
    ];
  },

  // Webpack 설정
  webpack: (config, { isServer }) => {
    // 번들 크기 최적화
    if (!isServer) {
      config.resolve.fallback = {
        ...config.resolve.fallback,
        fs: false,
        net: false,
        tls: false,
      };
    }

    // SVG를 React 컴포넌트로 변환
    config.module.rules.push({
      test: /\.svg$/,
      use: ['@svgr/webpack'],
    });

    return config;
  },

  // 출력 설정
  output: 'standalone',
  poweredByHeader: false,
  compress: true,
  reactStrictMode: true,

  // 로깅
  logging: {
    fetches: {
      fullUrl: process.env.NODE_ENV === 'development',
    },
  },

  // TypeScript
  typescript: {
    ignoreBuildErrors: false,
  },

  // ESLint
  eslint: {
    ignoreDuringBuilds: false,
  },
};

export default withBundleAnalyzer(nextConfig);
```

### 2.3 Vercel CLI 설정 스크립트

```typescript
// /scripts/vercel-setup.ts
/**
 * Vercel 프로젝트 설정 스크립트
 *
 * @description Vercel CLI를 사용한 프로젝트 초기 설정
 * @dependencies execa, dotenv
 * @usage npx tsx scripts/vercel-setup.ts
 */

import { execa } from 'execa';
import * as dotenv from 'dotenv';
import * as readline from 'readline';

dotenv.config();

interface VercelProject {
  id: string;
  name: string;
  accountId: string;
}

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

function question(prompt: string): Promise<string> {
  return new Promise((resolve) => {
    rl.question(prompt, resolve);
  });
}

async function checkVercelCLI(): Promise<boolean> {
  try {
    await execa('vercel', ['--version']);
    return true;
  } catch {
    return false;
  }
}

async function loginToVercel(): Promise<void> {
  console.log('Vercel 로그인 중...');
  await execa('vercel', ['login'], { stdio: 'inherit' });
}

async function linkProject(): Promise<VercelProject> {
  console.log('\n프로젝트 연결 중...');
  const result = await execa('vercel', ['link', '--yes'], { stdio: 'pipe' });

  // .vercel/project.json에서 프로젝트 정보 읽기
  const { readFileSync } = await import('fs');
  const projectConfig = JSON.parse(
    readFileSync('.vercel/project.json', 'utf-8')
  );

  return {
    id: projectConfig.projectId,
    name: projectConfig.settings?.projectName || 'magnetic-sales-webapp',
    accountId: projectConfig.orgId,
  };
}

async function setEnvironmentVariables(
  project: VercelProject
): Promise<void> {
  console.log('\n환경 변수 설정 중...');

  const envVars = [
    { key: 'NEXT_PUBLIC_SUPABASE_URL', target: ['production', 'preview', 'development'] },
    { key: 'NEXT_PUBLIC_SUPABASE_ANON_KEY', target: ['production', 'preview', 'development'] },
    { key: 'SUPABASE_SERVICE_ROLE_KEY', target: ['production', 'preview'] },
    { key: 'SUPABASE_DB_PASSWORD', target: ['production'] },
    { key: 'ANTHROPIC_API_KEY', target: ['production', 'preview'] },
    { key: 'UPSTASH_REDIS_REST_URL', target: ['production', 'preview'] },
    { key: 'UPSTASH_REDIS_REST_TOKEN', target: ['production', 'preview'] },
    { key: 'ENCRYPTION_KEY', target: ['production'] },
    { key: 'JWT_SECRET', target: ['production'] },
  ];

  for (const envVar of envVars) {
    const value = process.env[envVar.key];
    if (!value) {
      console.log(`  [SKIP] ${envVar.key}: 값이 설정되지 않음`);
      continue;
    }

    for (const target of envVar.target) {
      try {
        await execa('vercel', [
          'env',
          'add',
          envVar.key,
          target,
          '--force',
        ], {
          input: value,
          stdio: ['pipe', 'inherit', 'inherit'],
        });
        console.log(`  [OK] ${envVar.key} -> ${target}`);
      } catch (error) {
        console.error(`  [ERROR] ${envVar.key} -> ${target}:`, error);
      }
    }
  }
}

async function configureDomains(): Promise<void> {
  console.log('\n도메인 설정...');

  const addDomain = await question('커스텀 도메인을 추가하시겠습니까? (y/n): ');

  if (addDomain.toLowerCase() === 'y') {
    const domain = await question('도메인을 입력하세요: ');

    try {
      await execa('vercel', ['domains', 'add', domain], { stdio: 'inherit' });
      console.log(`  [OK] ${domain} 추가됨`);
    } catch (error) {
      console.error(`  [ERROR] 도메인 추가 실패:`, error);
    }
  }
}

async function deployPreview(): Promise<void> {
  console.log('\nPreview 배포 중...');

  try {
    const result = await execa('vercel', ['deploy'], { stdio: 'pipe' });
    console.log(`  [OK] Preview URL: ${result.stdout}`);
  } catch (error) {
    console.error('  [ERROR] 배포 실패:', error);
  }
}

async function main(): Promise<void> {
  console.log('='.repeat(50));
  console.log('  Magnetic Sales WebApp - Vercel Setup');
  console.log('='.repeat(50));

  // 1. Vercel CLI 확인
  const hasVercel = await checkVercelCLI();
  if (!hasVercel) {
    console.error('Vercel CLI가 설치되어 있지 않습니다.');
    console.log('설치: npm i -g vercel');
    process.exit(1);
  }

  // 2. 로그인
  await loginToVercel();

  // 3. 프로젝트 연결
  const project = await linkProject();
  console.log(`\n프로젝트 연결됨: ${project.name} (${project.id})`);

  // 4. 환경 변수 설정
  await setEnvironmentVariables(project);

  // 5. 도메인 설정
  await configureDomains();

  // 6. Preview 배포
  const deploy = await question('\nPreview 배포를 진행하시겠습니까? (y/n): ');
  if (deploy.toLowerCase() === 'y') {
    await deployPreview();
  }

  console.log('\n설정 완료!');
  rl.close();
}

main().catch(console.error);
```

---

## 3. 환경 변수 관리

### 3.1 환경 변수 스키마 및 검증

```typescript
// /src/config/env.ts
/**
 * 환경 변수 스키마 정의 및 검증
 *
 * @description 타입 안전한 환경 변수 접근
 * @dependencies zod
 */

import { z } from 'zod';

// 서버 환경 변수 스키마
const serverEnvSchema = z.object({
  // Node
  NODE_ENV: z.enum(['development', 'test', 'production']).default('development'),

  // Vercel
  VERCEL_ENV: z.enum(['development', 'preview', 'production']).optional(),
  VERCEL_URL: z.string().optional(),
  VERCEL_GIT_COMMIT_SHA: z.string().optional(),
  VERCEL_GIT_COMMIT_REF: z.string().optional(),

  // Supabase
  SUPABASE_SERVICE_ROLE_KEY: z.string().min(1, 'SUPABASE_SERVICE_ROLE_KEY is required'),
  SUPABASE_DB_HOST: z.string().optional(),
  SUPABASE_DB_PASSWORD: z.string().optional(),

  // Anthropic
  ANTHROPIC_API_KEY: z.string().startsWith('sk-ant-', 'Invalid Anthropic API key format'),

  // Redis (Upstash)
  UPSTASH_REDIS_REST_URL: z.string().url().optional(),
  UPSTASH_REDIS_REST_TOKEN: z.string().optional(),

  // Security
  ENCRYPTION_KEY: z.string().length(64, 'ENCRYPTION_KEY must be 64 characters (32 bytes hex)').optional(),
  JWT_SECRET: z.string().min(32, 'JWT_SECRET must be at least 32 characters').optional(),

  // Monitoring
  SENTRY_DSN: z.string().url().optional(),
  SENTRY_AUTH_TOKEN: z.string().optional(),

  // Cron Secret
  CRON_SECRET: z.string().min(32).optional(),
});

// 클라이언트 환경 변수 스키마
const clientEnvSchema = z.object({
  NEXT_PUBLIC_SUPABASE_URL: z.string().url('Invalid Supabase URL'),
  NEXT_PUBLIC_SUPABASE_ANON_KEY: z.string().min(1, 'NEXT_PUBLIC_SUPABASE_ANON_KEY is required'),
  NEXT_PUBLIC_APP_URL: z.string().url().optional(),
  NEXT_PUBLIC_SENTRY_DSN: z.string().url().optional(),
  NEXT_PUBLIC_GA_MEASUREMENT_ID: z.string().startsWith('G-').optional(),
});

// 타입 추론
export type ServerEnv = z.infer<typeof serverEnvSchema>;
export type ClientEnv = z.infer<typeof clientEnvSchema>;

// 서버 환경 변수 검증 및 캐싱
let _serverEnv: ServerEnv | null = null;

export function getServerEnv(): ServerEnv {
  if (_serverEnv) return _serverEnv;

  const parsed = serverEnvSchema.safeParse(process.env);

  if (!parsed.success) {
    console.error('Server environment validation failed:');
    console.error(parsed.error.format());

    // 프로덕션에서는 빌드 실패
    if (process.env.NODE_ENV === 'production') {
      throw new Error('Invalid server environment variables');
    }

    // 개발 환경에서는 경고만 출력
    console.warn('Continuing with partial environment in development mode');
    _serverEnv = parsed.data as ServerEnv;
    return _serverEnv;
  }

  _serverEnv = parsed.data;
  return _serverEnv;
}

// 클라이언트 환경 변수 검증 및 캐싱
let _clientEnv: ClientEnv | null = null;

export function getClientEnv(): ClientEnv {
  if (_clientEnv) return _clientEnv;

  const parsed = clientEnvSchema.safeParse({
    NEXT_PUBLIC_SUPABASE_URL: process.env.NEXT_PUBLIC_SUPABASE_URL,
    NEXT_PUBLIC_SUPABASE_ANON_KEY: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
    NEXT_PUBLIC_APP_URL: process.env.NEXT_PUBLIC_APP_URL,
    NEXT_PUBLIC_SENTRY_DSN: process.env.NEXT_PUBLIC_SENTRY_DSN,
    NEXT_PUBLIC_GA_MEASUREMENT_ID: process.env.NEXT_PUBLIC_GA_MEASUREMENT_ID,
  });

  if (!parsed.success) {
    console.error('Client environment validation failed:');
    console.error(parsed.error.format());
    throw new Error('Invalid client environment variables');
  }

  _clientEnv = parsed.data;
  return _clientEnv;
}

// 환경 변수 헬퍼
export const env = {
  get server() {
    return getServerEnv();
  },
  get client() {
    return getClientEnv();
  },
  get isProduction() {
    return process.env.NODE_ENV === 'production';
  },
  get isDevelopment() {
    return process.env.NODE_ENV === 'development';
  },
  get isTest() {
    return process.env.NODE_ENV === 'test';
  },
};
```

### 3.2 환경별 .env 템플릿

```bash
# /.env.example
# ==============================================================================
# Magnetic Sales WebApp - Environment Variables Template
# ==============================================================================
# 이 파일을 복사하여 .env.local을 생성하세요
# cp .env.example .env.local
# ==============================================================================

# ------------------------------------------------------------------------------
# Node Environment
# ------------------------------------------------------------------------------
NODE_ENV=development

# ------------------------------------------------------------------------------
# Supabase Configuration
# https://supabase.com/dashboard/project/YOUR_PROJECT/settings/api
# ------------------------------------------------------------------------------
NEXT_PUBLIC_SUPABASE_URL=https://YOUR_PROJECT_REF.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

# Service Role Key (서버 전용 - 절대 클라이언트에 노출하지 마세요)
SUPABASE_SERVICE_ROLE_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

# Database Connection (Direct connection for migrations)
SUPABASE_DB_HOST=db.YOUR_PROJECT_REF.supabase.co
SUPABASE_DB_PORT=5432
SUPABASE_DB_USER=postgres
SUPABASE_DB_PASSWORD=your-database-password

# ------------------------------------------------------------------------------
# Anthropic Claude API
# https://console.anthropic.com/settings/keys
# ------------------------------------------------------------------------------
ANTHROPIC_API_KEY=sk-ant-api03-...

# ------------------------------------------------------------------------------
# Redis (Upstash) - Rate Limiting & Caching
# https://console.upstash.com/redis
# ------------------------------------------------------------------------------
UPSTASH_REDIS_REST_URL=https://YOUR_REDIS.upstash.io
UPSTASH_REDIS_REST_TOKEN=AX...

# ------------------------------------------------------------------------------
# Security Keys
# Generate: openssl rand -hex 32
# ------------------------------------------------------------------------------
ENCRYPTION_KEY=your-64-character-hex-string-here-for-aes-256-encryption
JWT_SECRET=your-secure-jwt-secret-at-least-32-characters-long

# ------------------------------------------------------------------------------
# Application URLs
# ------------------------------------------------------------------------------
NEXT_PUBLIC_APP_URL=http://localhost:3000

# ------------------------------------------------------------------------------
# Monitoring & Analytics (Optional)
# ------------------------------------------------------------------------------
# Sentry
SENTRY_DSN=https://xxx@xxx.ingest.sentry.io/xxx
SENTRY_AUTH_TOKEN=sntrys_...
NEXT_PUBLIC_SENTRY_DSN=https://xxx@xxx.ingest.sentry.io/xxx

# Google Analytics
NEXT_PUBLIC_GA_MEASUREMENT_ID=G-XXXXXXXXXX

# ------------------------------------------------------------------------------
# Cron Jobs
# ------------------------------------------------------------------------------
CRON_SECRET=your-cron-secret-at-least-32-characters
```

### 3.3 환경 변수 동기화 스크립트

```typescript
// /scripts/sync-env.ts
/**
 * 환경 변수 동기화 스크립트
 *
 * @description .env 파일과 Vercel 환경 변수 동기화
 * @dependencies execa, dotenv, chalk
 * @usage npx tsx scripts/sync-env.ts [push|pull]
 */

import { execa } from 'execa';
import * as dotenv from 'dotenv';
import * as fs from 'fs';
import * as path from 'path';
import chalk from 'chalk';

type SyncMode = 'push' | 'pull';
type Environment = 'production' | 'preview' | 'development';

interface EnvVariable {
  key: string;
  value: string;
  target: Environment[];
}

// 동기화할 환경 변수 목록 (민감하지 않은 것만)
const SYNCABLE_VARS = [
  'NEXT_PUBLIC_SUPABASE_URL',
  'NEXT_PUBLIC_SUPABASE_ANON_KEY',
  'NEXT_PUBLIC_APP_URL',
  'NEXT_PUBLIC_GA_MEASUREMENT_ID',
];

// 민감한 환경 변수 (push 시 확인 필요)
const SENSITIVE_VARS = [
  'SUPABASE_SERVICE_ROLE_KEY',
  'SUPABASE_DB_PASSWORD',
  'ANTHROPIC_API_KEY',
  'UPSTASH_REDIS_REST_TOKEN',
  'ENCRYPTION_KEY',
  'JWT_SECRET',
  'SENTRY_AUTH_TOKEN',
  'CRON_SECRET',
];

async function pullEnv(environment: Environment): Promise<void> {
  console.log(chalk.blue(`\nPulling environment variables from Vercel (${environment})...`));

  try {
    const result = await execa('vercel', ['env', 'pull', `.env.${environment}`, '--environment', environment], {
      stdio: 'pipe',
    });

    console.log(chalk.green(`Successfully pulled to .env.${environment}`));
    console.log(result.stdout);
  } catch (error) {
    console.error(chalk.red('Failed to pull environment variables:'), error);
    throw error;
  }
}

async function pushEnv(environment: Environment): Promise<void> {
  console.log(chalk.blue(`\nPushing environment variables to Vercel (${environment})...`));

  // .env.local 파일 읽기
  const envPath = path.join(process.cwd(), '.env.local');
  if (!fs.existsSync(envPath)) {
    throw new Error('.env.local file not found');
  }

  const envConfig = dotenv.parse(fs.readFileSync(envPath));
  const varsToSync: EnvVariable[] = [];

  // 동기화할 변수 필터링
  for (const key of SYNCABLE_VARS) {
    if (envConfig[key]) {
      varsToSync.push({
        key,
        value: envConfig[key],
        target: [environment],
      });
    }
  }

  console.log(chalk.yellow(`\nVariables to sync (${varsToSync.length}):`));
  varsToSync.forEach((v) => console.log(`  - ${v.key}`));

  // 민감한 변수 확인
  const sensitiveToPush: string[] = [];
  for (const key of SENSITIVE_VARS) {
    if (envConfig[key]) {
      sensitiveToPush.push(key);
    }
  }

  if (sensitiveToPush.length > 0) {
    console.log(chalk.red(`\nWARNING: Sensitive variables found (not syncing):`));
    sensitiveToPush.forEach((k) => console.log(`  - ${k}`));
    console.log(chalk.yellow('Use Vercel dashboard to set sensitive variables manually.'));
  }

  // 변수 push
  for (const { key, value, target } of varsToSync) {
    try {
      await execa('vercel', ['env', 'add', key, ...target, '--force'], {
        input: value,
        stdio: ['pipe', 'inherit', 'inherit'],
      });
      console.log(chalk.green(`  [OK] ${key}`));
    } catch (error) {
      console.error(chalk.red(`  [FAIL] ${key}:`), error);
    }
  }
}

async function validateEnv(): Promise<void> {
  console.log(chalk.blue('\nValidating environment variables...'));

  const envPath = path.join(process.cwd(), '.env.local');
  if (!fs.existsSync(envPath)) {
    console.log(chalk.yellow('No .env.local found, checking .env.example...'));
    return;
  }

  const envConfig = dotenv.parse(fs.readFileSync(envPath));
  const examplePath = path.join(process.cwd(), '.env.example');
  const exampleConfig = dotenv.parse(fs.readFileSync(examplePath));

  const missing: string[] = [];
  const extra: string[] = [];

  // 누락된 변수 확인
  for (const key of Object.keys(exampleConfig)) {
    if (!envConfig[key] && !key.startsWith('#')) {
      missing.push(key);
    }
  }

  // 추가된 변수 확인
  for (const key of Object.keys(envConfig)) {
    if (!exampleConfig[key]) {
      extra.push(key);
    }
  }

  if (missing.length > 0) {
    console.log(chalk.red('\nMissing variables:'));
    missing.forEach((k) => console.log(`  - ${k}`));
  }

  if (extra.length > 0) {
    console.log(chalk.yellow('\nExtra variables (not in .env.example):'));
    extra.forEach((k) => console.log(`  - ${k}`));
  }

  if (missing.length === 0 && extra.length === 0) {
    console.log(chalk.green('All environment variables are properly configured!'));
  }
}

async function main(): Promise<void> {
  const args = process.argv.slice(2);
  const mode = args[0] as SyncMode | undefined;
  const environment = (args[1] as Environment) || 'production';

  console.log(chalk.bold('='.repeat(50)));
  console.log(chalk.bold('  Environment Variable Sync Tool'));
  console.log(chalk.bold('='.repeat(50)));

  switch (mode) {
    case 'push':
      await pushEnv(environment);
      break;
    case 'pull':
      await pullEnv(environment);
      break;
    default:
      await validateEnv();
      console.log(chalk.gray('\nUsage:'));
      console.log(chalk.gray('  npx tsx scripts/sync-env.ts push [production|preview|development]'));
      console.log(chalk.gray('  npx tsx scripts/sync-env.ts pull [production|preview|development]'));
  }
}

main().catch(console.error);
```

---

## 4. CI/CD 파이프라인

### 4.1 GitHub Actions 워크플로우

```yaml
# /.github/workflows/deploy.yml
name: Deploy Pipeline

on:
  push:
    branches: [main, staging]
  pull_request:
    branches: [main, staging]

env:
  VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
  VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}

jobs:
  # ==========================================================================
  # 코드 품질 검사
  # ==========================================================================
  quality:
    name: Code Quality
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 9

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Type check
        run: pnpm type-check

      - name: Lint
        run: pnpm lint

      - name: Format check
        run: pnpm format:check

  # ==========================================================================
  # 단위 테스트 및 통합 테스트
  # ==========================================================================
  test:
    name: Test Suite
    runs-on: ubuntu-latest
    needs: quality
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 9

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Run unit tests
        run: pnpm test:unit
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db

      - name: Run integration tests
        run: pnpm test:integration
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY_TEST }}

      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: ./coverage/lcov.info
          fail_ci_if_error: false

  # ==========================================================================
  # 보안 검사
  # ==========================================================================
  security:
    name: Security Audit
    runs-on: ubuntu-latest
    needs: quality
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 9

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Run security audit
        run: pnpm audit --audit-level=high

      - name: Run Snyk test
        uses: snyk/actions/node@master
        continue-on-error: true
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}

      - name: Check for secrets
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: ${{ github.event.repository.default_branch }}
          head: HEAD

  # ==========================================================================
  # 빌드 테스트
  # ==========================================================================
  build:
    name: Build Test
    runs-on: ubuntu-latest
    needs: [test, security]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 9

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build
        run: pnpm build
        env:
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}

      - name: Analyze bundle
        run: pnpm build:analyze || true
        env:
          ANALYZE: true

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-output
          path: .next/
          retention-days: 7

  # ==========================================================================
  # Preview 배포 (PR)
  # ==========================================================================
  deploy-preview:
    name: Deploy Preview
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'pull_request'
    environment:
      name: preview
      url: ${{ steps.deploy.outputs.url }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 9

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Install Vercel CLI
        run: pnpm add -g vercel@latest

      - name: Pull Vercel Environment
        run: vercel pull --yes --environment=preview --token=${{ secrets.VERCEL_TOKEN }}

      - name: Build Project
        run: vercel build --token=${{ secrets.VERCEL_TOKEN }}

      - name: Deploy Preview
        id: deploy
        run: |
          url=$(vercel deploy --prebuilt --token=${{ secrets.VERCEL_TOKEN }})
          echo "url=$url" >> $GITHUB_OUTPUT

      - name: Comment PR with Preview URL
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## Preview Deployment\n\nDeployed to: ${{ steps.deploy.outputs.url }}\n\nCommit: ${context.sha.substring(0, 7)}`
            })

  # ==========================================================================
  # Staging 배포
  # ==========================================================================
  deploy-staging:
    name: Deploy Staging
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/staging' && github.event_name == 'push'
    environment:
      name: staging
      url: https://staging.magnetic-sales.app
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 9

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Install Vercel CLI
        run: pnpm add -g vercel@latest

      - name: Pull Vercel Environment
        run: vercel pull --yes --environment=preview --token=${{ secrets.VERCEL_TOKEN }}

      - name: Build Project
        run: vercel build --token=${{ secrets.VERCEL_TOKEN }}

      - name: Deploy to Staging
        run: vercel deploy --prebuilt --token=${{ secrets.VERCEL_TOKEN }}

      - name: Assign Staging Alias
        run: vercel alias set --token=${{ secrets.VERCEL_TOKEN }} staging.magnetic-sales.app

  # ==========================================================================
  # Production 배포
  # ==========================================================================
  deploy-production:
    name: Deploy Production
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment:
      name: production
      url: https://magnetic-sales.app
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 9

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Install Vercel CLI
        run: pnpm add -g vercel@latest

      - name: Pull Vercel Environment
        run: vercel pull --yes --environment=production --token=${{ secrets.VERCEL_TOKEN }}

      - name: Build Project
        run: vercel build --prod --token=${{ secrets.VERCEL_TOKEN }}

      - name: Run DB Migrations
        run: pnpm db:migrate
        env:
          SUPABASE_DB_HOST: ${{ secrets.SUPABASE_DB_HOST }}
          SUPABASE_DB_PASSWORD: ${{ secrets.SUPABASE_DB_PASSWORD }}

      - name: Deploy to Production
        run: vercel deploy --prebuilt --prod --token=${{ secrets.VERCEL_TOKEN }}

      - name: Notify Slack
        if: success()
        uses: slackapi/slack-github-action@v1.24.0
        with:
          payload: |
            {
              "text": "Production deployment successful!",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Production Deployment*\n\nCommit: `${{ github.sha }}`\nAuthor: ${{ github.actor }}\nURL: https://magnetic-sales.app"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # ==========================================================================
  # E2E 테스트 (배포 후)
  # ==========================================================================
  e2e-test:
    name: E2E Tests
    runs-on: ubuntu-latest
    needs: [deploy-staging]
    if: github.ref == 'refs/heads/staging'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 9

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Install Playwright browsers
        run: pnpm exec playwright install --with-deps chromium

      - name: Run E2E tests
        run: pnpm test:e2e
        env:
          BASE_URL: https://staging.magnetic-sales.app
          TEST_USER_EMAIL: ${{ secrets.TEST_USER_EMAIL }}
          TEST_USER_PASSWORD: ${{ secrets.TEST_USER_PASSWORD }}

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: playwright-report
          path: playwright-report/
          retention-days: 30
```

### 4.2 DB 마이그레이션 워크플로우

```yaml
# /.github/workflows/db-migrate.yml
name: Database Migration

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - staging
          - production
      migration_name:
        description: 'Migration name (optional)'
        required: false
        type: string

jobs:
  migrate:
    name: Run Migration
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 9

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Create backup
        run: |
          echo "Creating database backup..."
          pnpm db:backup
        env:
          SUPABASE_DB_HOST: ${{ secrets.SUPABASE_DB_HOST }}
          SUPABASE_DB_PASSWORD: ${{ secrets.SUPABASE_DB_PASSWORD }}

      - name: Run migrations
        run: |
          echo "Running migrations..."
          pnpm db:migrate
        env:
          SUPABASE_DB_HOST: ${{ secrets.SUPABASE_DB_HOST }}
          SUPABASE_DB_PASSWORD: ${{ secrets.SUPABASE_DB_PASSWORD }}

      - name: Verify migration
        run: |
          echo "Verifying migration..."
          pnpm db:verify
        env:
          SUPABASE_DB_HOST: ${{ secrets.SUPABASE_DB_HOST }}
          SUPABASE_DB_PASSWORD: ${{ secrets.SUPABASE_DB_PASSWORD }}

      - name: Notify on failure
        if: failure()
        uses: slackapi/slack-github-action@v1.24.0
        with:
          payload: |
            {
              "text": "Database migration failed!",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Migration Failed*\n\nEnvironment: ${{ github.event.inputs.environment }}\nTriggered by: ${{ github.actor }}"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
```

---

## 5. 배포 전략

### 5.1 배포 매니저

```typescript
// /src/lib/deployment/deployment-manager.ts
/**
 * 배포 매니저
 *
 * @description 배포 상태 관리 및 헬스체크
 * @dependencies @vercel/kv (optional)
 */

import { getServerEnv } from '@/config/env';

export interface DeploymentInfo {
  version: string;
  commitSha: string;
  commitRef: string;
  deployedAt: string;
  environment: string;
}

export interface HealthStatus {
  status: 'healthy' | 'degraded' | 'unhealthy';
  timestamp: string;
  checks: {
    database: HealthCheck;
    redis: HealthCheck;
    anthropic: HealthCheck;
  };
  deployment: DeploymentInfo;
}

interface HealthCheck {
  status: 'ok' | 'error';
  latency?: number;
  error?: string;
}

export function getDeploymentInfo(): DeploymentInfo {
  return {
    version: process.env.npm_package_version || '0.0.0',
    commitSha: process.env.VERCEL_GIT_COMMIT_SHA || 'unknown',
    commitRef: process.env.VERCEL_GIT_COMMIT_REF || 'unknown',
    deployedAt: process.env.VERCEL_GIT_COMMIT_MESSAGE || new Date().toISOString(),
    environment: process.env.VERCEL_ENV || 'development',
  };
}

async function checkDatabase(): Promise<HealthCheck> {
  const start = Date.now();

  try {
    // Supabase 연결 확인
    const { createClient } = await import('@supabase/supabase-js');
    const supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      getServerEnv().SUPABASE_SERVICE_ROLE_KEY
    );

    const { error } = await supabase.from('users').select('count').limit(1);

    if (error) throw error;

    return {
      status: 'ok',
      latency: Date.now() - start,
    };
  } catch (error) {
    return {
      status: 'error',
      latency: Date.now() - start,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

async function checkRedis(): Promise<HealthCheck> {
  const start = Date.now();
  const env = getServerEnv();

  if (!env.UPSTASH_REDIS_REST_URL) {
    return { status: 'ok', latency: 0 }; // Redis 미설정 시 스킵
  }

  try {
    const response = await fetch(`${env.UPSTASH_REDIS_REST_URL}/ping`, {
      headers: {
        Authorization: `Bearer ${env.UPSTASH_REDIS_REST_TOKEN}`,
      },
    });

    if (!response.ok) throw new Error('Redis ping failed');

    return {
      status: 'ok',
      latency: Date.now() - start,
    };
  } catch (error) {
    return {
      status: 'error',
      latency: Date.now() - start,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

async function checkAnthropic(): Promise<HealthCheck> {
  const start = Date.now();

  try {
    // API 키 유효성만 확인 (실제 요청 없이)
    const apiKey = getServerEnv().ANTHROPIC_API_KEY;

    if (!apiKey || !apiKey.startsWith('sk-ant-')) {
      throw new Error('Invalid API key format');
    }

    return {
      status: 'ok',
      latency: Date.now() - start,
    };
  } catch (error) {
    return {
      status: 'error',
      latency: Date.now() - start,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

export async function getHealthStatus(): Promise<HealthStatus> {
  const [database, redis, anthropic] = await Promise.all([
    checkDatabase(),
    checkRedis(),
    checkAnthropic(),
  ]);

  const checks = { database, redis, anthropic };
  const allOk = Object.values(checks).every((c) => c.status === 'ok');
  const anyError = Object.values(checks).some((c) => c.status === 'error');

  return {
    status: allOk ? 'healthy' : anyError ? 'unhealthy' : 'degraded',
    timestamp: new Date().toISOString(),
    checks,
    deployment: getDeploymentInfo(),
  };
}
```

### 5.2 Health Check API

```typescript
// /src/app/api/health/route.ts
/**
 * Health Check API
 *
 * @description 서비스 상태 확인 엔드포인트
 * @dependencies deployment-manager
 */

import { NextResponse } from 'next/server';
import { getHealthStatus, type HealthStatus } from '@/lib/deployment/deployment-manager';

export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

export async function GET(): Promise<NextResponse<HealthStatus>> {
  try {
    const health = await getHealthStatus();

    const statusCode = health.status === 'healthy' ? 200 :
                       health.status === 'degraded' ? 200 : 503;

    return NextResponse.json(health, { status: statusCode });
  } catch (error) {
    return NextResponse.json(
      {
        status: 'unhealthy',
        timestamp: new Date().toISOString(),
        checks: {
          database: { status: 'error', error: 'Check failed' },
          redis: { status: 'error', error: 'Check failed' },
          anthropic: { status: 'error', error: 'Check failed' },
        },
        deployment: {
          version: 'unknown',
          commitSha: 'unknown',
          commitRef: 'unknown',
          deployedAt: 'unknown',
          environment: 'unknown',
        },
      } satisfies HealthStatus,
      { status: 503 }
    );
  }
}
```

### 5.3 Feature Flags 시스템

```typescript
// /src/lib/deployment/feature-flags.ts
/**
 * Feature Flags 시스템
 *
 * @description 기능 플래그 관리
 * @dependencies 없음 (Redis 연동 가능)
 */

import { getEnvironment } from '@/config/deployment';

export interface FeatureFlag {
  key: string;
  enabled: boolean;
  description: string;
  environments: ('development' | 'preview' | 'staging' | 'production')[];
  percentage?: number; // 점진적 롤아웃용
  userIds?: string[]; // 특정 사용자만
}

// 정적 Feature Flags 정의
const FEATURE_FLAGS: FeatureFlag[] = [
  {
    key: 'ai_streaming',
    enabled: true,
    description: 'AI 응답 스트리밍 활성화',
    environments: ['development', 'preview', 'staging', 'production'],
  },
  {
    key: 'advanced_editor',
    enabled: true,
    description: 'TipTap 고급 에디터 기능',
    environments: ['development', 'preview', 'staging', 'production'],
  },
  {
    key: 'export_pdf',
    enabled: true,
    description: 'PDF 내보내기 기능',
    environments: ['development', 'preview', 'staging', 'production'],
  },
  {
    key: 'collaboration',
    enabled: false,
    description: '실시간 협업 기능 (베타)',
    environments: ['development', 'staging'],
    percentage: 10,
  },
  {
    key: 'ai_suggestions',
    enabled: false,
    description: 'AI 자동 제안 기능',
    environments: ['development'],
  },
  {
    key: 'new_dashboard',
    enabled: false,
    description: '새로운 대시보드 UI',
    environments: ['development', 'preview'],
    percentage: 50,
  },
];

export function isFeatureEnabled(
  key: string,
  options?: {
    userId?: string;
    sessionId?: string;
  }
): boolean {
  const flag = FEATURE_FLAGS.find((f) => f.key === key);

  if (!flag) {
    console.warn(`Unknown feature flag: ${key}`);
    return false;
  }

  // 기본적으로 비활성화
  if (!flag.enabled) return false;

  // 환경 체크
  const currentEnv = getEnvironment();
  if (!flag.environments.includes(currentEnv)) return false;

  // 특정 사용자만
  if (flag.userIds && options?.userId) {
    return flag.userIds.includes(options.userId);
  }

  // 퍼센트 기반 롤아웃
  if (flag.percentage !== undefined && options?.sessionId) {
    const hash = simpleHash(options.sessionId + key);
    return (hash % 100) < flag.percentage;
  }

  return true;
}

export function getAllFeatureFlags(): FeatureFlag[] {
  const currentEnv = getEnvironment();
  return FEATURE_FLAGS.filter((f) => f.environments.includes(currentEnv));
}

export function getFeatureFlag(key: string): FeatureFlag | undefined {
  return FEATURE_FLAGS.find((f) => f.key === key);
}

// 간단한 해시 함수 (퍼센트 롤아웃용)
function simpleHash(str: string): number {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash;
  }
  return Math.abs(hash);
}

// React Hook
export function useFeatureFlag(
  key: string,
  options?: { userId?: string; sessionId?: string }
): boolean {
  // 서버 컴포넌트에서는 직접 호출
  if (typeof window === 'undefined') {
    return isFeatureEnabled(key, options);
  }

  // 클라이언트에서는 세션 ID 사용
  const sessionId = options?.sessionId ||
    (typeof sessionStorage !== 'undefined'
      ? sessionStorage.getItem('session_id') || Math.random().toString(36)
      : Math.random().toString(36));

  return isFeatureEnabled(key, { ...options, sessionId });
}
```

---

## 6. 데이터베이스 마이그레이션

### 6.1 마이그레이션 러너

```typescript
// /scripts/db/migrate.ts
/**
 * 데이터베이스 마이그레이션 러너
 *
 * @description Supabase 마이그레이션 실행
 * @dependencies pg, dotenv, chalk
 * @usage npx tsx scripts/db/migrate.ts [up|down|status]
 */

import { Pool } from 'pg';
import * as fs from 'fs';
import * as path from 'path';
import chalk from 'chalk';
import * as dotenv from 'dotenv';

dotenv.config({ path: '.env.local' });

interface Migration {
  id: number;
  name: string;
  applied_at: Date | null;
  checksum: string;
}

const MIGRATIONS_DIR = path.join(process.cwd(), 'supabase/migrations');
const MIGRATIONS_TABLE = '_migrations';

async function createPool(): Promise<Pool> {
  return new Pool({
    host: process.env.SUPABASE_DB_HOST,
    port: parseInt(process.env.SUPABASE_DB_PORT || '5432'),
    user: process.env.SUPABASE_DB_USER || 'postgres',
    password: process.env.SUPABASE_DB_PASSWORD,
    database: 'postgres',
    ssl: { rejectUnauthorized: false },
  });
}

async function ensureMigrationsTable(pool: Pool): Promise<void> {
  await pool.query(`
    CREATE TABLE IF NOT EXISTS ${MIGRATIONS_TABLE} (
      id SERIAL PRIMARY KEY,
      name VARCHAR(255) NOT NULL UNIQUE,
      applied_at TIMESTAMPTZ DEFAULT NOW(),
      checksum VARCHAR(64) NOT NULL
    )
  `);
}

function getMigrationFiles(): string[] {
  if (!fs.existsSync(MIGRATIONS_DIR)) {
    console.log(chalk.yellow('Migrations directory not found'));
    return [];
  }

  return fs.readdirSync(MIGRATIONS_DIR)
    .filter((f) => f.endsWith('.sql'))
    .sort();
}

function calculateChecksum(content: string): string {
  const crypto = require('crypto');
  return crypto.createHash('sha256').update(content).digest('hex').slice(0, 16);
}

async function getAppliedMigrations(pool: Pool): Promise<Map<string, Migration>> {
  const result = await pool.query<Migration>(
    `SELECT * FROM ${MIGRATIONS_TABLE} ORDER BY id`
  );

  return new Map(result.rows.map((m) => [m.name, m]));
}

async function runMigration(
  pool: Pool,
  filename: string,
  direction: 'up' | 'down'
): Promise<void> {
  const filePath = path.join(MIGRATIONS_DIR, filename);
  const content = fs.readFileSync(filePath, 'utf-8');

  // up/down 섹션 파싱
  const upMatch = content.match(/-- migrate:up\n([\s\S]*?)(?=-- migrate:down|$)/);
  const downMatch = content.match(/-- migrate:down\n([\s\S]*?)$/);

  const sql = direction === 'up' ? upMatch?.[1] : downMatch?.[1];

  if (!sql?.trim()) {
    console.log(chalk.yellow(`  No ${direction} migration found in ${filename}`));
    return;
  }

  const client = await pool.connect();

  try {
    await client.query('BEGIN');

    // 마이그레이션 실행
    await client.query(sql);

    // 마이그레이션 기록
    if (direction === 'up') {
      const checksum = calculateChecksum(content);
      await client.query(
        `INSERT INTO ${MIGRATIONS_TABLE} (name, checksum) VALUES ($1, $2)`,
        [filename, checksum]
      );
    } else {
      await client.query(
        `DELETE FROM ${MIGRATIONS_TABLE} WHERE name = $1`,
        [filename]
      );
    }

    await client.query('COMMIT');
    console.log(chalk.green(`  [OK] ${filename}`));
  } catch (error) {
    await client.query('ROLLBACK');
    console.error(chalk.red(`  [FAIL] ${filename}:`), error);
    throw error;
  } finally {
    client.release();
  }
}

async function migrateUp(pool: Pool): Promise<void> {
  console.log(chalk.blue('\nRunning migrations UP...\n'));

  const files = getMigrationFiles();
  const applied = await getAppliedMigrations(pool);

  const pending = files.filter((f) => !applied.has(f));

  if (pending.length === 0) {
    console.log(chalk.green('No pending migrations'));
    return;
  }

  console.log(chalk.yellow(`Pending migrations: ${pending.length}\n`));

  for (const file of pending) {
    await runMigration(pool, file, 'up');
  }

  console.log(chalk.green(`\nApplied ${pending.length} migrations`));
}

async function migrateDown(pool: Pool, steps: number = 1): Promise<void> {
  console.log(chalk.blue(`\nRolling back ${steps} migration(s)...\n`));

  const applied = await getAppliedMigrations(pool);
  const appliedList = Array.from(applied.keys()).reverse();

  const toRollback = appliedList.slice(0, steps);

  if (toRollback.length === 0) {
    console.log(chalk.yellow('No migrations to rollback'));
    return;
  }

  for (const file of toRollback) {
    await runMigration(pool, file, 'down');
  }

  console.log(chalk.green(`\nRolled back ${toRollback.length} migrations`));
}

async function showStatus(pool: Pool): Promise<void> {
  console.log(chalk.blue('\nMigration Status\n'));

  const files = getMigrationFiles();
  const applied = await getAppliedMigrations(pool);

  console.log(chalk.gray('-'.repeat(80)));
  console.log(
    chalk.gray('Status'.padEnd(10)),
    chalk.gray('Migration'.padEnd(50)),
    chalk.gray('Applied At')
  );
  console.log(chalk.gray('-'.repeat(80)));

  for (const file of files) {
    const migration = applied.get(file);
    const status = migration ? chalk.green('[OK]') : chalk.yellow('[PENDING]');
    const appliedAt = migration?.applied_at
      ? new Date(migration.applied_at).toISOString()
      : '-';

    console.log(
      status.padEnd(10),
      file.padEnd(50),
      appliedAt
    );
  }

  console.log(chalk.gray('-'.repeat(80)));
  console.log(`\nTotal: ${files.length} | Applied: ${applied.size} | Pending: ${files.length - applied.size}`);
}

async function main(): Promise<void> {
  const command = process.argv[2] || 'status';
  const pool = await createPool();

  try {
    await ensureMigrationsTable(pool);

    switch (command) {
      case 'up':
        await migrateUp(pool);
        break;
      case 'down':
        const steps = parseInt(process.argv[3] || '1');
        await migrateDown(pool, steps);
        break;
      case 'status':
        await showStatus(pool);
        break;
      default:
        console.log('Usage: npx tsx scripts/db/migrate.ts [up|down|status]');
    }
  } finally {
    await pool.end();
  }
}

main().catch(console.error);
```

### 6.2 시드 데이터 스크립트

```typescript
// /scripts/db/seed.ts
/**
 * 데이터베이스 시드 스크립트
 *
 * @description 초기 데이터 삽입
 * @dependencies pg, dotenv, @faker-js/faker
 * @usage npx tsx scripts/db/seed.ts [--reset]
 */

import { Pool } from 'pg';
import { faker } from '@faker-js/faker/locale/ko';
import * as dotenv from 'dotenv';
import chalk from 'chalk';

dotenv.config({ path: '.env.local' });

const SEED_USER_COUNT = 5;
const SEED_PROJECTS_PER_USER = 3;
const SEED_QUESTIONS_PER_PROJECT = 5;

async function createPool(): Promise<Pool> {
  return new Pool({
    host: process.env.SUPABASE_DB_HOST,
    port: parseInt(process.env.SUPABASE_DB_PORT || '5432'),
    user: process.env.SUPABASE_DB_USER || 'postgres',
    password: process.env.SUPABASE_DB_PASSWORD,
    database: 'postgres',
    ssl: { rejectUnauthorized: false },
  });
}

async function clearData(pool: Pool): Promise<void> {
  console.log(chalk.yellow('\nClearing existing data...'));

  await pool.query('DELETE FROM question_responses');
  await pool.query('DELETE FROM questions');
  await pool.query('DELETE FROM projects');
  await pool.query('DELETE FROM users WHERE email LIKE $1', ['%seed.test']);

  console.log(chalk.green('  Data cleared'));
}

async function seedUsers(pool: Pool): Promise<string[]> {
  console.log(chalk.blue('\nSeeding users...'));

  const userIds: string[] = [];

  for (let i = 0; i < SEED_USER_COUNT; i++) {
    const result = await pool.query(
      `INSERT INTO users (email, name, avatar_url)
       VALUES ($1, $2, $3)
       RETURNING id`,
      [
        `user${i + 1}@seed.test`,
        faker.person.fullName(),
        faker.image.avatar(),
      ]
    );

    userIds.push(result.rows[0].id);
    console.log(chalk.green(`  [OK] User ${i + 1}`));
  }

  return userIds;
}

async function seedProjects(pool: Pool, userIds: string[]): Promise<string[]> {
  console.log(chalk.blue('\nSeeding projects...'));

  const projectIds: string[] = [];
  const businessTypes = ['B2B SaaS', 'E-commerce', 'Service', 'Education', 'Healthcare'];

  for (const userId of userIds) {
    for (let i = 0; i < SEED_PROJECTS_PER_USER; i++) {
      const result = await pool.query(
        `INSERT INTO projects (user_id, title, description, business_type, target_audience, status)
         VALUES ($1, $2, $3, $4, $5, $6)
         RETURNING id`,
        [
          userId,
          faker.company.catchPhrase(),
          faker.lorem.paragraph(),
          faker.helpers.arrayElement(businessTypes),
          faker.lorem.sentence(),
          faker.helpers.arrayElement(['draft', 'in_progress', 'completed']),
        ]
      );

      projectIds.push(result.rows[0].id);
    }
  }

  console.log(chalk.green(`  [OK] ${projectIds.length} projects`));
  return projectIds;
}

async function seedQuestions(pool: Pool, projectIds: string[]): Promise<void> {
  console.log(chalk.blue('\nSeeding questions...'));

  const questionCategories = ['target', 'problem', 'solution', 'benefit', 'cta'];
  let totalQuestions = 0;

  for (const projectId of projectIds) {
    for (let i = 0; i < SEED_QUESTIONS_PER_PROJECT; i++) {
      await pool.query(
        `INSERT INTO questions (project_id, category, question_text, answer_text, order_index)
         VALUES ($1, $2, $3, $4, $5)`,
        [
          projectId,
          faker.helpers.arrayElement(questionCategories),
          faker.lorem.sentence() + '?',
          faker.lorem.paragraphs(2),
          i,
        ]
      );
      totalQuestions++;
    }
  }

  console.log(chalk.green(`  [OK] ${totalQuestions} questions`));
}

async function main(): Promise<void> {
  const shouldReset = process.argv.includes('--reset');
  const pool = await createPool();

  console.log(chalk.bold('='.repeat(50)));
  console.log(chalk.bold('  Database Seeding'));
  console.log(chalk.bold('='.repeat(50)));

  try {
    if (shouldReset) {
      await clearData(pool);
    }

    const userIds = await seedUsers(pool);
    const projectIds = await seedProjects(pool, userIds);
    await seedQuestions(pool, projectIds);

    console.log(chalk.green('\nSeeding completed successfully!'));
    console.log(chalk.gray(`\nTest credentials:`));
    console.log(chalk.gray(`  Email: user1@seed.test`));
    console.log(chalk.gray(`  (Use magic link or reset password)`));
  } catch (error) {
    console.error(chalk.red('\nSeeding failed:'), error);
    process.exit(1);
  } finally {
    await pool.end();
  }
}

main();
```

---

## 7. 도메인 및 SSL 설정

### 7.1 도메인 설정 스크립트

```typescript
// /scripts/setup-domain.ts
/**
 * 도메인 설정 스크립트
 *
 * @description Vercel 도메인 및 DNS 설정
 * @dependencies execa, chalk
 * @usage npx tsx scripts/setup-domain.ts
 */

import { execa } from 'execa';
import chalk from 'chalk';
import * as readline from 'readline';

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

function question(prompt: string): Promise<string> {
  return new Promise((resolve) => {
    rl.question(prompt, resolve);
  });
}

interface DomainConfig {
  apex: string;
  www: boolean;
  staging: boolean;
}

async function addDomain(domain: string): Promise<void> {
  try {
    await execa('vercel', ['domains', 'add', domain], { stdio: 'inherit' });
    console.log(chalk.green(`  [OK] ${domain} added`));
  } catch (error) {
    console.error(chalk.red(`  [FAIL] Failed to add ${domain}`));
  }
}

async function verifyDomain(domain: string): Promise<boolean> {
  try {
    const result = await execa('vercel', ['domains', 'inspect', domain], { stdio: 'pipe' });
    return result.stdout.includes('verified');
  } catch {
    return false;
  }
}

async function setupDomains(config: DomainConfig): Promise<void> {
  console.log(chalk.blue('\nSetting up domains...\n'));

  // Apex 도메인
  await addDomain(config.apex);

  // WWW 서브도메인
  if (config.www) {
    await addDomain(`www.${config.apex}`);
  }

  // Staging 서브도메인
  if (config.staging) {
    await addDomain(`staging.${config.apex}`);
  }

  console.log(chalk.yellow('\nDNS Configuration Required:\n'));
  console.log(chalk.gray('Add the following DNS records to your domain provider:\n'));

  console.log(chalk.white('For apex domain:'));
  console.log(chalk.gray('  Type: A'));
  console.log(chalk.gray('  Name: @'));
  console.log(chalk.gray('  Value: 76.76.21.21'));

  if (config.www) {
    console.log(chalk.white('\nFor www subdomain:'));
    console.log(chalk.gray('  Type: CNAME'));
    console.log(chalk.gray('  Name: www'));
    console.log(chalk.gray('  Value: cname.vercel-dns.com'));
  }

  if (config.staging) {
    console.log(chalk.white('\nFor staging subdomain:'));
    console.log(chalk.gray('  Type: CNAME'));
    console.log(chalk.gray('  Name: staging'));
    console.log(chalk.gray('  Value: cname.vercel-dns.com'));
  }
}

async function main(): Promise<void> {
  console.log(chalk.bold('='.repeat(50)));
  console.log(chalk.bold('  Domain Setup'));
  console.log(chalk.bold('='.repeat(50)));

  const apex = await question('\nEnter your domain (e.g., magnetic-sales.app): ');
  const www = (await question('Add www subdomain? (y/n): ')).toLowerCase() === 'y';
  const staging = (await question('Add staging subdomain? (y/n): ')).toLowerCase() === 'y';

  await setupDomains({ apex, www, staging });

  console.log(chalk.yellow('\nAfter DNS propagation (up to 48 hours), verify with:'));
  console.log(chalk.gray(`  vercel domains inspect ${apex}`));

  rl.close();
}

main().catch(console.error);
```

### 7.2 SSL 인증서 확인

```typescript
// /scripts/check-ssl.ts
/**
 * SSL 인증서 확인 스크립트
 *
 * @description 도메인 SSL 상태 확인
 * @dependencies tls, chalk
 * @usage npx tsx scripts/check-ssl.ts [domain]
 */

import * as tls from 'tls';
import * as https from 'https';
import chalk from 'chalk';

interface SSLInfo {
  valid: boolean;
  issuer: string;
  subject: string;
  validFrom: Date;
  validTo: Date;
  daysRemaining: number;
  protocol: string;
}

async function checkSSL(domain: string): Promise<SSLInfo> {
  return new Promise((resolve, reject) => {
    const options = {
      host: domain,
      port: 443,
      method: 'GET',
      rejectUnauthorized: false,
    };

    const req = https.request(options, (res) => {
      const socket = res.socket as tls.TLSSocket;
      const cert = socket.getPeerCertificate();

      if (!cert || Object.keys(cert).length === 0) {
        reject(new Error('No certificate found'));
        return;
      }

      const validFrom = new Date(cert.valid_from);
      const validTo = new Date(cert.valid_to);
      const now = new Date();
      const daysRemaining = Math.floor((validTo.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));

      resolve({
        valid: socket.authorized,
        issuer: cert.issuer?.O || 'Unknown',
        subject: cert.subject?.CN || domain,
        validFrom,
        validTo,
        daysRemaining,
        protocol: socket.getProtocol() || 'Unknown',
      });
    });

    req.on('error', reject);
    req.end();
  });
}

async function main(): Promise<void> {
  const domain = process.argv[2] || 'magnetic-sales.app';

  console.log(chalk.bold('='.repeat(50)));
  console.log(chalk.bold(`  SSL Certificate Check: ${domain}`));
  console.log(chalk.bold('='.repeat(50)));

  try {
    const info = await checkSSL(domain);

    console.log(chalk.blue('\nCertificate Information:\n'));

    const statusColor = info.valid ? chalk.green : chalk.red;
    console.log(`  Status: ${statusColor(info.valid ? 'Valid' : 'Invalid')}`);
    console.log(`  Issuer: ${info.issuer}`);
    console.log(`  Subject: ${info.subject}`);
    console.log(`  Valid From: ${info.validFrom.toISOString()}`);
    console.log(`  Valid To: ${info.validTo.toISOString()}`);

    const daysColor = info.daysRemaining > 30 ? chalk.green :
                      info.daysRemaining > 7 ? chalk.yellow : chalk.red;
    console.log(`  Days Remaining: ${daysColor(info.daysRemaining.toString())}`);
    console.log(`  Protocol: ${info.protocol}`);

    if (info.daysRemaining <= 30) {
      console.log(chalk.yellow('\n  Warning: Certificate expires soon!'));
    }

    if (!info.valid) {
      console.log(chalk.red('\n  Error: Certificate is not valid'));
    }
  } catch (error) {
    console.error(chalk.red('\nFailed to check SSL:'), error);
  }
}

main();
```

---

## 8. Edge Functions 및 Middleware

### 8.1 Middleware 설정

```typescript
// /src/middleware.ts
/**
 * Next.js Edge Middleware
 *
 * @description 요청 처리 전 미들웨어
 * @dependencies next/server, @supabase/ssr
 */

import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { createServerClient, type CookieOptions } from '@supabase/ssr';

// 인증이 필요한 경로
const PROTECTED_ROUTES = ['/dashboard', '/projects', '/settings', '/api/projects', '/api/ai'];

// 인증된 사용자가 접근하면 안 되는 경로
const AUTH_ROUTES = ['/auth/login', '/auth/register'];

// Rate limiting을 위한 간단한 인메모리 스토어 (Edge에서 Redis 대체)
const rateLimitStore = new Map<string, { count: number; timestamp: number }>();

export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;

  // 정적 파일 및 API 헬스체크 스킵
  if (
    pathname.startsWith('/_next') ||
    pathname.startsWith('/static') ||
    pathname === '/api/health' ||
    pathname === '/favicon.ico'
  ) {
    return NextResponse.next();
  }

  // Rate Limiting (API 라우트만)
  if (pathname.startsWith('/api/')) {
    const ip = request.ip || request.headers.get('x-forwarded-for') || 'unknown';
    const key = `${ip}:${pathname}`;
    const now = Date.now();
    const windowMs = 60000; // 1분
    const maxRequests = pathname.startsWith('/api/ai') ? 10 : 100;

    const current = rateLimitStore.get(key);

    if (current && now - current.timestamp < windowMs) {
      if (current.count >= maxRequests) {
        return NextResponse.json(
          { error: 'Too many requests' },
          { status: 429, headers: { 'Retry-After': '60' } }
        );
      }
      current.count++;
    } else {
      rateLimitStore.set(key, { count: 1, timestamp: now });
    }

    // 오래된 항목 정리 (메모리 관리)
    if (rateLimitStore.size > 10000) {
      const cutoff = now - windowMs;
      for (const [k, v] of rateLimitStore) {
        if (v.timestamp < cutoff) rateLimitStore.delete(k);
      }
    }
  }

  // Supabase 세션 확인
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: CookieOptions) {
          request.cookies.set({ name, value, ...options });
          response = NextResponse.next({
            request: { headers: request.headers },
          });
          response.cookies.set({ name, value, ...options });
        },
        remove(name: string, options: CookieOptions) {
          request.cookies.set({ name, value: '', ...options });
          response = NextResponse.next({
            request: { headers: request.headers },
          });
          response.cookies.set({ name, value: '', ...options });
        },
      },
    }
  );

  const {
    data: { session },
  } = await supabase.auth.getSession();

  const isProtectedRoute = PROTECTED_ROUTES.some((route) => pathname.startsWith(route));
  const isAuthRoute = AUTH_ROUTES.some((route) => pathname.startsWith(route));

  // 인증 필요한 경로인데 세션 없음
  if (isProtectedRoute && !session) {
    const loginUrl = new URL('/auth/login', request.url);
    loginUrl.searchParams.set('redirect', pathname);
    return NextResponse.redirect(loginUrl);
  }

  // 인증된 사용자가 auth 페이지 접근
  if (isAuthRoute && session) {
    return NextResponse.redirect(new URL('/dashboard', request.url));
  }

  // 보안 헤더 추가
  response.headers.set('X-Content-Type-Options', 'nosniff');
  response.headers.set('X-Frame-Options', 'DENY');
  response.headers.set('X-XSS-Protection', '1; mode=block');
  response.headers.set('Referrer-Policy', 'strict-origin-when-cross-origin');

  return response;
}

export const config = {
  matcher: [
    /*
     * Match all request paths except:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * - public folder
     */
    '/((?!_next/static|_next/image|favicon.ico|public/).*)',
  ],
};
```

### 8.2 Edge API 라우트

```typescript
// /src/app/api/edge/geo/route.ts
/**
 * Edge 지리적 위치 API
 *
 * @description Edge에서 실행되는 Geo API
 * @dependencies next/server
 */

import { NextRequest, NextResponse } from 'next/server';

export const runtime = 'edge';

interface GeoData {
  country: string | undefined;
  city: string | undefined;
  region: string | undefined;
  latitude: string | undefined;
  longitude: string | undefined;
}

export async function GET(request: NextRequest) {
  const geo: GeoData = {
    country: request.geo?.country,
    city: request.geo?.city,
    region: request.geo?.region,
    latitude: request.geo?.latitude,
    longitude: request.geo?.longitude,
  };

  return NextResponse.json({
    success: true,
    data: {
      geo,
      headers: {
        'x-forwarded-for': request.headers.get('x-forwarded-for'),
        'x-real-ip': request.headers.get('x-real-ip'),
        'x-vercel-ip-country': request.headers.get('x-vercel-ip-country'),
        'x-vercel-ip-city': request.headers.get('x-vercel-ip-city'),
      },
    },
  });
}
```

### 8.3 Cron Job 핸들러

```typescript
// /src/app/api/cron/cleanup-expired-sessions/route.ts
/**
 * 만료된 세션 정리 Cron Job
 *
 * @description 매일 실행되는 세션 정리 작업
 * @dependencies @supabase/supabase-js
 * @schedule 0 2 * * * (매일 오전 2시)
 */

import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import { getServerEnv } from '@/config/env';

export const runtime = 'nodejs';
export const maxDuration = 60;

export async function GET(request: NextRequest) {
  // Cron 시크릿 검증
  const authHeader = request.headers.get('authorization');
  const cronSecret = getServerEnv().CRON_SECRET;

  if (cronSecret && authHeader !== `Bearer ${cronSecret}`) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    getServerEnv().SUPABASE_SERVICE_ROLE_KEY
  );

  const results = {
    expiredSessions: 0,
    orphanedTokens: 0,
    inactiveUsers: 0,
    errors: [] as string[],
  };

  try {
    // 1. 만료된 리프레시 토큰 정리
    const { count: tokenCount, error: tokenError } = await supabase
      .from('refresh_tokens')
      .delete()
      .lt('expires_at', new Date().toISOString())
      .select('*', { count: 'exact', head: true });

    if (tokenError) {
      results.errors.push(`Token cleanup: ${tokenError.message}`);
    } else {
      results.orphanedTokens = tokenCount || 0;
    }

    // 2. 30일 이상 비활성 사용자 세션 정리
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

    const { count: sessionCount, error: sessionError } = await supabase
      .from('user_sessions')
      .delete()
      .lt('last_activity', thirtyDaysAgo.toISOString())
      .select('*', { count: 'exact', head: true });

    if (sessionError) {
      results.errors.push(`Session cleanup: ${sessionError.message}`);
    } else {
      results.expiredSessions = sessionCount || 0;
    }

    // 3. 임시 데이터 정리 (draft 상태 7일 이상)
    const sevenDaysAgo = new Date();
    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

    await supabase
      .from('projects')
      .delete()
      .eq('status', 'draft')
      .lt('updated_at', sevenDaysAgo.toISOString());

    console.log('Cleanup completed:', results);

    return NextResponse.json({
      success: true,
      data: results,
      timestamp: new Date().toISOString(),
    });
  } catch (error) {
    console.error('Cleanup error:', error);

    return NextResponse.json({
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
      data: results,
      timestamp: new Date().toISOString(),
    }, { status: 500 });
  }
}
```

---

## 9. 캐싱 전략

### 9.1 캐싱 유틸리티

```typescript
// /src/lib/cache/cache-manager.ts
/**
 * 캐시 매니저
 *
 * @description 다층 캐싱 전략 구현
 * @dependencies @upstash/redis (optional)
 */

import { getServerEnv } from '@/config/env';

export interface CacheOptions {
  ttl?: number; // seconds
  tags?: string[];
  staleWhileRevalidate?: number;
}

export interface CacheEntry<T> {
  data: T;
  timestamp: number;
  ttl: number;
  tags: string[];
}

// 인메모리 캐시 (서버리스 함수 재사용 동안 유지)
const memoryCache = new Map<string, CacheEntry<unknown>>();

// Redis 클라이언트 (lazy initialization)
let redisClient: RedisLike | null = null;

interface RedisLike {
  get(key: string): Promise<string | null>;
  set(key: string, value: string, options?: { ex?: number }): Promise<void>;
  del(key: string): Promise<void>;
  keys(pattern: string): Promise<string[]>;
}

async function getRedisClient(): Promise<RedisLike | null> {
  const env = getServerEnv();

  if (!env.UPSTASH_REDIS_REST_URL || !env.UPSTASH_REDIS_REST_TOKEN) {
    return null;
  }

  if (redisClient) return redisClient;

  try {
    const { Redis } = await import('@upstash/redis');
    redisClient = new Redis({
      url: env.UPSTASH_REDIS_REST_URL,
      token: env.UPSTASH_REDIS_REST_TOKEN,
    }) as RedisLike;
    return redisClient;
  } catch {
    console.warn('Redis not available, using memory cache only');
    return null;
  }
}

export async function cacheGet<T>(key: string): Promise<T | null> {
  const cacheKey = `cache:${key}`;

  // 1. 인메모리 캐시 확인
  const memEntry = memoryCache.get(cacheKey) as CacheEntry<T> | undefined;
  if (memEntry) {
    const isExpired = Date.now() > memEntry.timestamp + memEntry.ttl * 1000;
    if (!isExpired) {
      return memEntry.data;
    }
    memoryCache.delete(cacheKey);
  }

  // 2. Redis 캐시 확인
  const redis = await getRedisClient();
  if (redis) {
    try {
      const redisData = await redis.get(cacheKey);
      if (redisData) {
        const entry = JSON.parse(redisData) as CacheEntry<T>;

        // 인메모리에도 저장
        memoryCache.set(cacheKey, entry);

        return entry.data;
      }
    } catch (error) {
      console.error('Redis get error:', error);
    }
  }

  return null;
}

export async function cacheSet<T>(
  key: string,
  data: T,
  options: CacheOptions = {}
): Promise<void> {
  const { ttl = 300, tags = [] } = options;
  const cacheKey = `cache:${key}`;

  const entry: CacheEntry<T> = {
    data,
    timestamp: Date.now(),
    ttl,
    tags,
  };

  // 1. 인메모리 캐시에 저장
  memoryCache.set(cacheKey, entry as CacheEntry<unknown>);

  // 2. Redis에 저장
  const redis = await getRedisClient();
  if (redis) {
    try {
      await redis.set(cacheKey, JSON.stringify(entry), { ex: ttl });

      // 태그 인덱스 저장
      for (const tag of tags) {
        await redis.set(`tag:${tag}:${key}`, '1', { ex: ttl });
      }
    } catch (error) {
      console.error('Redis set error:', error);
    }
  }
}

export async function cacheDelete(key: string): Promise<void> {
  const cacheKey = `cache:${key}`;

  // 인메모리에서 삭제
  memoryCache.delete(cacheKey);

  // Redis에서 삭제
  const redis = await getRedisClient();
  if (redis) {
    try {
      await redis.del(cacheKey);
    } catch (error) {
      console.error('Redis delete error:', error);
    }
  }
}

export async function cacheInvalidateByTag(tag: string): Promise<void> {
  const redis = await getRedisClient();

  if (redis) {
    try {
      const keys = await redis.keys(`tag:${tag}:*`);

      for (const tagKey of keys) {
        const key = tagKey.replace(`tag:${tag}:`, '');
        await cacheDelete(key);
        await redis.del(tagKey);
      }
    } catch (error) {
      console.error('Redis invalidate error:', error);
    }
  }

  // 인메모리 태그 기반 무효화
  for (const [key, entry] of memoryCache) {
    if (entry.tags.includes(tag)) {
      memoryCache.delete(key);
    }
  }
}

// SWR 패턴 캐시
export async function cacheWithSWR<T>(
  key: string,
  fetcher: () => Promise<T>,
  options: CacheOptions = {}
): Promise<T> {
  const { ttl = 300, staleWhileRevalidate = 60 } = options;

  // 캐시 확인
  const cached = await cacheGet<{ data: T; fetchedAt: number }>(key);

  if (cached) {
    const age = (Date.now() - cached.fetchedAt) / 1000;

    // 신선한 데이터
    if (age < ttl) {
      return cached.data;
    }

    // Stale 데이터 - 백그라운드에서 갱신
    if (age < ttl + staleWhileRevalidate) {
      // 비동기로 갱신 (fire and forget)
      fetcher().then((newData) => {
        cacheSet(key, { data: newData, fetchedAt: Date.now() }, options);
      }).catch(console.error);

      return cached.data;
    }
  }

  // 캐시 미스 또는 완전히 만료
  const data = await fetcher();
  await cacheSet(key, { data, fetchedAt: Date.now() }, options);

  return data;
}
```

### 9.2 API 응답 캐싱

```typescript
// /src/lib/cache/api-cache.ts
/**
 * API 응답 캐싱
 *
 * @description Next.js API 라우트 캐싱 유틸리티
 * @dependencies cache-manager
 */

import { NextResponse } from 'next/server';
import { cacheGet, cacheSet, type CacheOptions } from './cache-manager';

export interface CachedResponse<T> {
  data: T;
  cached: boolean;
  cachedAt?: string;
}

export function withCache<T>(
  handler: () => Promise<T>,
  options: {
    key: string | ((req?: Request) => string);
    ttl?: number;
    tags?: string[];
    condition?: (data: T) => boolean;
  }
) {
  return async (request?: Request): Promise<NextResponse<CachedResponse<T>>> => {
    const cacheKey = typeof options.key === 'function'
      ? options.key(request)
      : options.key;

    // 캐시 확인
    const cached = await cacheGet<{ data: T; timestamp: string }>(cacheKey);

    if (cached) {
      return NextResponse.json({
        data: cached.data,
        cached: true,
        cachedAt: cached.timestamp,
      }, {
        headers: {
          'X-Cache': 'HIT',
          'X-Cache-Key': cacheKey,
        },
      });
    }

    // 실제 데이터 가져오기
    const data = await handler();

    // 조건부 캐싱
    const shouldCache = options.condition ? options.condition(data) : true;

    if (shouldCache) {
      await cacheSet(cacheKey, {
        data,
        timestamp: new Date().toISOString()
      }, {
        ttl: options.ttl,
        tags: options.tags,
      });
    }

    return NextResponse.json({
      data,
      cached: false,
    }, {
      headers: {
        'X-Cache': 'MISS',
        'X-Cache-Key': cacheKey,
      },
    });
  };
}

// 캐시 헤더 설정 헬퍼
export function setCacheHeaders(
  response: NextResponse,
  options: {
    maxAge?: number;
    sMaxAge?: number;
    staleWhileRevalidate?: number;
    private?: boolean;
  }
): NextResponse {
  const directives: string[] = [];

  if (options.private) {
    directives.push('private');
  } else {
    directives.push('public');
  }

  if (options.maxAge !== undefined) {
    directives.push(`max-age=${options.maxAge}`);
  }

  if (options.sMaxAge !== undefined) {
    directives.push(`s-maxage=${options.sMaxAge}`);
  }

  if (options.staleWhileRevalidate !== undefined) {
    directives.push(`stale-while-revalidate=${options.staleWhileRevalidate}`);
  }

  response.headers.set('Cache-Control', directives.join(', '));

  return response;
}
```

---

## 10. 모니터링 및 관측성

### 10.1 Sentry 설정

```typescript
// /src/lib/monitoring/sentry.ts
/**
 * Sentry 에러 모니터링 설정
 *
 * @description Sentry 초기화 및 유틸리티
 * @dependencies @sentry/nextjs
 */

import * as Sentry from '@sentry/nextjs';
import { getServerEnv, getClientEnv } from '@/config/env';

export function initSentry() {
  const isServer = typeof window === 'undefined';
  const dsn = isServer ? getServerEnv().SENTRY_DSN : getClientEnv().NEXT_PUBLIC_SENTRY_DSN;

  if (!dsn) {
    console.log('Sentry DSN not configured, skipping initialization');
    return;
  }

  Sentry.init({
    dsn,
    environment: process.env.VERCEL_ENV || 'development',
    release: process.env.VERCEL_GIT_COMMIT_SHA,

    // 성능 모니터링
    tracesSampleRate: process.env.NODE_ENV === 'production' ? 0.1 : 1.0,

    // 에러 샘플링
    sampleRate: 1.0,

    // 민감한 데이터 필터링
    beforeSend(event, hint) {
      // 개발 환경에서는 콘솔만 출력
      if (process.env.NODE_ENV === 'development') {
        console.error('Sentry would capture:', hint.originalException);
        return null;
      }

      // 민감한 정보 제거
      if (event.request?.headers) {
        delete event.request.headers['authorization'];
        delete event.request.headers['cookie'];
      }

      // 특정 에러 무시
      const error = hint.originalException;
      if (error instanceof Error) {
        // 사용자 취소 에러 무시
        if (error.name === 'AbortError') return null;
        // 네트워크 에러 무시
        if (error.message.includes('fetch failed')) return null;
      }

      return event;
    },

    // 브레드크럼 필터링
    beforeBreadcrumb(breadcrumb) {
      // 민감한 URL 필터링
      if (breadcrumb.category === 'navigation') {
        if (breadcrumb.data?.to?.includes('/auth/')) {
          breadcrumb.data.to = '[AUTH_ROUTE]';
        }
      }
      return breadcrumb;
    },

    // 통합 설정
    integrations: [
      Sentry.browserTracingIntegration(),
      Sentry.replayIntegration({
        maskAllText: true,
        blockAllMedia: true,
      }),
    ],

    // Replay 설정 (클라이언트만)
    replaysSessionSampleRate: 0.1,
    replaysOnErrorSampleRate: 1.0,
  });
}

// 사용자 컨텍스트 설정
export function setUserContext(user: { id: string; email: string }) {
  Sentry.setUser({
    id: user.id,
    email: user.email,
  });
}

// 사용자 컨텍스트 제거
export function clearUserContext() {
  Sentry.setUser(null);
}

// 커스텀 에러 캡처
export function captureError(
  error: Error,
  context?: Record<string, unknown>
) {
  Sentry.captureException(error, {
    extra: context,
  });
}

// 커스텀 메시지 캡처
export function captureMessage(
  message: string,
  level: Sentry.SeverityLevel = 'info',
  context?: Record<string, unknown>
) {
  Sentry.captureMessage(message, {
    level,
    extra: context,
  });
}

// 트랜잭션 시작
export function startTransaction(
  name: string,
  op: string
): Sentry.Span | undefined {
  return Sentry.startInactiveSpan({ name, op });
}
```

### 10.2 성능 모니터링

```typescript
// /src/lib/monitoring/performance.ts
/**
 * 성능 모니터링
 *
 * @description Web Vitals 및 커스텀 메트릭 수집
 * @dependencies web-vitals
 */

import type { Metric } from 'web-vitals';

export interface PerformanceMetric {
  name: string;
  value: number;
  rating: 'good' | 'needs-improvement' | 'poor';
  timestamp: number;
}

// Web Vitals 임계값
const thresholds = {
  CLS: { good: 0.1, poor: 0.25 },
  FCP: { good: 1800, poor: 3000 },
  FID: { good: 100, poor: 300 },
  INP: { good: 200, poor: 500 },
  LCP: { good: 2500, poor: 4000 },
  TTFB: { good: 800, poor: 1800 },
};

function getRating(
  name: string,
  value: number
): 'good' | 'needs-improvement' | 'poor' {
  const threshold = thresholds[name as keyof typeof thresholds];
  if (!threshold) return 'good';

  if (value <= threshold.good) return 'good';
  if (value <= threshold.poor) return 'needs-improvement';
  return 'poor';
}

// 메트릭 리포터
export function reportWebVitals(metric: Metric) {
  const body: PerformanceMetric = {
    name: metric.name,
    value: metric.value,
    rating: getRating(metric.name, metric.value),
    timestamp: Date.now(),
  };

  // 개발 환경에서는 콘솔 출력
  if (process.env.NODE_ENV === 'development') {
    console.log('[Web Vitals]', body);
    return;
  }

  // Analytics로 전송
  if (typeof window !== 'undefined' && window.gtag) {
    window.gtag('event', metric.name, {
      event_category: 'Web Vitals',
      event_label: metric.id,
      value: Math.round(metric.name === 'CLS' ? metric.value * 1000 : metric.value),
      non_interaction: true,
    });
  }

  // 커스텀 엔드포인트로 전송
  if (process.env.NEXT_PUBLIC_ANALYTICS_ENDPOINT) {
    fetch(process.env.NEXT_PUBLIC_ANALYTICS_ENDPOINT, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body),
      keepalive: true,
    }).catch(console.error);
  }
}

// 커스텀 성능 측정
export function measurePerformance<T>(
  name: string,
  fn: () => T
): T {
  const start = performance.now();

  try {
    const result = fn();

    if (result instanceof Promise) {
      return result.finally(() => {
        const duration = performance.now() - start;
        logPerformance(name, duration);
      }) as T;
    }

    const duration = performance.now() - start;
    logPerformance(name, duration);

    return result;
  } catch (error) {
    const duration = performance.now() - start;
    logPerformance(name, duration, true);
    throw error;
  }
}

function logPerformance(name: string, duration: number, isError = false) {
  const metric = {
    name,
    duration: Math.round(duration),
    isError,
    timestamp: Date.now(),
  };

  if (process.env.NODE_ENV === 'development') {
    console.log('[Performance]', metric);
  }

  // Sentry 트랜잭션으로 전송
  if (typeof window !== 'undefined') {
    import('@sentry/nextjs').then((Sentry) => {
      Sentry.addBreadcrumb({
        category: 'performance',
        message: name,
        level: isError ? 'error' : 'info',
        data: { duration },
      });
    });
  }
}

// React 컴포넌트 성능 측정 HOC
export function withPerformance<P extends object>(
  Component: React.ComponentType<P>,
  name: string
): React.ComponentType<P> {
  const WrappedComponent = (props: P) => {
    React.useEffect(() => {
      const mountTime = performance.now();

      return () => {
        const unmountTime = performance.now();
        logPerformance(`${name}:lifetime`, unmountTime - mountTime);
      };
    }, []);

    return React.createElement(Component, props);
  };

  WrappedComponent.displayName = `withPerformance(${name})`;

  return WrappedComponent;
}

// React import 추가
import * as React from 'react';

// Window에 gtag 타입 추가
declare global {
  interface Window {
    gtag?: (
      command: string,
      action: string,
      params?: Record<string, unknown>
    ) => void;
  }
}
```

### 10.3 로깅 시스템

```typescript
// /src/lib/monitoring/logger.ts
/**
 * 구조화된 로깅 시스템
 *
 * @description JSON 포맷 로거
 * @dependencies 없음
 */

export type LogLevel = 'debug' | 'info' | 'warn' | 'error';

export interface LogEntry {
  level: LogLevel;
  message: string;
  timestamp: string;
  context?: Record<string, unknown>;
  error?: {
    name: string;
    message: string;
    stack?: string;
  };
  request?: {
    method: string;
    path: string;
    userAgent?: string;
    ip?: string;
  };
  performance?: {
    duration: number;
  };
}

const LOG_LEVELS: Record<LogLevel, number> = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3,
};

const CURRENT_LOG_LEVEL: LogLevel =
  (process.env.LOG_LEVEL as LogLevel) ||
  (process.env.NODE_ENV === 'production' ? 'info' : 'debug');

class Logger {
  private context: Record<string, unknown> = {};

  constructor(context?: Record<string, unknown>) {
    if (context) {
      this.context = context;
    }
  }

  private shouldLog(level: LogLevel): boolean {
    return LOG_LEVELS[level] >= LOG_LEVELS[CURRENT_LOG_LEVEL];
  }

  private formatEntry(entry: LogEntry): string {
    if (process.env.NODE_ENV === 'development') {
      const levelColors: Record<LogLevel, string> = {
        debug: '\x1b[36m', // cyan
        info: '\x1b[32m',  // green
        warn: '\x1b[33m',  // yellow
        error: '\x1b[31m', // red
      };
      const reset = '\x1b[0m';

      return `${levelColors[entry.level]}[${entry.level.toUpperCase()}]${reset} ${entry.message}${
        entry.context ? ` ${JSON.stringify(entry.context)}` : ''
      }`;
    }

    return JSON.stringify(entry);
  }

  private log(level: LogLevel, message: string, data?: Record<string, unknown>) {
    if (!this.shouldLog(level)) return;

    const entry: LogEntry = {
      level,
      message,
      timestamp: new Date().toISOString(),
      context: { ...this.context, ...data },
    };

    const formatted = this.formatEntry(entry);

    switch (level) {
      case 'debug':
        console.debug(formatted);
        break;
      case 'info':
        console.info(formatted);
        break;
      case 'warn':
        console.warn(formatted);
        break;
      case 'error':
        console.error(formatted);
        break;
    }
  }

  debug(message: string, data?: Record<string, unknown>) {
    this.log('debug', message, data);
  }

  info(message: string, data?: Record<string, unknown>) {
    this.log('info', message, data);
  }

  warn(message: string, data?: Record<string, unknown>) {
    this.log('warn', message, data);
  }

  error(message: string, error?: Error, data?: Record<string, unknown>) {
    const entry: LogEntry = {
      level: 'error',
      message,
      timestamp: new Date().toISOString(),
      context: { ...this.context, ...data },
    };

    if (error) {
      entry.error = {
        name: error.name,
        message: error.message,
        stack: error.stack,
      };
    }

    const formatted = this.formatEntry(entry);
    console.error(formatted);

    // Sentry로 에러 전송
    if (error && process.env.NODE_ENV === 'production') {
      import('./sentry').then(({ captureError }) => {
        captureError(error, entry.context);
      });
    }
  }

  child(context: Record<string, unknown>): Logger {
    return new Logger({ ...this.context, ...context });
  }
}

export const logger = new Logger();

// API 요청 로거
export function createRequestLogger(request: Request): Logger {
  return logger.child({
    method: request.method,
    path: new URL(request.url).pathname,
    userAgent: request.headers.get('user-agent') || undefined,
  });
}
```

---

## 11. 롤백 절차

### 11.1 롤백 스크립트

```typescript
// /scripts/rollback.ts
/**
 * 배포 롤백 스크립트
 *
 * @description Vercel 배포 롤백
 * @dependencies execa, chalk
 * @usage npx tsx scripts/rollback.ts [deployment-url]
 */

import { execa } from 'execa';
import chalk from 'chalk';
import * as readline from 'readline';

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

function question(prompt: string): Promise<string> {
  return new Promise((resolve) => {
    rl.question(prompt, resolve);
  });
}

interface Deployment {
  uid: string;
  url: string;
  created: string;
  state: string;
  target: string | null;
}

async function listDeployments(): Promise<Deployment[]> {
  const result = await execa('vercel', ['list', '--json', '-n', '10'], {
    stdio: 'pipe'
  });

  return JSON.parse(result.stdout);
}

async function promoteDeployment(url: string): Promise<void> {
  console.log(chalk.blue(`\nPromoting ${url} to production...`));

  await execa('vercel', ['promote', url], { stdio: 'inherit' });

  console.log(chalk.green('Rollback completed successfully!'));
}

async function main(): Promise<void> {
  console.log(chalk.bold('='.repeat(50)));
  console.log(chalk.bold('  Deployment Rollback'));
  console.log(chalk.bold('='.repeat(50)));

  const targetUrl = process.argv[2];

  if (targetUrl) {
    const confirm = await question(
      `Roll back to ${targetUrl}? (y/n): `
    );

    if (confirm.toLowerCase() === 'y') {
      await promoteDeployment(targetUrl);
    }
  } else {
    console.log(chalk.blue('\nFetching recent deployments...\n'));

    const deployments = await listDeployments();

    console.log(chalk.gray('-'.repeat(80)));
    console.log(
      chalk.gray('#'.padEnd(4)),
      chalk.gray('State'.padEnd(10)),
      chalk.gray('URL'.padEnd(40)),
      chalk.gray('Created')
    );
    console.log(chalk.gray('-'.repeat(80)));

    deployments.forEach((d, i) => {
      const stateColor = d.state === 'READY' ? chalk.green : chalk.yellow;
      const targetBadge = d.target === 'production' ? chalk.bgGreen(' PROD ') : '';

      console.log(
        (i + 1).toString().padEnd(4),
        stateColor(d.state.padEnd(10)),
        (d.url.substring(0, 38) + (d.url.length > 38 ? '..' : '')).padEnd(40),
        new Date(d.created).toLocaleString(),
        targetBadge
      );
    });

    console.log(chalk.gray('-'.repeat(80)));

    const choice = await question('\nEnter deployment number to rollback (or q to quit): ');

    if (choice.toLowerCase() === 'q') {
      console.log('Cancelled.');
    } else {
      const index = parseInt(choice) - 1;
      if (index >= 0 && index < deployments.length) {
        const deployment = deployments[index];

        if (deployment.target === 'production') {
          console.log(chalk.yellow('This deployment is already in production.'));
        } else {
          const confirm = await question(
            `Roll back to ${deployment.url}? (y/n): `
          );

          if (confirm.toLowerCase() === 'y') {
            await promoteDeployment(deployment.url);
          }
        }
      } else {
        console.log(chalk.red('Invalid selection.'));
      }
    }
  }

  rl.close();
}

main().catch(console.error);
```

### 11.2 데이터베이스 롤백

```typescript
// /scripts/db/rollback.ts
/**
 * 데이터베이스 롤백 스크립트
 *
 * @description 백업에서 데이터베이스 복원
 * @dependencies pg, dotenv, chalk
 * @usage npx tsx scripts/db/rollback.ts [backup-file]
 */

import { Pool } from 'pg';
import * as fs from 'fs';
import * as path from 'path';
import chalk from 'chalk';
import * as dotenv from 'dotenv';
import * as readline from 'readline';

dotenv.config({ path: '.env.local' });

const BACKUPS_DIR = path.join(process.cwd(), 'backups');

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

function question(prompt: string): Promise<string> {
  return new Promise((resolve) => {
    rl.question(prompt, resolve);
  });
}

async function createPool(): Promise<Pool> {
  return new Pool({
    host: process.env.SUPABASE_DB_HOST,
    port: parseInt(process.env.SUPABASE_DB_PORT || '5432'),
    user: process.env.SUPABASE_DB_USER || 'postgres',
    password: process.env.SUPABASE_DB_PASSWORD,
    database: 'postgres',
    ssl: { rejectUnauthorized: false },
  });
}

function listBackups(): string[] {
  if (!fs.existsSync(BACKUPS_DIR)) {
    return [];
  }

  return fs.readdirSync(BACKUPS_DIR)
    .filter((f) => f.endsWith('.sql'))
    .sort()
    .reverse();
}

async function restoreBackup(pool: Pool, backupFile: string): Promise<void> {
  const filePath = path.join(BACKUPS_DIR, backupFile);

  if (!fs.existsSync(filePath)) {
    throw new Error(`Backup file not found: ${filePath}`);
  }

  console.log(chalk.blue(`\nRestoring from ${backupFile}...`));

  const sql = fs.readFileSync(filePath, 'utf-8');
  const client = await pool.connect();

  try {
    await client.query('BEGIN');

    // 기존 데이터 삭제
    console.log(chalk.yellow('  Clearing existing data...'));
    await client.query('DELETE FROM question_responses');
    await client.query('DELETE FROM questions');
    await client.query('DELETE FROM projects');

    // 백업 데이터 복원
    console.log(chalk.yellow('  Restoring backup data...'));
    await client.query(sql);

    await client.query('COMMIT');
    console.log(chalk.green('\nRestore completed successfully!'));
  } catch (error) {
    await client.query('ROLLBACK');
    console.error(chalk.red('Restore failed, rolling back...'));
    throw error;
  } finally {
    client.release();
  }
}

async function main(): Promise<void> {
  console.log(chalk.bold('='.repeat(50)));
  console.log(chalk.bold('  Database Rollback'));
  console.log(chalk.bold('='.repeat(50)));

  const pool = await createPool();
  const backupFile = process.argv[2];

  try {
    if (backupFile) {
      const confirm = await question(
        chalk.red(`\nWARNING: This will OVERWRITE current data!\nRestore from ${backupFile}? (yes/no): `)
      );

      if (confirm.toLowerCase() === 'yes') {
        await restoreBackup(pool, backupFile);
      }
    } else {
      const backups = listBackups();

      if (backups.length === 0) {
        console.log(chalk.yellow('\nNo backups found.'));
        console.log(chalk.gray(`Backups directory: ${BACKUPS_DIR}`));
      } else {
        console.log(chalk.blue('\nAvailable backups:\n'));

        backups.forEach((b, i) => {
          console.log(`  ${i + 1}. ${b}`);
        });

        const choice = await question('\nEnter backup number to restore (or q to quit): ');

        if (choice.toLowerCase() !== 'q') {
          const index = parseInt(choice) - 1;

          if (index >= 0 && index < backups.length) {
            const confirm = await question(
              chalk.red(`\nWARNING: This will OVERWRITE current data!\nRestore from ${backups[index]}? (yes/no): `)
            );

            if (confirm.toLowerCase() === 'yes') {
              await restoreBackup(pool, backups[index]);
            }
          } else {
            console.log(chalk.red('Invalid selection.'));
          }
        }
      }
    }
  } finally {
    await pool.end();
    rl.close();
  }
}

main().catch(console.error);
```

---

## 12. 배포 체크리스트

### 12.1 배포 전 체크리스트

```typescript
// /scripts/pre-deploy-check.ts
/**
 * 배포 전 체크리스트 검증
 *
 * @description 배포 전 필수 항목 확인
 * @dependencies chalk, execa
 * @usage npx tsx scripts/pre-deploy-check.ts
 */

import chalk from 'chalk';
import { execa } from 'execa';
import * as fs from 'fs';
import * as path from 'path';

interface CheckResult {
  name: string;
  status: 'pass' | 'fail' | 'warn';
  message: string;
}

const results: CheckResult[] = [];

function addResult(name: string, status: CheckResult['status'], message: string) {
  results.push({ name, status, message });
}

async function checkEnvVariables(): Promise<void> {
  const requiredVars = [
    'NEXT_PUBLIC_SUPABASE_URL',
    'NEXT_PUBLIC_SUPABASE_ANON_KEY',
    'ANTHROPIC_API_KEY',
  ];

  const missing: string[] = [];

  for (const varName of requiredVars) {
    if (!process.env[varName]) {
      missing.push(varName);
    }
  }

  if (missing.length > 0) {
    addResult('Environment Variables', 'fail', `Missing: ${missing.join(', ')}`);
  } else {
    addResult('Environment Variables', 'pass', 'All required variables set');
  }
}

async function checkBuild(): Promise<void> {
  try {
    await execa('pnpm', ['build'], { stdio: 'pipe' });
    addResult('Build', 'pass', 'Build completed successfully');
  } catch (error) {
    addResult('Build', 'fail', 'Build failed');
  }
}

async function checkTypeScript(): Promise<void> {
  try {
    await execa('pnpm', ['type-check'], { stdio: 'pipe' });
    addResult('TypeScript', 'pass', 'No type errors');
  } catch (error) {
    addResult('TypeScript', 'fail', 'Type errors found');
  }
}

async function checkLinting(): Promise<void> {
  try {
    await execa('pnpm', ['lint'], { stdio: 'pipe' });
    addResult('ESLint', 'pass', 'No linting errors');
  } catch (error) {
    addResult('ESLint', 'fail', 'Linting errors found');
  }
}

async function checkTests(): Promise<void> {
  try {
    await execa('pnpm', ['test:ci'], { stdio: 'pipe' });
    addResult('Tests', 'pass', 'All tests passed');
  } catch (error) {
    addResult('Tests', 'fail', 'Some tests failed');
  }
}

async function checkSecurityAudit(): Promise<void> {
  try {
    await execa('pnpm', ['audit', '--audit-level=high'], { stdio: 'pipe' });
    addResult('Security Audit', 'pass', 'No high/critical vulnerabilities');
  } catch (error) {
    addResult('Security Audit', 'warn', 'Vulnerabilities found (check manually)');
  }
}

async function checkBundleSize(): Promise<void> {
  const buildDir = path.join(process.cwd(), '.next');

  if (!fs.existsSync(buildDir)) {
    addResult('Bundle Size', 'warn', 'Build directory not found');
    return;
  }

  // 간단한 번들 크기 체크 (실제로는 더 정교하게)
  const staticDir = path.join(buildDir, 'static', 'chunks');

  if (fs.existsSync(staticDir)) {
    const files = fs.readdirSync(staticDir);
    const totalSize = files.reduce((acc, file) => {
      const stat = fs.statSync(path.join(staticDir, file));
      return acc + stat.size;
    }, 0);

    const sizeMB = (totalSize / 1024 / 1024).toFixed(2);

    if (totalSize > 5 * 1024 * 1024) { // 5MB 이상
      addResult('Bundle Size', 'warn', `${sizeMB}MB (consider optimization)`);
    } else {
      addResult('Bundle Size', 'pass', `${sizeMB}MB`);
    }
  }
}

async function checkMigrations(): Promise<void> {
  const migrationsDir = path.join(process.cwd(), 'supabase', 'migrations');

  if (!fs.existsSync(migrationsDir)) {
    addResult('Migrations', 'warn', 'No migrations directory');
    return;
  }

  const files = fs.readdirSync(migrationsDir).filter((f) => f.endsWith('.sql'));
  addResult('Migrations', 'pass', `${files.length} migration files found`);
}

function printResults(): void {
  console.log(chalk.bold('\n' + '='.repeat(60)));
  console.log(chalk.bold('  Pre-Deployment Checklist Results'));
  console.log(chalk.bold('='.repeat(60) + '\n'));

  let hasFailures = false;

  for (const result of results) {
    const icon = result.status === 'pass' ? chalk.green('✓') :
                 result.status === 'fail' ? chalk.red('✗') :
                 chalk.yellow('⚠');

    const statusColor = result.status === 'pass' ? chalk.green :
                        result.status === 'fail' ? chalk.red :
                        chalk.yellow;

    console.log(`  ${icon} ${result.name.padEnd(25)} ${statusColor(result.message)}`);

    if (result.status === 'fail') hasFailures = true;
  }

  console.log(chalk.bold('\n' + '='.repeat(60)));

  if (hasFailures) {
    console.log(chalk.red('\n  ✗ Pre-deployment checks FAILED'));
    console.log(chalk.red('    Fix the issues above before deploying.\n'));
    process.exit(1);
  } else {
    console.log(chalk.green('\n  ✓ All pre-deployment checks PASSED'));
    console.log(chalk.green('    Ready to deploy!\n'));
  }
}

async function main(): Promise<void> {
  console.log(chalk.blue('\nRunning pre-deployment checks...\n'));

  await checkEnvVariables();
  await checkTypeScript();
  await checkLinting();
  await checkTests();
  await checkSecurityAudit();
  await checkBuild();
  await checkBundleSize();
  await checkMigrations();

  printResults();
}

main().catch((error) => {
  console.error(chalk.red('Check failed:'), error);
  process.exit(1);
});
```

### 12.2 배포 후 검증

```typescript
// /scripts/post-deploy-verify.ts
/**
 * 배포 후 검증 스크립트
 *
 * @description 배포 후 서비스 상태 확인
 * @dependencies chalk, node-fetch
 * @usage npx tsx scripts/post-deploy-verify.ts [url]
 */

import chalk from 'chalk';

interface VerificationResult {
  name: string;
  status: 'pass' | 'fail';
  message: string;
  latency?: number;
}

const results: VerificationResult[] = [];

async function checkEndpoint(
  name: string,
  url: string,
  expectedStatus: number = 200
): Promise<void> {
  const start = Date.now();

  try {
    const response = await fetch(url);
    const latency = Date.now() - start;

    if (response.status === expectedStatus) {
      results.push({
        name,
        status: 'pass',
        message: `${response.status} OK`,
        latency,
      });
    } else {
      results.push({
        name,
        status: 'fail',
        message: `Expected ${expectedStatus}, got ${response.status}`,
        latency,
      });
    }
  } catch (error) {
    results.push({
      name,
      status: 'fail',
      message: error instanceof Error ? error.message : 'Unknown error',
    });
  }
}

async function checkHealthEndpoint(baseUrl: string): Promise<void> {
  const start = Date.now();

  try {
    const response = await fetch(`${baseUrl}/api/health`);
    const latency = Date.now() - start;
    const data = await response.json();

    if (data.status === 'healthy') {
      results.push({
        name: 'Health Check',
        status: 'pass',
        message: `All systems healthy`,
        latency,
      });
    } else {
      results.push({
        name: 'Health Check',
        status: 'fail',
        message: `Status: ${data.status}`,
        latency,
      });
    }
  } catch (error) {
    results.push({
      name: 'Health Check',
      status: 'fail',
      message: error instanceof Error ? error.message : 'Unknown error',
    });
  }
}

async function checkSSL(url: string): Promise<void> {
  try {
    const response = await fetch(url);
    const isSecure = new URL(response.url).protocol === 'https:';

    if (isSecure) {
      results.push({
        name: 'SSL/TLS',
        status: 'pass',
        message: 'HTTPS enabled',
      });
    } else {
      results.push({
        name: 'SSL/TLS',
        status: 'fail',
        message: 'Not using HTTPS',
      });
    }
  } catch (error) {
    results.push({
      name: 'SSL/TLS',
      status: 'fail',
      message: error instanceof Error ? error.message : 'Unknown error',
    });
  }
}

async function checkSecurityHeaders(url: string): Promise<void> {
  try {
    const response = await fetch(url);
    const headers = response.headers;

    const requiredHeaders = [
      'x-content-type-options',
      'x-frame-options',
      'x-xss-protection',
    ];

    const missing: string[] = [];

    for (const header of requiredHeaders) {
      if (!headers.get(header)) {
        missing.push(header);
      }
    }

    if (missing.length === 0) {
      results.push({
        name: 'Security Headers',
        status: 'pass',
        message: 'All required headers present',
      });
    } else {
      results.push({
        name: 'Security Headers',
        status: 'fail',
        message: `Missing: ${missing.join(', ')}`,
      });
    }
  } catch (error) {
    results.push({
      name: 'Security Headers',
      status: 'fail',
      message: error instanceof Error ? error.message : 'Unknown error',
    });
  }
}

function printResults(): void {
  console.log(chalk.bold('\n' + '='.repeat(60)));
  console.log(chalk.bold('  Post-Deployment Verification Results'));
  console.log(chalk.bold('='.repeat(60) + '\n'));

  let hasFailures = false;

  for (const result of results) {
    const icon = result.status === 'pass' ? chalk.green('✓') : chalk.red('✗');
    const latencyStr = result.latency ? chalk.gray(` (${result.latency}ms)`) : '';

    console.log(`  ${icon} ${result.name.padEnd(25)} ${result.message}${latencyStr}`);

    if (result.status === 'fail') hasFailures = true;
  }

  console.log(chalk.bold('\n' + '='.repeat(60)));

  if (hasFailures) {
    console.log(chalk.red('\n  ✗ Some verifications FAILED'));
    console.log(chalk.red('    Check the issues above.\n'));
    process.exit(1);
  } else {
    console.log(chalk.green('\n  ✓ All verifications PASSED'));
    console.log(chalk.green('    Deployment successful!\n'));
  }
}

async function main(): Promise<void> {
  const baseUrl = process.argv[2] || 'https://magnetic-sales.app';

  console.log(chalk.blue(`\nVerifying deployment at ${baseUrl}...\n`));

  await checkEndpoint('Homepage', baseUrl);
  await checkEndpoint('Auth Page', `${baseUrl}/auth/login`);
  await checkHealthEndpoint(baseUrl);
  await checkSSL(baseUrl);
  await checkSecurityHeaders(baseUrl);

  printResults();
}

main().catch((error) => {
  console.error(chalk.red('Verification failed:'), error);
  process.exit(1);
});
```

### 12.3 종합 체크리스트 (마크다운)

```markdown
# 배포 체크리스트

## 배포 전 (Pre-deployment)

### 코드 품질
- [ ] TypeScript 타입 체크 통과 (`pnpm type-check`)
- [ ] ESLint 검사 통과 (`pnpm lint`)
- [ ] Prettier 포맷팅 확인 (`pnpm format:check`)
- [ ] 단위 테스트 통과 (`pnpm test:unit`)
- [ ] 통합 테스트 통과 (`pnpm test:integration`)

### 보안
- [ ] 보안 취약점 스캔 (`pnpm audit`)
- [ ] 하드코딩된 시크릿 없음
- [ ] .env 파일 gitignore 확인
- [ ] HTTPS 강제 설정

### 빌드
- [ ] 프로덕션 빌드 성공 (`pnpm build`)
- [ ] 번들 크기 확인 (< 500KB initial)
- [ ] 이미지 최적화 확인

### 데이터베이스
- [ ] 마이그레이션 파일 준비
- [ ] 백업 생성
- [ ] 롤백 계획 수립

### 환경 변수
- [ ] 모든 필수 환경 변수 설정
- [ ] Vercel 환경 변수 동기화
- [ ] 프로덕션/스테이징 분리 확인

## 배포 중 (During deployment)

### Vercel 배포
- [ ] Preview 배포 확인
- [ ] E2E 테스트 실행
- [ ] 성능 테스트 실행
- [ ] 프로덕션 배포 승인

### 데이터베이스
- [ ] 마이그레이션 실행
- [ ] 마이그레이션 검증
- [ ] 데이터 무결성 확인

## 배포 후 (Post-deployment)

### 기능 검증
- [ ] 홈페이지 로드 확인
- [ ] 로그인/로그아웃 테스트
- [ ] 핵심 기능 수동 테스트
- [ ] API 엔드포인트 확인

### 성능 & 모니터링
- [ ] Health check 통과
- [ ] Sentry 에러 모니터링 확인
- [ ] 응답 시간 확인 (< 3초)
- [ ] Web Vitals 확인

### 보안
- [ ] SSL 인증서 확인
- [ ] 보안 헤더 확인
- [ ] CORS 설정 확인

### 알림
- [ ] 팀에 배포 완료 알림
- [ ] 변경 사항 문서화
- [ ] 이슈 트래커 업데이트
```

---

## 요약

이 배포 가이드는 다음을 포함합니다:

1. **배포 아키텍처**: Vercel Edge Network, Supabase, Redis 통합
2. **Vercel 설정**: vercel.json, Next.js 프로덕션 설정
3. **환경 변수 관리**: Zod 스키마 검증, 동기화 스크립트
4. **CI/CD 파이프라인**: GitHub Actions 워크플로우
5. **배포 전략**: Feature Flags, Health Check
6. **DB 마이그레이션**: 마이그레이션 러너, 시드 데이터
7. **도메인/SSL**: 설정 스크립트, 인증서 확인
8. **Edge Functions**: Middleware, Cron Jobs
9. **캐싱 전략**: 다층 캐싱, SWR 패턴
10. **모니터링**: Sentry, 성능 모니터링, 로깅
11. **롤백 절차**: 배포 롤백, DB 롤백
12. **체크리스트**: 배포 전/후 검증

모든 코드는 **복사-붙여넣기**로 즉시 사용 가능하며, TypeScript 타입 안전성과 엔터프라이즈급 품질을 보장합니다.
