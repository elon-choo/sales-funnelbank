# 06. 프론트엔드 아키텍처 PRD

## 문서 정보
| 항목 | 내용 |
|------|------|
| 문서 버전 | 1.0 |
| 작성일 | 2025-01-15 |
| 작성자 | CTO |
| 상태 | 최종 |

---

## 1. 프론트엔드 아키텍처 개요

### 1.1 아키텍처 다이어그램

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           Frontend Architecture                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                               │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                         App Router (Next.js 14)                       │    │
│  │  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐   │    │
│  │  │  (auth) │  │dashboard│  │ generate│  │  editor │  │ preview │   │    │
│  │  │ /login  │  │    /    │  │   /new  │  │  /[id]  │  │/p/[slug]│   │    │
│  │  └────┬────┘  └────┬────┘  └────┬────┘  └────┬────┘  └────┬────┘   │    │
│  └───────┼────────────┼────────────┼────────────┼────────────┼────────┘    │
│          │            │            │            │            │              │
│  ┌───────▼────────────▼────────────▼────────────▼────────────▼────────┐    │
│  │                          Page Components                            │    │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐           │    │
│  │  │LoginPage │  │Dashboard │  │Generator │  │  Editor  │           │    │
│  │  │SignupPage│  │  Page    │  │   Page   │  │   Page   │           │    │
│  │  └────┬─────┘  └────┬─────┘  └────┬─────┘  └────┬─────┘           │    │
│  └───────┼─────────────┼─────────────┼─────────────┼──────────────────┘    │
│          │             │             │             │                        │
│  ┌───────▼─────────────▼─────────────▼─────────────▼──────────────────┐    │
│  │                         UI Components                               │    │
│  │  ┌────────┐  ┌────────┐  ┌────────┐  ┌────────┐  ┌────────┐      │    │
│  │  │ Button │  │  Input │  │  Modal │  │  Card  │  │ Toast  │      │    │
│  │  │  Form  │  │ Select │  │ Dialog │  │Progress│  │Skeleton│      │    │
│  │  └────────┘  └────────┘  └────────┘  └────────┘  └────────┘      │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│                                    │                                        │
│  ┌─────────────────────────────────▼──────────────────────────────────┐    │
│  │                        State Management                             │    │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐             │    │
│  │  │  authStore   │  │projectStore  │  │ uiStore      │             │    │
│  │  │  (Zustand)   │  │  (Zustand)   │  │  (Zustand)   │             │    │
│  │  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘             │    │
│  └─────────┼─────────────────┼─────────────────┼───────────────────────┘    │
│            │                 │                 │                            │
│  ┌─────────▼─────────────────▼─────────────────▼───────────────────────┐    │
│  │                          Custom Hooks                               │    │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐           │    │
│  │  │ useAuth  │  │useProject│  │useAI     │  │useTokens │           │    │
│  │  │useSession│  │useLanding│  │useStream │  │useUpload │           │    │
│  │  └──────────┘  └──────────┘  └──────────┘  └──────────┘           │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│                                    │                                        │
│  ┌─────────────────────────────────▼──────────────────────────────────┐    │
│  │                           API Layer                                 │    │
│  │  ┌──────────────────────────────────────────────────────────┐     │    │
│  │  │                    API Client (fetch)                     │     │    │
│  │  │  - Request Interceptor (Auth Token)                       │     │    │
│  │  │  - Response Interceptor (Error Handling)                  │     │    │
│  │  │  - Auto Token Refresh                                     │     │    │
│  │  └──────────────────────────────────────────────────────────┘     │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│                                                                               │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 1.2 기술 스택

```yaml
Core:
  Framework: Next.js 14 (App Router)
  Language: TypeScript 5.x
  Runtime: Node.js 20.x

Styling:
  CSS Framework: Tailwind CSS 3.4
  Component Library: shadcn/ui
  Icons: Lucide React
  Animations: Framer Motion

State Management:
  Client State: Zustand 4.x
  Server State: TanStack Query 5.x
  Form State: React Hook Form + Zod

Rich Text Editor:
  Library: TipTap 2.x
  Extensions: StarterKit, Image, Link, Placeholder

Utilities:
  Date: date-fns
  HTTP: Native fetch (with custom wrapper)
  Validation: Zod
  Sanitization: DOMPurify
```

---

## 2. 라우팅 구조

### 2.1 App Router 구조

```
// 파일: app/ 디렉토리 구조
// 목적: Next.js 14 App Router 기반 페이지 라우팅

app/
├── (auth)/                          # 인증 그룹 (레이아웃 공유)
│   ├── layout.tsx                   # 인증 페이지 레이아웃
│   ├── login/
│   │   └── page.tsx                 # 로그인 페이지
│   ├── signup/
│   │   └── page.tsx                 # 회원가입 페이지
│   ├── forgot-password/
│   │   └── page.tsx                 # 비밀번호 찾기
│   ├── reset-password/
│   │   └── page.tsx                 # 비밀번호 재설정
│   └── pending-approval/
│       └── page.tsx                 # 승인 대기 페이지
│
├── (dashboard)/                     # 대시보드 그룹 (인증 필요)
│   ├── layout.tsx                   # 대시보드 레이아웃 (사이드바)
│   ├── page.tsx                     # 대시보드 홈
│   ├── projects/
│   │   ├── page.tsx                 # 프로젝트 목록
│   │   ├── new/
│   │   │   └── page.tsx             # 새 프로젝트 생성
│   │   └── [id]/
│   │       ├── page.tsx             # 프로젝트 상세
│   │       ├── questions/
│   │       │   └── page.tsx         # 40개 질문 답변
│   │       ├── generate/
│   │       │   └── page.tsx         # AI 생성 페이지
│   │       ├── edit/
│   │       │   └── page.tsx         # 에디터 페이지
│   │       └── preview/
│   │           └── page.tsx         # 미리보기 페이지
│   ├── settings/
│   │   └── page.tsx                 # 설정 페이지
│   └── tokens/
│       └── page.tsx                 # 토큰 사용량 페이지
│
├── (public)/                        # 공개 페이지 그룹
│   └── p/
│       └── [slug]/
│           └── page.tsx             # 배포된 랜딩페이지
│
├── api/                             # API Routes
│   └── [...] (03_API_명세.md 참조)
│
├── layout.tsx                       # 루트 레이아웃
├── page.tsx                         # 랜딩 페이지 (/)
├── loading.tsx                      # 전역 로딩 UI
├── error.tsx                        # 전역 에러 UI
├── not-found.tsx                    # 404 페이지
└── globals.css                      # 전역 스타일
```

### 2.2 라우트 설정 타입

```typescript
// 파일: src/types/routes.ts
// 목적: 타입 안전한 라우팅을 위한 상수 및 타입 정의
// 의존성: 없음

export const ROUTES = {
  // Public routes
  HOME: '/',
  LOGIN: '/login',
  SIGNUP: '/signup',
  FORGOT_PASSWORD: '/forgot-password',
  RESET_PASSWORD: '/reset-password',
  PENDING_APPROVAL: '/pending-approval',

  // Dashboard routes
  DASHBOARD: '/dashboard',
  PROJECTS: '/projects',
  PROJECT_NEW: '/projects/new',
  PROJECT_DETAIL: (id: string) => `/projects/${id}` as const,
  PROJECT_QUESTIONS: (id: string) => `/projects/${id}/questions` as const,
  PROJECT_GENERATE: (id: string) => `/projects/${id}/generate` as const,
  PROJECT_EDIT: (id: string) => `/projects/${id}/edit` as const,
  PROJECT_PREVIEW: (id: string) => `/projects/${id}/preview` as const,

  // Settings
  SETTINGS: '/settings',
  TOKENS: '/tokens',

  // Public landing pages
  LANDING_PAGE: (slug: string) => `/p/${slug}` as const,
} as const;

// 타입 추출
export type RouteKey = keyof typeof ROUTES;
export type StaticRoute = Extract<(typeof ROUTES)[RouteKey], string>;
export type DynamicRoute = Extract<(typeof ROUTES)[RouteKey], (...args: any[]) => string>;

// 보호된 라우트 목록
export const PROTECTED_ROUTES: string[] = [
  '/dashboard',
  '/projects',
  '/settings',
  '/tokens',
];

// 인증 페이지 (로그인 상태에서 접근 불가)
export const AUTH_ROUTES: string[] = [
  '/login',
  '/signup',
  '/forgot-password',
  '/reset-password',
];
```

### 2.3 미들웨어 (라우트 보호)

```typescript
// 파일: middleware.ts
// 목적: 인증 상태에 따른 라우트 보호 및 리다이렉션
// 의존성: next/server, @supabase/ssr

import { createServerClient, type CookieOptions } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';
import { PROTECTED_ROUTES, AUTH_ROUTES, ROUTES } from '@/types/routes';

export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;

  // 정적 파일 및 API 제외
  if (
    pathname.startsWith('/_next') ||
    pathname.startsWith('/api') ||
    pathname.includes('.')
  ) {
    return NextResponse.next();
  }

  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: CookieOptions) {
          request.cookies.set({ name, value, ...options });
          response = NextResponse.next({
            request: { headers: request.headers },
          });
          response.cookies.set({ name, value, ...options });
        },
        remove(name: string, options: CookieOptions) {
          request.cookies.set({ name, value: '', ...options });
          response = NextResponse.next({
            request: { headers: request.headers },
          });
          response.cookies.set({ name, value: '', ...options });
        },
      },
    }
  );

  const { data: { session } } = await supabase.auth.getSession();

  // 보호된 라우트 접근 체크
  const isProtectedRoute = PROTECTED_ROUTES.some(route =>
    pathname.startsWith(route)
  );

  const isAuthRoute = AUTH_ROUTES.some(route =>
    pathname.startsWith(route)
  );

  // 미인증 사용자가 보호된 라우트 접근 시
  if (isProtectedRoute && !session) {
    const redirectUrl = new URL(ROUTES.LOGIN, request.url);
    redirectUrl.searchParams.set('redirect', pathname);
    return NextResponse.redirect(redirectUrl);
  }

  // 인증된 사용자가 인증 페이지 접근 시
  if (isAuthRoute && session) {
    return NextResponse.redirect(new URL(ROUTES.DASHBOARD, request.url));
  }

  // 승인 상태 체크 (보호된 라우트에서만)
  if (isProtectedRoute && session) {
    const { data: profile } = await supabase
      .from('profiles')
      .select('is_approved')
      .eq('id', session.user.id)
      .single();

    // 미승인 사용자는 승인 대기 페이지로
    if (!profile?.is_approved && pathname !== ROUTES.PENDING_APPROVAL) {
      return NextResponse.redirect(
        new URL(ROUTES.PENDING_APPROVAL, request.url)
      );
    }
  }

  return response;
}

export const config = {
  matcher: [
    /*
     * Match all request paths except:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * - public folder
     */
    '/((?!_next/static|_next/image|favicon.ico|public/).*)',
  ],
};
```

---

## 3. Zustand 상태 관리

### 3.1 Auth Store

```typescript
// 파일: src/stores/authStore.ts
// 목적: 인증 상태 및 사용자 정보 전역 관리
// 의존성: zustand, @/types/auth

import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';

// ============================================
// 타입 정의
// ============================================

export interface User {
  id: string;
  email: string;
  name: string;
  avatarUrl: string | null;
  tier: 'free' | 'pro' | 'enterprise';
  isApproved: boolean;
  createdAt: string;
}

export interface AuthState {
  // State
  user: User | null;
  accessToken: string | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  isInitialized: boolean;
  error: string | null;

  // Actions
  setUser: (user: User | null) => void;
  setAccessToken: (token: string | null) => void;
  setLoading: (loading: boolean) => void;
  setInitialized: (initialized: boolean) => void;
  setError: (error: string | null) => void;
  login: (user: User, accessToken: string) => void;
  logout: () => void;
  updateUser: (updates: Partial<User>) => void;
  reset: () => void;
}

// ============================================
// 초기 상태
// ============================================

const initialState = {
  user: null,
  accessToken: null,
  isAuthenticated: false,
  isLoading: true,
  isInitialized: false,
  error: null,
};

// ============================================
// Store 생성
// ============================================

export const useAuthStore = create<AuthState>()(
  persist(
    immer((set, get) => ({
      ...initialState,

      setUser: (user) =>
        set((state) => {
          state.user = user;
          state.isAuthenticated = !!user;
        }),

      setAccessToken: (token) =>
        set((state) => {
          state.accessToken = token;
        }),

      setLoading: (loading) =>
        set((state) => {
          state.isLoading = loading;
        }),

      setInitialized: (initialized) =>
        set((state) => {
          state.isInitialized = initialized;
        }),

      setError: (error) =>
        set((state) => {
          state.error = error;
        }),

      login: (user, accessToken) =>
        set((state) => {
          state.user = user;
          state.accessToken = accessToken;
          state.isAuthenticated = true;
          state.isLoading = false;
          state.error = null;
        }),

      logout: () =>
        set((state) => {
          state.user = null;
          state.accessToken = null;
          state.isAuthenticated = false;
          state.error = null;
        }),

      updateUser: (updates) =>
        set((state) => {
          if (state.user) {
            state.user = { ...state.user, ...updates };
          }
        }),

      reset: () => set(initialState),
    })),
    {
      name: 'auth-storage',
      storage: createJSONStorage(() => sessionStorage),
      // accessToken은 메모리에만 저장 (보안)
      partialize: (state) => ({
        user: state.user,
        isAuthenticated: state.isAuthenticated,
      }),
    }
  )
);

// ============================================
// Selector Hooks (성능 최적화)
// ============================================

export const useUser = () => useAuthStore((state) => state.user);
export const useIsAuthenticated = () => useAuthStore((state) => state.isAuthenticated);
export const useAuthLoading = () => useAuthStore((state) => state.isLoading);
export const useAuthError = () => useAuthStore((state) => state.error);
```

### 3.2 Project Store

```typescript
// 파일: src/stores/projectStore.ts
// 목적: 프로젝트 및 랜딩페이지 상태 관리
// 의존성: zustand, immer, @/types/project

import { create } from 'zustand';
import { immer } from 'zustand/middleware/immer';
import { devtools } from 'zustand/middleware';

// ============================================
// 타입 정의
// ============================================

export type ProjectStatus = 'draft' | 'generating' | 'completed' | 'published';

export interface Answer {
  questionId: number;
  answer: string;
  updatedAt: string;
}

export interface Project {
  id: string;
  userId: string;
  title: string;
  status: ProjectStatus;
  templateId: string | null;
  answers: Answer[];
  generatedContent: GeneratedContent | null;
  publishedUrl: string | null;
  createdAt: string;
  updatedAt: string;
  deletedAt: string | null;
}

export interface GeneratedContent {
  html: string;
  css: string;
  sections: Section[];
  metadata: ContentMetadata;
}

export interface Section {
  id: string;
  type: 'hero' | 'problem' | 'solution' | 'proof' | 'offer' | 'cta';
  content: string;
  order: number;
}

export interface ContentMetadata {
  headline: string;
  subheadline: string;
  generatedAt: string;
  tokenUsage: {
    input: number;
    output: number;
  };
}

export interface ProjectState {
  // State
  projects: Project[];
  currentProject: Project | null;
  currentQuestionIndex: number;
  isLoading: boolean;
  isSaving: boolean;
  error: string | null;
  lastSavedAt: string | null;

  // Actions
  setProjects: (projects: Project[]) => void;
  addProject: (project: Project) => void;
  updateProject: (id: string, updates: Partial<Project>) => void;
  removeProject: (id: string) => void;
  setCurrentProject: (project: Project | null) => void;
  setCurrentQuestionIndex: (index: number) => void;
  saveAnswer: (questionId: number, answer: string) => void;
  setGeneratedContent: (content: GeneratedContent) => void;
  setLoading: (loading: boolean) => void;
  setSaving: (saving: boolean) => void;
  setError: (error: string | null) => void;
  reset: () => void;
}

// ============================================
// 초기 상태
// ============================================

const initialState = {
  projects: [],
  currentProject: null,
  currentQuestionIndex: 0,
  isLoading: false,
  isSaving: false,
  error: null,
  lastSavedAt: null,
};

// ============================================
// Store 생성
// ============================================

export const useProjectStore = create<ProjectState>()(
  devtools(
    immer((set, get) => ({
      ...initialState,

      setProjects: (projects) =>
        set((state) => {
          state.projects = projects;
        }),

      addProject: (project) =>
        set((state) => {
          state.projects.unshift(project);
        }),

      updateProject: (id, updates) =>
        set((state) => {
          const index = state.projects.findIndex((p) => p.id === id);
          if (index !== -1) {
            state.projects[index] = {
              ...state.projects[index],
              ...updates,
              updatedAt: new Date().toISOString(),
            };
          }
          if (state.currentProject?.id === id) {
            state.currentProject = {
              ...state.currentProject,
              ...updates,
              updatedAt: new Date().toISOString(),
            };
          }
        }),

      removeProject: (id) =>
        set((state) => {
          state.projects = state.projects.filter((p) => p.id !== id);
          if (state.currentProject?.id === id) {
            state.currentProject = null;
          }
        }),

      setCurrentProject: (project) =>
        set((state) => {
          state.currentProject = project;
          state.currentQuestionIndex = 0;
        }),

      setCurrentQuestionIndex: (index) =>
        set((state) => {
          state.currentQuestionIndex = index;
        }),

      saveAnswer: (questionId, answer) =>
        set((state) => {
          if (!state.currentProject) return;

          const existingIndex = state.currentProject.answers.findIndex(
            (a) => a.questionId === questionId
          );

          const newAnswer: Answer = {
            questionId,
            answer,
            updatedAt: new Date().toISOString(),
          };

          if (existingIndex !== -1) {
            state.currentProject.answers[existingIndex] = newAnswer;
          } else {
            state.currentProject.answers.push(newAnswer);
          }

          state.lastSavedAt = new Date().toISOString();
        }),

      setGeneratedContent: (content) =>
        set((state) => {
          if (state.currentProject) {
            state.currentProject.generatedContent = content;
            state.currentProject.status = 'completed';
          }
        }),

      setLoading: (loading) =>
        set((state) => {
          state.isLoading = loading;
        }),

      setSaving: (saving) =>
        set((state) => {
          state.isSaving = saving;
        }),

      setError: (error) =>
        set((state) => {
          state.error = error;
        }),

      reset: () => set(initialState),
    })),
    { name: 'project-store' }
  )
);

// ============================================
// Selector Hooks
// ============================================

export const useProjects = () => useProjectStore((state) => state.projects);
export const useCurrentProject = () => useProjectStore((state) => state.currentProject);
export const useProjectLoading = () => useProjectStore((state) => state.isLoading);
export const useProjectSaving = () => useProjectStore((state) => state.isSaving);
export const useCurrentQuestionIndex = () =>
  useProjectStore((state) => state.currentQuestionIndex);

// 계산된 값
export const useAnsweredQuestions = () =>
  useProjectStore((state) => state.currentProject?.answers.length ?? 0);

export const useProgress = () =>
  useProjectStore((state) => {
    const answered = state.currentProject?.answers.length ?? 0;
    return Math.round((answered / 40) * 100);
  });
```

### 3.3 UI Store

```typescript
// 파일: src/stores/uiStore.ts
// 목적: UI 상태 관리 (모달, 토스트, 사이드바 등)
// 의존성: zustand, immer

import { create } from 'zustand';
import { immer } from 'zustand/middleware/immer';

// ============================================
// 타입 정의
// ============================================

export type ToastType = 'success' | 'error' | 'warning' | 'info';

export interface Toast {
  id: string;
  type: ToastType;
  title: string;
  message?: string;
  duration?: number;
  action?: {
    label: string;
    onClick: () => void;
  };
}

export interface Modal {
  id: string;
  component: React.ComponentType<any>;
  props?: Record<string, any>;
}

export interface UIState {
  // Sidebar
  isSidebarOpen: boolean;
  isSidebarCollapsed: boolean;

  // Theme
  theme: 'light' | 'dark' | 'system';

  // Toasts
  toasts: Toast[];

  // Modals
  modals: Modal[];

  // Loading overlay
  isGlobalLoading: boolean;
  globalLoadingMessage: string | null;

  // Mobile
  isMobileMenuOpen: boolean;

  // Actions
  toggleSidebar: () => void;
  setSidebarCollapsed: (collapsed: boolean) => void;
  setTheme: (theme: 'light' | 'dark' | 'system') => void;
  addToast: (toast: Omit<Toast, 'id'>) => string;
  removeToast: (id: string) => void;
  clearToasts: () => void;
  openModal: (modal: Omit<Modal, 'id'>) => string;
  closeModal: (id: string) => void;
  closeAllModals: () => void;
  setGlobalLoading: (loading: boolean, message?: string) => void;
  toggleMobileMenu: () => void;
  setMobileMenuOpen: (open: boolean) => void;
}

// ============================================
// Store 생성
// ============================================

export const useUIStore = create<UIState>()(
  immer((set) => ({
    // Initial state
    isSidebarOpen: true,
    isSidebarCollapsed: false,
    theme: 'system',
    toasts: [],
    modals: [],
    isGlobalLoading: false,
    globalLoadingMessage: null,
    isMobileMenuOpen: false,

    // Actions
    toggleSidebar: () =>
      set((state) => {
        state.isSidebarOpen = !state.isSidebarOpen;
      }),

    setSidebarCollapsed: (collapsed) =>
      set((state) => {
        state.isSidebarCollapsed = collapsed;
      }),

    setTheme: (theme) =>
      set((state) => {
        state.theme = theme;
      }),

    addToast: (toast) => {
      const id = `toast-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      set((state) => {
        state.toasts.push({ ...toast, id });
      });
      return id;
    },

    removeToast: (id) =>
      set((state) => {
        state.toasts = state.toasts.filter((t) => t.id !== id);
      }),

    clearToasts: () =>
      set((state) => {
        state.toasts = [];
      }),

    openModal: (modal) => {
      const id = `modal-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      set((state) => {
        state.modals.push({ ...modal, id });
      });
      return id;
    },

    closeModal: (id) =>
      set((state) => {
        state.modals = state.modals.filter((m) => m.id !== id);
      }),

    closeAllModals: () =>
      set((state) => {
        state.modals = [];
      }),

    setGlobalLoading: (loading, message) =>
      set((state) => {
        state.isGlobalLoading = loading;
        state.globalLoadingMessage = message ?? null;
      }),

    toggleMobileMenu: () =>
      set((state) => {
        state.isMobileMenuOpen = !state.isMobileMenuOpen;
      }),

    setMobileMenuOpen: (open) =>
      set((state) => {
        state.isMobileMenuOpen = open;
      }),
  }))
);

// ============================================
// Selector Hooks
// ============================================

export const useToasts = () => useUIStore((state) => state.toasts);
export const useModals = () => useUIStore((state) => state.modals);
export const useGlobalLoading = () => useUIStore((state) => state.isGlobalLoading);
export const useTheme = () => useUIStore((state) => state.theme);
export const useSidebarState = () =>
  useUIStore((state) => ({
    isOpen: state.isSidebarOpen,
    isCollapsed: state.isSidebarCollapsed,
  }));
```

### 3.4 Token Store

```typescript
// 파일: src/stores/tokenStore.ts
// 목적: AI 토큰 사용량 상태 관리
// 의존성: zustand, immer

import { create } from 'zustand';
import { immer } from 'zustand/middleware/immer';

// ============================================
// 타입 정의
// ============================================

export interface TokenUsage {
  daily: {
    used: number;
    limit: number;
    remaining: number;
    resetAt: string;
  };
  monthly: {
    used: number;
    limit: number;
    remaining: number;
    resetAt: string;
  };
}

export interface TokenState {
  // State
  usage: TokenUsage | null;
  tier: 'free' | 'pro' | 'enterprise';
  isLoading: boolean;
  lastFetchedAt: string | null;
  error: string | null;

  // Actions
  setUsage: (usage: TokenUsage) => void;
  setTier: (tier: 'free' | 'pro' | 'enterprise') => void;
  setLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;
  incrementUsage: (tokens: number) => void;
  reset: () => void;
}

// ============================================
// 초기 상태
// ============================================

const initialState = {
  usage: null,
  tier: 'free' as const,
  isLoading: false,
  lastFetchedAt: null,
  error: null,
};

// ============================================
// Store 생성
// ============================================

export const useTokenStore = create<TokenState>()(
  immer((set) => ({
    ...initialState,

    setUsage: (usage) =>
      set((state) => {
        state.usage = usage;
        state.lastFetchedAt = new Date().toISOString();
      }),

    setTier: (tier) =>
      set((state) => {
        state.tier = tier;
      }),

    setLoading: (loading) =>
      set((state) => {
        state.isLoading = loading;
      }),

    setError: (error) =>
      set((state) => {
        state.error = error;
      }),

    incrementUsage: (tokens) =>
      set((state) => {
        if (state.usage) {
          state.usage.daily.used += tokens;
          state.usage.daily.remaining -= tokens;
          state.usage.monthly.used += tokens;
          state.usage.monthly.remaining -= tokens;
        }
      }),

    reset: () => set(initialState),
  }))
);

// ============================================
// Selector Hooks
// ============================================

export const useTokenUsage = () => useTokenStore((state) => state.usage);
export const useTokenTier = () => useTokenStore((state) => state.tier);
export const useTokenLoading = () => useTokenStore((state) => state.isLoading);

export const useDailyTokenPercentage = () =>
  useTokenStore((state) => {
    if (!state.usage) return 0;
    return Math.round((state.usage.daily.used / state.usage.daily.limit) * 100);
  });

export const useCanGenerateContent = () =>
  useTokenStore((state) => {
    if (!state.usage) return false;
    // 평균 생성에 약 5000 토큰 필요하다고 가정
    const ESTIMATED_GENERATION_TOKENS = 5000;
    return state.usage.daily.remaining >= ESTIMATED_GENERATION_TOKENS;
  });
```

---

## 4. Custom Hooks

### 4.1 useAuth Hook

```typescript
// 파일: src/hooks/useAuth.ts
// 목적: 인증 관련 비즈니스 로직 캡슐화
// 의존성: @/stores/authStore, @/lib/api, @/lib/supabase/client

import { useCallback, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { useAuthStore } from '@/stores/authStore';
import { useUIStore } from '@/stores/uiStore';
import { createClient } from '@/lib/supabase/client';
import { apiClient } from '@/lib/api/client';
import { ROUTES } from '@/types/routes';
import type { User } from '@/stores/authStore';

// ============================================
// 타입 정의
// ============================================

interface LoginCredentials {
  email: string;
  password: string;
  rememberMe?: boolean;
}

interface SignupData {
  email: string;
  password: string;
  name: string;
  phone?: string;
}

interface UseAuthReturn {
  // State
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  error: string | null;

  // Actions
  login: (credentials: LoginCredentials) => Promise<void>;
  signup: (data: SignupData) => Promise<void>;
  logout: () => Promise<void>;
  refreshSession: () => Promise<void>;
  resetPassword: (email: string) => Promise<void>;
  updatePassword: (newPassword: string) => Promise<void>;
  clearError: () => void;
}

// ============================================
// Hook 구현
// ============================================

export function useAuth(): UseAuthReturn {
  const router = useRouter();
  const supabase = createClient();

  const {
    user,
    isAuthenticated,
    isLoading,
    error,
    login: setLogin,
    logout: setLogout,
    setLoading,
    setError,
    setInitialized,
  } = useAuthStore();

  const { addToast } = useUIStore();

  // 세션 초기화
  useEffect(() => {
    const initializeAuth = async () => {
      try {
        setLoading(true);

        const { data: { session } } = await supabase.auth.getSession();

        if (session?.user) {
          // 프로필 정보 조회
          const { data: profile } = await supabase
            .from('profiles')
            .select('*')
            .eq('id', session.user.id)
            .single();

          if (profile) {
            const userData: User = {
              id: session.user.id,
              email: session.user.email!,
              name: profile.full_name,
              avatarUrl: profile.avatar_url,
              tier: profile.tier,
              isApproved: profile.is_approved,
              createdAt: profile.created_at,
            };

            setLogin(userData, session.access_token);
          }
        }
      } catch (err) {
        console.error('Auth initialization error:', err);
      } finally {
        setLoading(false);
        setInitialized(true);
      }
    };

    initializeAuth();

    // Auth 상태 변경 리스너
    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      async (event, session) => {
        if (event === 'SIGNED_OUT') {
          setLogout();
        } else if (event === 'TOKEN_REFRESHED' && session) {
          useAuthStore.getState().setAccessToken(session.access_token);
        }
      }
    );

    return () => {
      subscription.unsubscribe();
    };
  }, []);

  // 로그인
  const login = useCallback(async (credentials: LoginCredentials) => {
    try {
      setLoading(true);
      setError(null);

      const response = await apiClient.post<{
        user: User;
        accessToken: string;
      }>('/api/auth/login', credentials);

      setLogin(response.user, response.accessToken);

      addToast({
        type: 'success',
        title: '로그인 성공',
        message: `${response.user.name}님, 환영합니다!`,
      });

      router.push(ROUTES.DASHBOARD);
    } catch (err: any) {
      const message = err.message || '로그인에 실패했습니다.';
      setError(message);
      addToast({
        type: 'error',
        title: '로그인 실패',
        message,
      });
      throw err;
    } finally {
      setLoading(false);
    }
  }, [router, addToast]);

  // 회원가입
  const signup = useCallback(async (data: SignupData) => {
    try {
      setLoading(true);
      setError(null);

      await apiClient.post('/api/auth/signup', data);

      addToast({
        type: 'success',
        title: '회원가입 완료',
        message: '관리자 승인 후 서비스를 이용하실 수 있습니다.',
        duration: 5000,
      });

      router.push(ROUTES.PENDING_APPROVAL);
    } catch (err: any) {
      const message = err.message || '회원가입에 실패했습니다.';
      setError(message);
      addToast({
        type: 'error',
        title: '회원가입 실패',
        message,
      });
      throw err;
    } finally {
      setLoading(false);
    }
  }, [router, addToast]);

  // 로그아웃
  const logout = useCallback(async () => {
    try {
      setLoading(true);

      await apiClient.post('/api/auth/logout');
      await supabase.auth.signOut();

      setLogout();

      addToast({
        type: 'info',
        title: '로그아웃',
        message: '안전하게 로그아웃되었습니다.',
      });

      router.push(ROUTES.LOGIN);
    } catch (err: any) {
      console.error('Logout error:', err);
      // 에러가 발생해도 클라이언트 상태는 초기화
      setLogout();
      router.push(ROUTES.LOGIN);
    } finally {
      setLoading(false);
    }
  }, [router, addToast, supabase]);

  // 세션 갱신
  const refreshSession = useCallback(async () => {
    try {
      const response = await apiClient.post<{ accessToken: string }>(
        '/api/auth/refresh'
      );

      useAuthStore.getState().setAccessToken(response.accessToken);
    } catch (err) {
      // Refresh 실패 시 로그아웃
      await logout();
      throw err;
    }
  }, [logout]);

  // 비밀번호 재설정 요청
  const resetPassword = useCallback(async (email: string) => {
    try {
      setLoading(true);

      await apiClient.post('/api/auth/reset-password', { email });

      addToast({
        type: 'success',
        title: '이메일 발송 완료',
        message: '비밀번호 재설정 링크가 이메일로 발송되었습니다.',
        duration: 5000,
      });
    } catch (err: any) {
      // 보안을 위해 항상 성공 메시지 표시
      addToast({
        type: 'success',
        title: '이메일 발송 완료',
        message: '등록된 이메일이라면 재설정 링크가 발송됩니다.',
        duration: 5000,
      });
    } finally {
      setLoading(false);
    }
  }, [addToast]);

  // 비밀번호 업데이트
  const updatePassword = useCallback(async (newPassword: string) => {
    try {
      setLoading(true);

      await apiClient.post('/api/auth/update-password', { newPassword });

      addToast({
        type: 'success',
        title: '비밀번호 변경 완료',
        message: '새 비밀번호로 다시 로그인해주세요.',
      });

      await logout();
    } catch (err: any) {
      const message = err.message || '비밀번호 변경에 실패했습니다.';
      setError(message);
      addToast({
        type: 'error',
        title: '비밀번호 변경 실패',
        message,
      });
      throw err;
    } finally {
      setLoading(false);
    }
  }, [logout, addToast]);

  // 에러 초기화
  const clearError = useCallback(() => {
    setError(null);
  }, []);

  return {
    user,
    isAuthenticated,
    isLoading,
    error,
    login,
    signup,
    logout,
    refreshSession,
    resetPassword,
    updatePassword,
    clearError,
  };
}
```

### 4.2 useAIGeneration Hook

```typescript
// 파일: src/hooks/useAIGeneration.ts
// 목적: AI 랜딩페이지 생성 로직 (SSE 스트리밍 포함)
// 의존성: @/stores/projectStore, @/stores/tokenStore, @/lib/api

import { useState, useCallback, useRef, useEffect } from 'react';
import { useProjectStore } from '@/stores/projectStore';
import { useTokenStore } from '@/stores/tokenStore';
import { useUIStore } from '@/stores/uiStore';

// ============================================
// 타입 정의
// ============================================

export type GenerationStatus =
  | 'idle'
  | 'preparing'
  | 'generating'
  | 'processing'
  | 'completed'
  | 'error'
  | 'cancelled';

export interface GenerationProgress {
  stage: string;
  percentage: number;
  message: string;
  estimatedTimeRemaining?: number;
}

export interface GenerationResult {
  html: string;
  css: string;
  sections: Array<{
    id: string;
    type: string;
    content: string;
    order: number;
  }>;
  metadata: {
    headline: string;
    subheadline: string;
    generatedAt: string;
    tokenUsage: {
      input: number;
      output: number;
    };
  };
}

interface UseAIGenerationOptions {
  onProgress?: (progress: GenerationProgress) => void;
  onComplete?: (result: GenerationResult) => void;
  onError?: (error: Error) => void;
  timeout?: number;
}

interface UseAIGenerationReturn {
  status: GenerationStatus;
  progress: GenerationProgress | null;
  result: GenerationResult | null;
  error: Error | null;
  streamedContent: string;
  generate: (projectId: string) => Promise<void>;
  cancel: () => void;
  reset: () => void;
}

// ============================================
// 상수
// ============================================

const GENERATION_STAGES = [
  { stage: 'preparing', message: '생성 준비 중...', percentage: 0 },
  { stage: 'analyzing', message: '입력 분석 중...', percentage: 10 },
  { stage: 'structuring', message: '구조 설계 중...', percentage: 30 },
  { stage: 'generating', message: '콘텐츠 생성 중...', percentage: 50 },
  { stage: 'styling', message: '스타일 적용 중...', percentage: 80 },
  { stage: 'finalizing', message: '최종 검토 중...', percentage: 95 },
  { stage: 'completed', message: '생성 완료!', percentage: 100 },
];

const DEFAULT_TIMEOUT = 90000; // 90초

// ============================================
// Hook 구현
// ============================================

export function useAIGeneration(options: UseAIGenerationOptions = {}): UseAIGenerationReturn {
  const {
    onProgress,
    onComplete,
    onError,
    timeout = DEFAULT_TIMEOUT
  } = options;

  const [status, setStatus] = useState<GenerationStatus>('idle');
  const [progress, setProgress] = useState<GenerationProgress | null>(null);
  const [result, setResult] = useState<GenerationResult | null>(null);
  const [error, setError] = useState<Error | null>(null);
  const [streamedContent, setStreamedContent] = useState('');

  const abortControllerRef = useRef<AbortController | null>(null);
  const timeoutRef = useRef<NodeJS.Timeout | null>(null);
  const startTimeRef = useRef<number>(0);

  const { setGeneratedContent } = useProjectStore();
  const { incrementUsage } = useTokenStore();
  const { addToast } = useUIStore();

  // Cleanup
  useEffect(() => {
    return () => {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, []);

  // Progress 업데이트 헬퍼
  const updateProgress = useCallback((newProgress: GenerationProgress) => {
    setProgress(newProgress);
    onProgress?.(newProgress);
  }, [onProgress]);

  // 생성 함수
  const generate = useCallback(async (projectId: string) => {
    try {
      // 기존 요청 취소
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }

      // 상태 초기화
      setStatus('preparing');
      setError(null);
      setResult(null);
      setStreamedContent('');
      startTimeRef.current = Date.now();

      // AbortController 생성
      abortControllerRef.current = new AbortController();

      // 타임아웃 설정
      timeoutRef.current = setTimeout(() => {
        if (status !== 'completed' && status !== 'error') {
          abortControllerRef.current?.abort();
          setStatus('error');
          const timeoutError = new Error('생성 시간이 초과되었습니다.');
          setError(timeoutError);
          onError?.(timeoutError);
          addToast({
            type: 'error',
            title: '생성 시간 초과',
            message: '입력을 줄여서 다시 시도해주세요.',
          });
        }
      }, timeout);

      updateProgress({
        stage: 'preparing',
        percentage: 0,
        message: '생성 준비 중...',
      });

      // SSE 연결
      const response = await fetch('/api/ai/generate', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ projectId }),
        signal: abortControllerRef.current.signal,
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error?.message || '생성에 실패했습니다.');
      }

      if (!response.body) {
        throw new Error('스트리밍 응답을 받지 못했습니다.');
      }

      setStatus('generating');

      // SSE 스트림 처리
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = '';
      let accumulatedContent = '';

      while (true) {
        const { done, value } = await reader.read();

        if (done) break;

        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n');
        buffer = lines.pop() || '';

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const data = line.slice(6);

            if (data === '[DONE]') {
              continue;
            }

            try {
              const parsed = JSON.parse(data);

              switch (parsed.type) {
                case 'progress':
                  updateProgress({
                    stage: parsed.stage,
                    percentage: parsed.percentage,
                    message: parsed.message,
                    estimatedTimeRemaining: parsed.estimatedTime,
                  });
                  break;

                case 'content':
                  accumulatedContent += parsed.content;
                  setStreamedContent(accumulatedContent);
                  break;

                case 'complete':
                  setStatus('completed');
                  setResult(parsed.result);
                  setGeneratedContent(parsed.result);
                  incrementUsage(
                    parsed.result.metadata.tokenUsage.input +
                    parsed.result.metadata.tokenUsage.output
                  );
                  onComplete?.(parsed.result);
                  updateProgress({
                    stage: 'completed',
                    percentage: 100,
                    message: '생성 완료!',
                  });
                  addToast({
                    type: 'success',
                    title: '생성 완료',
                    message: '랜딩페이지가 성공적으로 생성되었습니다.',
                  });
                  break;

                case 'error':
                  throw new Error(parsed.message);
              }
            } catch (parseError) {
              // JSON 파싱 실패는 무시 (불완전한 청크일 수 있음)
              if (!(parseError instanceof SyntaxError)) {
                throw parseError;
              }
            }
          }
        }
      }
    } catch (err) {
      if ((err as Error).name === 'AbortError') {
        setStatus('cancelled');
        return;
      }

      const errorObj = err instanceof Error ? err : new Error('알 수 없는 오류');
      setStatus('error');
      setError(errorObj);
      onError?.(errorObj);
      addToast({
        type: 'error',
        title: '생성 실패',
        message: errorObj.message,
      });
    } finally {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
        timeoutRef.current = null;
      }
    }
  }, [
    status,
    timeout,
    updateProgress,
    setGeneratedContent,
    incrementUsage,
    onComplete,
    onError,
    addToast,
  ]);

  // 취소 함수
  const cancel = useCallback(() => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
      abortControllerRef.current = null;
    }
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = null;
    }
    setStatus('cancelled');
    addToast({
      type: 'info',
      title: '생성 취소됨',
      message: '랜딩페이지 생성이 취소되었습니다.',
    });
  }, [addToast]);

  // 리셋 함수
  const reset = useCallback(() => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
      abortControllerRef.current = null;
    }
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = null;
    }
    setStatus('idle');
    setProgress(null);
    setResult(null);
    setError(null);
    setStreamedContent('');
  }, []);

  return {
    status,
    progress,
    result,
    error,
    streamedContent,
    generate,
    cancel,
    reset,
  };
}
```

### 4.3 useAutoSave Hook

```typescript
// 파일: src/hooks/useAutoSave.ts
// 목적: 질문 답변 자동 저장 (debounce 적용)
// 의존성: @/stores/projectStore, @/lib/api

import { useCallback, useRef, useEffect } from 'react';
import { useProjectStore } from '@/stores/projectStore';
import { apiClient } from '@/lib/api/client';

// ============================================
// 타입 정의
// ============================================

interface UseAutoSaveOptions {
  delay?: number;
  onSaveStart?: () => void;
  onSaveSuccess?: () => void;
  onSaveError?: (error: Error) => void;
}

interface UseAutoSaveReturn {
  save: (questionId: number, answer: string) => void;
  saveImmediate: () => Promise<void>;
  isPending: boolean;
  lastSavedAt: string | null;
}

// ============================================
// 상수
// ============================================

const DEFAULT_DELAY = 3000; // 3초

// ============================================
// Hook 구현
// ============================================

export function useAutoSave(
  projectId: string,
  options: UseAutoSaveOptions = {}
): UseAutoSaveReturn {
  const {
    delay = DEFAULT_DELAY,
    onSaveStart,
    onSaveSuccess,
    onSaveError,
  } = options;

  const { saveAnswer, setSaving, lastSavedAt, currentProject } = useProjectStore();

  const timeoutRef = useRef<NodeJS.Timeout | null>(null);
  const pendingChangesRef = useRef<Map<number, string>>(new Map());
  const isPendingRef = useRef(false);

  // 서버에 저장
  const saveToServer = useCallback(async () => {
    if (pendingChangesRef.current.size === 0) return;

    const changes = Array.from(pendingChangesRef.current.entries());
    pendingChangesRef.current.clear();

    try {
      isPendingRef.current = true;
      setSaving(true);
      onSaveStart?.();

      await apiClient.patch(`/api/projects/${projectId}/answers`, {
        answers: changes.map(([questionId, answer]) => ({
          questionId,
          answer,
        })),
      });

      onSaveSuccess?.();
    } catch (error) {
      // 실패 시 변경사항 복구
      changes.forEach(([questionId, answer]) => {
        pendingChangesRef.current.set(questionId, answer);
      });
      onSaveError?.(error as Error);
    } finally {
      isPendingRef.current = false;
      setSaving(false);
    }
  }, [projectId, setSaving, onSaveStart, onSaveSuccess, onSaveError]);

  // Debounced save
  const save = useCallback((questionId: number, answer: string) => {
    // 로컬 상태 즉시 업데이트
    saveAnswer(questionId, answer);

    // 변경사항 누적
    pendingChangesRef.current.set(questionId, answer);

    // 기존 타이머 취소
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }

    // 새 타이머 설정
    timeoutRef.current = setTimeout(saveToServer, delay);
  }, [saveAnswer, saveToServer, delay]);

  // 즉시 저장
  const saveImmediate = useCallback(async () => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = null;
    }
    await saveToServer();
  }, [saveToServer]);

  // Cleanup & 언마운트 시 저장
  useEffect(() => {
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
      // 언마운트 시 미저장 데이터 저장
      if (pendingChangesRef.current.size > 0) {
        saveToServer();
      }
    };
  }, [saveToServer]);

  // 페이지 이탈 시 경고
  useEffect(() => {
    const handleBeforeUnload = (e: BeforeUnloadEvent) => {
      if (pendingChangesRef.current.size > 0) {
        e.preventDefault();
        e.returnValue = '';
        // 비동기 저장 시도
        saveToServer();
      }
    };

    window.addEventListener('beforeunload', handleBeforeUnload);
    return () => window.removeEventListener('beforeunload', handleBeforeUnload);
  }, [saveToServer]);

  return {
    save,
    saveImmediate,
    isPending: isPendingRef.current,
    lastSavedAt,
  };
}
```

### 4.4 useTokenUsage Hook

```typescript
// 파일: src/hooks/useTokenUsage.ts
// 목적: 토큰 사용량 조회 및 갱신
// 의존성: @/stores/tokenStore, @/lib/api

import { useCallback, useEffect, useRef } from 'react';
import { useTokenStore } from '@/stores/tokenStore';
import { apiClient } from '@/lib/api/client';

// ============================================
// 타입 정의
// ============================================

interface UseTokenUsageOptions {
  autoRefresh?: boolean;
  refreshInterval?: number;
}

interface UseTokenUsageReturn {
  usage: {
    daily: { used: number; limit: number; remaining: number };
    monthly: { used: number; limit: number; remaining: number };
  } | null;
  tier: 'free' | 'pro' | 'enterprise';
  isLoading: boolean;
  error: string | null;
  refresh: () => Promise<void>;
  canGenerate: (estimatedTokens?: number) => boolean;
  usagePercentage: { daily: number; monthly: number };
}

// ============================================
// 상수
// ============================================

const DEFAULT_REFRESH_INTERVAL = 60000; // 1분
const ESTIMATED_GENERATION_TOKENS = 5000;

// ============================================
// Hook 구현
// ============================================

export function useTokenUsage(
  options: UseTokenUsageOptions = {}
): UseTokenUsageReturn {
  const {
    autoRefresh = true,
    refreshInterval = DEFAULT_REFRESH_INTERVAL,
  } = options;

  const { usage, tier, isLoading, error, setUsage, setLoading, setError } = useTokenStore();
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  // 토큰 사용량 조회
  const refresh = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);

      const data = await apiClient.get<{
        usage: typeof usage;
        tier: typeof tier;
      }>('/api/ai/tokens');

      setUsage(data.usage!);
    } catch (err) {
      setError((err as Error).message);
    } finally {
      setLoading(false);
    }
  }, [setUsage, setLoading, setError]);

  // 초기 로드 및 자동 갱신
  useEffect(() => {
    refresh();

    if (autoRefresh) {
      intervalRef.current = setInterval(refresh, refreshInterval);
    }

    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, [refresh, autoRefresh, refreshInterval]);

  // 생성 가능 여부 확인
  const canGenerate = useCallback((estimatedTokens = ESTIMATED_GENERATION_TOKENS) => {
    if (!usage) return false;
    return usage.daily.remaining >= estimatedTokens;
  }, [usage]);

  // 사용률 계산
  const usagePercentage = {
    daily: usage ? Math.round((usage.daily.used / usage.daily.limit) * 100) : 0,
    monthly: usage ? Math.round((usage.monthly.used / usage.monthly.limit) * 100) : 0,
  };

  return {
    usage,
    tier,
    isLoading,
    error,
    refresh,
    canGenerate,
    usagePercentage,
  };
}
```

---

## 5. UI 컴포넌트

### 5.1 컴포넌트 디렉토리 구조

```
src/components/
├── ui/                          # 기본 UI 컴포넌트 (shadcn/ui 기반)
│   ├── button.tsx
│   ├── input.tsx
│   ├── select.tsx
│   ├── textarea.tsx
│   ├── checkbox.tsx
│   ├── radio-group.tsx
│   ├── switch.tsx
│   ├── slider.tsx
│   ├── dialog.tsx
│   ├── alert-dialog.tsx
│   ├── dropdown-menu.tsx
│   ├── popover.tsx
│   ├── tooltip.tsx
│   ├── toast.tsx
│   ├── progress.tsx
│   ├── skeleton.tsx
│   ├── avatar.tsx
│   ├── badge.tsx
│   ├── card.tsx
│   ├── tabs.tsx
│   ├── accordion.tsx
│   └── form.tsx
│
├── layout/                      # 레이아웃 컴포넌트
│   ├── Header.tsx
│   ├── Sidebar.tsx
│   ├── Footer.tsx
│   ├── MobileNav.tsx
│   └── PageContainer.tsx
│
├── auth/                        # 인증 관련 컴포넌트
│   ├── LoginForm.tsx
│   ├── SignupForm.tsx
│   ├── ForgotPasswordForm.tsx
│   ├── ResetPasswordForm.tsx
│   ├── AuthGuard.tsx
│   └── ApprovalPending.tsx
│
├── dashboard/                   # 대시보드 컴포넌트
│   ├── ProjectCard.tsx
│   ├── ProjectList.tsx
│   ├── StatsCard.tsx
│   ├── TokenUsageCard.tsx
│   ├── RecentActivity.tsx
│   └── QuickActions.tsx
│
├── project/                     # 프로젝트 관련 컴포넌트
│   ├── QuestionForm.tsx
│   ├── QuestionProgress.tsx
│   ├── AnswerInput.tsx
│   ├── PhaseNavigation.tsx
│   ├── ProjectSettings.tsx
│   └── TemplateSelector.tsx
│
├── generator/                   # AI 생성 관련 컴포넌트
│   ├── GenerationProgress.tsx
│   ├── GenerationResult.tsx
│   ├── StreamingContent.tsx
│   └── ErrorRetry.tsx
│
├── editor/                      # 에디터 컴포넌트
│   ├── TipTapEditor.tsx
│   ├── SectionEditor.tsx
│   ├── ImageUploader.tsx
│   ├── EditorToolbar.tsx
│   ├── PreviewPanel.tsx
│   └── DeviceToggle.tsx
│
├── common/                      # 공통 컴포넌트
│   ├── LoadingSpinner.tsx
│   ├── ErrorBoundary.tsx
│   ├── EmptyState.tsx
│   ├── ConfirmDialog.tsx
│   ├── SearchInput.tsx
│   └── Pagination.tsx
│
└── providers/                   # Context Providers
    ├── AuthProvider.tsx
    ├── ThemeProvider.tsx
    ├── ToastProvider.tsx
    └── QueryProvider.tsx
```

### 5.2 Button 컴포넌트

```typescript
// 파일: src/components/ui/button.tsx
// 목적: 재사용 가능한 버튼 컴포넌트
// 의존성: class-variance-authority, tailwind-merge

import * as React from 'react';
import { Slot } from '@radix-ui/react-slot';
import { cva, type VariantProps } from 'class-variance-authority';
import { cn } from '@/lib/utils';
import { Loader2 } from 'lucide-react';

// ============================================
// 스타일 정의
// ============================================

const buttonVariants = cva(
  'inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50',
  {
    variants: {
      variant: {
        default: 'bg-primary text-primary-foreground hover:bg-primary/90',
        destructive: 'bg-destructive text-destructive-foreground hover:bg-destructive/90',
        outline: 'border border-input bg-background hover:bg-accent hover:text-accent-foreground',
        secondary: 'bg-secondary text-secondary-foreground hover:bg-secondary/80',
        ghost: 'hover:bg-accent hover:text-accent-foreground',
        link: 'text-primary underline-offset-4 hover:underline',
      },
      size: {
        default: 'h-10 px-4 py-2',
        sm: 'h-9 rounded-md px-3',
        lg: 'h-11 rounded-md px-8',
        xl: 'h-12 rounded-md px-10 text-base',
        icon: 'h-10 w-10',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
);

// ============================================
// 타입 정의
// ============================================

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
  isLoading?: boolean;
  leftIcon?: React.ReactNode;
  rightIcon?: React.ReactNode;
}

// ============================================
// 컴포넌트 구현
// ============================================

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  (
    {
      className,
      variant,
      size,
      asChild = false,
      isLoading = false,
      leftIcon,
      rightIcon,
      children,
      disabled,
      ...props
    },
    ref
  ) => {
    const Comp = asChild ? Slot : 'button';

    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        disabled={disabled || isLoading}
        {...props}
      >
        {isLoading ? (
          <>
            <Loader2 className="mr-2 h-4 w-4 animate-spin" />
            {children}
          </>
        ) : (
          <>
            {leftIcon && <span className="mr-2">{leftIcon}</span>}
            {children}
            {rightIcon && <span className="ml-2">{rightIcon}</span>}
          </>
        )}
      </Comp>
    );
  }
);

Button.displayName = 'Button';

export { Button, buttonVariants };
```

### 5.3 QuestionForm 컴포넌트

```typescript
// 파일: src/components/project/QuestionForm.tsx
// 목적: 40개 질문 답변 폼 컴포넌트
// 의존성: @/hooks/useAutoSave, @/stores/projectStore, @/components/ui

'use client';

import { useState, useCallback, useMemo } from 'react';
import { useAutoSave } from '@/hooks/useAutoSave';
import { useProjectStore, useCurrentQuestionIndex, useProgress } from '@/stores/projectStore';
import { Button } from '@/components/ui/button';
import { Textarea } from '@/components/ui/textarea';
import { Progress } from '@/components/ui/progress';
import { Card, CardContent, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import {
  ChevronLeft,
  ChevronRight,
  Save,
  HelpCircle,
  CheckCircle2,
  AlertCircle,
} from 'lucide-react';
import { cn } from '@/lib/utils';

// ============================================
// 타입 정의
// ============================================

interface Question {
  id: number;
  phase: number;
  step: number;
  category: string;
  question: string;
  helpText: string;
  example: string;
  minLength?: number;
  maxLength: number;
  required: boolean;
}

interface QuestionFormProps {
  projectId: string;
  questions: Question[];
  onComplete?: () => void;
}

// ============================================
// 컴포넌트 구현
// ============================================

export function QuestionForm({ projectId, questions, onComplete }: QuestionFormProps) {
  const [showHelp, setShowHelp] = useState(false);

  const {
    currentProject,
    setCurrentQuestionIndex,
  } = useProjectStore();

  const currentIndex = useCurrentQuestionIndex();
  const progress = useProgress();

  const { save, saveImmediate, isPending, lastSavedAt } = useAutoSave(projectId, {
    delay: 3000,
  });

  // 현재 질문
  const currentQuestion = useMemo(() =>
    questions[currentIndex],
    [questions, currentIndex]
  );

  // 현재 답변 가져오기
  const currentAnswer = useMemo(() => {
    const answer = currentProject?.answers.find(
      (a) => a.questionId === currentQuestion.id
    );
    return answer?.answer || '';
  }, [currentProject?.answers, currentQuestion.id]);

  // 답변 변경 핸들러
  const handleAnswerChange = useCallback((value: string) => {
    if (value.length <= currentQuestion.maxLength) {
      save(currentQuestion.id, value);
    }
  }, [currentQuestion.id, currentQuestion.maxLength, save]);

  // 이전 질문
  const handlePrevious = useCallback(() => {
    if (currentIndex > 0) {
      setCurrentQuestionIndex(currentIndex - 1);
    }
  }, [currentIndex, setCurrentQuestionIndex]);

  // 다음 질문
  const handleNext = useCallback(async () => {
    await saveImmediate();

    if (currentIndex < questions.length - 1) {
      setCurrentQuestionIndex(currentIndex + 1);
    } else {
      // 마지막 질문인 경우 완료 콜백
      onComplete?.();
    }
  }, [currentIndex, questions.length, setCurrentQuestionIndex, saveImmediate, onComplete]);

  // 답변 완료 여부
  const isAnswered = currentAnswer.length >= (currentQuestion.minLength || 1);
  const isLastQuestion = currentIndex === questions.length - 1;

  // Phase 색상
  const phaseColors: Record<number, string> = {
    1: 'bg-blue-100 text-blue-800',
    2: 'bg-green-100 text-green-800',
    3: 'bg-yellow-100 text-yellow-800',
    4: 'bg-purple-100 text-purple-800',
    5: 'bg-pink-100 text-pink-800',
    6: 'bg-orange-100 text-orange-800',
  };

  return (
    <div className="max-w-3xl mx-auto space-y-6">
      {/* 진행률 */}
      <div className="space-y-2">
        <div className="flex justify-between text-sm text-muted-foreground">
          <span>진행률</span>
          <span>{currentIndex + 1} / {questions.length} ({progress}%)</span>
        </div>
        <Progress value={progress} className="h-2" />
      </div>

      {/* 질문 카드 */}
      <Card>
        <CardHeader>
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <Badge className={phaseColors[currentQuestion.phase]}>
                Phase {currentQuestion.phase}
              </Badge>
              <Badge variant="outline">
                {currentQuestion.category}
              </Badge>
            </div>
            <Button
              variant="ghost"
              size="sm"
              onClick={() => setShowHelp(!showHelp)}
            >
              <HelpCircle className="h-4 w-4 mr-1" />
              도움말
            </Button>
          </div>
          <CardTitle className="text-xl mt-4">
            Q{currentQuestion.id}. {currentQuestion.question}
          </CardTitle>
        </CardHeader>

        <CardContent className="space-y-4">
          {/* 도움말 */}
          {showHelp && (
            <div className="bg-muted rounded-lg p-4 space-y-3">
              <div>
                <p className="text-sm font-medium">왜 이 질문이 중요한가요?</p>
                <p className="text-sm text-muted-foreground mt-1">
                  {currentQuestion.helpText}
                </p>
              </div>
              <div>
                <p className="text-sm font-medium">예시 답변</p>
                <p className="text-sm text-muted-foreground mt-1 italic">
                  "{currentQuestion.example}"
                </p>
              </div>
            </div>
          )}

          {/* 답변 입력 */}
          <div className="space-y-2">
            <Textarea
              value={currentAnswer}
              onChange={(e) => handleAnswerChange(e.target.value)}
              placeholder="답변을 입력해주세요..."
              className="min-h-[150px] resize-none"
            />
            <div className="flex justify-between text-xs text-muted-foreground">
              <span
                className={cn(
                  currentQuestion.minLength &&
                  currentAnswer.length < currentQuestion.minLength &&
                  'text-destructive'
                )}
              >
                {currentQuestion.minLength
                  ? `최소 ${currentQuestion.minLength}자`
                  : ''}
              </span>
              <span
                className={cn(
                  currentAnswer.length > currentQuestion.maxLength * 0.9 &&
                  'text-warning'
                )}
              >
                {currentAnswer.length} / {currentQuestion.maxLength}자
              </span>
            </div>
          </div>
        </CardContent>

        <CardFooter className="flex justify-between">
          <div className="flex items-center gap-2 text-sm text-muted-foreground">
            {isPending ? (
              <>
                <Save className="h-4 w-4 animate-pulse" />
                저장 중...
              </>
            ) : lastSavedAt ? (
              <>
                <CheckCircle2 className="h-4 w-4 text-green-500" />
                자동 저장됨
              </>
            ) : null}
          </div>

          <div className="flex gap-2">
            <Button
              variant="outline"
              onClick={handlePrevious}
              disabled={currentIndex === 0}
            >
              <ChevronLeft className="h-4 w-4 mr-1" />
              이전
            </Button>
            <Button onClick={handleNext}>
              {isLastQuestion ? '완료' : '다음'}
              {!isLastQuestion && <ChevronRight className="h-4 w-4 ml-1" />}
            </Button>
          </div>
        </CardFooter>
      </Card>

      {/* 질문 네비게이션 */}
      <div className="flex flex-wrap gap-1 justify-center">
        {questions.map((q, index) => {
          const answer = currentProject?.answers.find(
            (a) => a.questionId === q.id
          );
          const hasAnswer = answer && answer.answer.length > 0;

          return (
            <button
              key={q.id}
              onClick={() => setCurrentQuestionIndex(index)}
              className={cn(
                'w-8 h-8 rounded-md text-xs font-medium transition-colors',
                index === currentIndex
                  ? 'bg-primary text-primary-foreground'
                  : hasAnswer
                  ? 'bg-green-100 text-green-800 hover:bg-green-200'
                  : 'bg-muted hover:bg-muted/80'
              )}
            >
              {q.id}
            </button>
          );
        })}
      </div>
    </div>
  );
}
```

### 5.4 GenerationProgress 컴포넌트

```typescript
// 파일: src/components/generator/GenerationProgress.tsx
// 목적: AI 생성 진행 상태 표시 컴포넌트
// 의존성: @/hooks/useAIGeneration, framer-motion

'use client';

import { motion, AnimatePresence } from 'framer-motion';
import { Progress } from '@/components/ui/progress';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import {
  Loader2,
  CheckCircle2,
  XCircle,
  Sparkles,
  Brain,
  Wand2,
  Palette,
  FileCheck,
} from 'lucide-react';
import type { GenerationStatus, GenerationProgress as Progress } from '@/hooks/useAIGeneration';

// ============================================
// 타입 정의
// ============================================

interface GenerationProgressProps {
  status: GenerationStatus;
  progress: Progress | null;
  onCancel: () => void;
  onRetry?: () => void;
  error?: Error | null;
}

// ============================================
// 상수
// ============================================

const STAGE_ICONS: Record<string, React.ComponentType<{ className?: string }>> = {
  preparing: Sparkles,
  analyzing: Brain,
  structuring: Wand2,
  generating: Wand2,
  styling: Palette,
  finalizing: FileCheck,
  completed: CheckCircle2,
};

const STAGE_MESSAGES: Record<string, string> = {
  preparing: '생성을 준비하고 있습니다...',
  analyzing: '입력한 정보를 분석하고 있습니다...',
  structuring: '랜딩페이지 구조를 설계하고 있습니다...',
  generating: '마그네틱 콘텐츠를 생성하고 있습니다...',
  styling: '스타일을 적용하고 있습니다...',
  finalizing: '최종 검토 중입니다...',
  completed: '생성이 완료되었습니다!',
};

// ============================================
// 컴포넌트 구현
// ============================================

export function GenerationProgress({
  status,
  progress,
  onCancel,
  onRetry,
  error,
}: GenerationProgressProps) {
  const currentStage = progress?.stage || 'preparing';
  const Icon = STAGE_ICONS[currentStage] || Loader2;
  const percentage = progress?.percentage || 0;

  // 예상 남은 시간 포맷팅
  const formatTime = (seconds?: number) => {
    if (!seconds) return null;
    if (seconds < 60) return `약 ${seconds}초`;
    return `약 ${Math.ceil(seconds / 60)}분`;
  };

  // 에러 상태
  if (status === 'error') {
    return (
      <Card className="max-w-lg mx-auto">
        <CardHeader>
          <div className="flex items-center justify-center">
            <XCircle className="h-16 w-16 text-destructive" />
          </div>
          <CardTitle className="text-center text-destructive">
            생성 실패
          </CardTitle>
        </CardHeader>
        <CardContent className="text-center space-y-4">
          <p className="text-muted-foreground">
            {error?.message || '알 수 없는 오류가 발생했습니다.'}
          </p>
          <div className="bg-muted rounded-lg p-4 text-sm text-left">
            <p className="font-medium mb-2">문제가 지속되면:</p>
            <ul className="list-disc list-inside space-y-1 text-muted-foreground">
              <li>입력한 내용을 줄여보세요</li>
              <li>복잡한 요청을 단순화해보세요</li>
              <li>잠시 후 다시 시도해보세요</li>
            </ul>
          </div>
        </CardContent>
        <CardFooter className="flex justify-center gap-4">
          <Button variant="outline" onClick={onCancel}>
            돌아가기
          </Button>
          {onRetry && (
            <Button onClick={onRetry}>
              다시 시도
            </Button>
          )}
        </CardFooter>
      </Card>
    );
  }

  // 완료 상태
  if (status === 'completed') {
    return (
      <motion.div
        initial={{ scale: 0.9, opacity: 0 }}
        animate={{ scale: 1, opacity: 1 }}
        className="text-center space-y-4"
      >
        <motion.div
          initial={{ scale: 0 }}
          animate={{ scale: 1 }}
          transition={{ delay: 0.2, type: 'spring', stiffness: 200 }}
        >
          <CheckCircle2 className="h-20 w-20 text-green-500 mx-auto" />
        </motion.div>
        <h2 className="text-2xl font-bold">생성 완료!</h2>
        <p className="text-muted-foreground">
          랜딩페이지가 성공적으로 생성되었습니다.
        </p>
      </motion.div>
    );
  }

  // 진행 중 상태
  return (
    <Card className="max-w-lg mx-auto">
      <CardHeader>
        <motion.div
          className="flex items-center justify-center"
          animate={{ rotate: status === 'generating' ? 360 : 0 }}
          transition={{ duration: 2, repeat: Infinity, ease: 'linear' }}
        >
          <div className="relative">
            <div className="absolute inset-0 bg-primary/20 rounded-full blur-xl" />
            <Icon className="h-16 w-16 text-primary relative z-10" />
          </div>
        </motion.div>
        <CardTitle className="text-center">
          AI 랜딩페이지 생성 중
        </CardTitle>
      </CardHeader>

      <CardContent className="space-y-6">
        {/* 진행률 바 */}
        <div className="space-y-2">
          <Progress value={percentage} className="h-3" />
          <div className="flex justify-between text-sm text-muted-foreground">
            <span>{progress?.message || STAGE_MESSAGES[currentStage]}</span>
            <span>{percentage}%</span>
          </div>
        </div>

        {/* 단계 표시 */}
        <div className="space-y-2">
          {Object.entries(STAGE_MESSAGES).map(([stage, message], index) => {
            const stageIndex = Object.keys(STAGE_MESSAGES).indexOf(currentStage);
            const thisIndex = index;
            const isCompleted = thisIndex < stageIndex;
            const isCurrent = stage === currentStage;
            const StageIcon = STAGE_ICONS[stage];

            if (stage === 'completed') return null;

            return (
              <motion.div
                key={stage}
                initial={false}
                animate={{
                  opacity: isCompleted || isCurrent ? 1 : 0.5,
                }}
                className="flex items-center gap-3"
              >
                <div
                  className={`
                    w-6 h-6 rounded-full flex items-center justify-center
                    ${isCompleted ? 'bg-green-500 text-white' : ''}
                    ${isCurrent ? 'bg-primary text-primary-foreground' : ''}
                    ${!isCompleted && !isCurrent ? 'bg-muted' : ''}
                  `}
                >
                  {isCompleted ? (
                    <CheckCircle2 className="h-4 w-4" />
                  ) : isCurrent ? (
                    <Loader2 className="h-3 w-3 animate-spin" />
                  ) : (
                    <StageIcon className="h-3 w-3" />
                  )}
                </div>
                <span
                  className={`text-sm ${
                    isCurrent ? 'font-medium' : 'text-muted-foreground'
                  }`}
                >
                  {message}
                </span>
              </motion.div>
            );
          })}
        </div>

        {/* 예상 시간 */}
        {progress?.estimatedTimeRemaining && (
          <p className="text-center text-sm text-muted-foreground">
            예상 남은 시간: {formatTime(progress.estimatedTimeRemaining)}
          </p>
        )}

        {/* 안내 메시지 */}
        <div className="bg-muted rounded-lg p-4 text-sm text-center text-muted-foreground">
          <Sparkles className="h-4 w-4 inline-block mr-1" />
          복잡한 내용은 최대 90초까지 소요될 수 있습니다.
        </div>
      </CardContent>

      <CardFooter className="flex justify-center">
        <Button variant="outline" onClick={onCancel}>
          생성 취소
        </Button>
      </CardFooter>
    </Card>
  );
}
```

### 5.5 TipTap 에디터 컴포넌트

```typescript
// 파일: src/components/editor/TipTapEditor.tsx
// 목적: WYSIWYG 리치 텍스트 에디터
// 의존성: @tiptap/react, @tiptap/starter-kit

'use client';

import { useCallback, useEffect } from 'react';
import { useEditor, EditorContent, Editor } from '@tiptap/react';
import StarterKit from '@tiptap/starter-kit';
import Image from '@tiptap/extension-image';
import Link from '@tiptap/extension-link';
import Placeholder from '@tiptap/extension-placeholder';
import TextAlign from '@tiptap/extension-text-align';
import Underline from '@tiptap/extension-underline';
import { Button } from '@/components/ui/button';
import {
  Bold,
  Italic,
  Underline as UnderlineIcon,
  Strikethrough,
  List,
  ListOrdered,
  AlignLeft,
  AlignCenter,
  AlignRight,
  Link as LinkIcon,
  Image as ImageIcon,
  Undo,
  Redo,
  Heading1,
  Heading2,
  Heading3,
  Quote,
  Code,
  Minus,
} from 'lucide-react';
import { cn } from '@/lib/utils';

// ============================================
// 타입 정의
// ============================================

interface TipTapEditorProps {
  content: string;
  onChange: (content: string) => void;
  placeholder?: string;
  editable?: boolean;
  className?: string;
  onImageUpload?: (file: File) => Promise<string>;
}

interface ToolbarButtonProps {
  onClick: () => void;
  isActive?: boolean;
  disabled?: boolean;
  children: React.ReactNode;
  title: string;
}

// ============================================
// 툴바 버튼 컴포넌트
// ============================================

function ToolbarButton({
  onClick,
  isActive,
  disabled,
  children,
  title,
}: ToolbarButtonProps) {
  return (
    <Button
      type="button"
      variant="ghost"
      size="sm"
      onClick={onClick}
      disabled={disabled}
      className={cn(
        'h-8 w-8 p-0',
        isActive && 'bg-muted'
      )}
      title={title}
    >
      {children}
    </Button>
  );
}

// ============================================
// 툴바 컴포넌트
// ============================================

function EditorToolbar({
  editor,
  onImageUpload
}: {
  editor: Editor | null;
  onImageUpload?: (file: File) => Promise<string>;
}) {
  if (!editor) return null;

  const addLink = useCallback(() => {
    const url = window.prompt('URL을 입력하세요:');
    if (url) {
      editor.chain().focus().setLink({ href: url }).run();
    }
  }, [editor]);

  const addImage = useCallback(async () => {
    if (onImageUpload) {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'image/*';
      input.onchange = async (e) => {
        const file = (e.target as HTMLInputElement).files?.[0];
        if (file) {
          try {
            const url = await onImageUpload(file);
            editor.chain().focus().setImage({ src: url }).run();
          } catch (error) {
            console.error('Image upload failed:', error);
          }
        }
      };
      input.click();
    } else {
      const url = window.prompt('이미지 URL을 입력하세요:');
      if (url) {
        editor.chain().focus().setImage({ src: url }).run();
      }
    }
  }, [editor, onImageUpload]);

  return (
    <div className="border-b p-2 flex flex-wrap gap-1">
      {/* 실행 취소 / 다시 실행 */}
      <div className="flex gap-1 border-r pr-2 mr-2">
        <ToolbarButton
          onClick={() => editor.chain().focus().undo().run()}
          disabled={!editor.can().undo()}
          title="실행 취소"
        >
          <Undo className="h-4 w-4" />
        </ToolbarButton>
        <ToolbarButton
          onClick={() => editor.chain().focus().redo().run()}
          disabled={!editor.can().redo()}
          title="다시 실행"
        >
          <Redo className="h-4 w-4" />
        </ToolbarButton>
      </div>

      {/* 제목 */}
      <div className="flex gap-1 border-r pr-2 mr-2">
        <ToolbarButton
          onClick={() => editor.chain().focus().toggleHeading({ level: 1 }).run()}
          isActive={editor.isActive('heading', { level: 1 })}
          title="제목 1"
        >
          <Heading1 className="h-4 w-4" />
        </ToolbarButton>
        <ToolbarButton
          onClick={() => editor.chain().focus().toggleHeading({ level: 2 }).run()}
          isActive={editor.isActive('heading', { level: 2 })}
          title="제목 2"
        >
          <Heading2 className="h-4 w-4" />
        </ToolbarButton>
        <ToolbarButton
          onClick={() => editor.chain().focus().toggleHeading({ level: 3 }).run()}
          isActive={editor.isActive('heading', { level: 3 })}
          title="제목 3"
        >
          <Heading3 className="h-4 w-4" />
        </ToolbarButton>
      </div>

      {/* 텍스트 스타일 */}
      <div className="flex gap-1 border-r pr-2 mr-2">
        <ToolbarButton
          onClick={() => editor.chain().focus().toggleBold().run()}
          isActive={editor.isActive('bold')}
          title="굵게"
        >
          <Bold className="h-4 w-4" />
        </ToolbarButton>
        <ToolbarButton
          onClick={() => editor.chain().focus().toggleItalic().run()}
          isActive={editor.isActive('italic')}
          title="기울임"
        >
          <Italic className="h-4 w-4" />
        </ToolbarButton>
        <ToolbarButton
          onClick={() => editor.chain().focus().toggleUnderline().run()}
          isActive={editor.isActive('underline')}
          title="밑줄"
        >
          <UnderlineIcon className="h-4 w-4" />
        </ToolbarButton>
        <ToolbarButton
          onClick={() => editor.chain().focus().toggleStrike().run()}
          isActive={editor.isActive('strike')}
          title="취소선"
        >
          <Strikethrough className="h-4 w-4" />
        </ToolbarButton>
      </div>

      {/* 정렬 */}
      <div className="flex gap-1 border-r pr-2 mr-2">
        <ToolbarButton
          onClick={() => editor.chain().focus().setTextAlign('left').run()}
          isActive={editor.isActive({ textAlign: 'left' })}
          title="왼쪽 정렬"
        >
          <AlignLeft className="h-4 w-4" />
        </ToolbarButton>
        <ToolbarButton
          onClick={() => editor.chain().focus().setTextAlign('center').run()}
          isActive={editor.isActive({ textAlign: 'center' })}
          title="가운데 정렬"
        >
          <AlignCenter className="h-4 w-4" />
        </ToolbarButton>
        <ToolbarButton
          onClick={() => editor.chain().focus().setTextAlign('right').run()}
          isActive={editor.isActive({ textAlign: 'right' })}
          title="오른쪽 정렬"
        >
          <AlignRight className="h-4 w-4" />
        </ToolbarButton>
      </div>

      {/* 리스트 */}
      <div className="flex gap-1 border-r pr-2 mr-2">
        <ToolbarButton
          onClick={() => editor.chain().focus().toggleBulletList().run()}
          isActive={editor.isActive('bulletList')}
          title="글머리 기호"
        >
          <List className="h-4 w-4" />
        </ToolbarButton>
        <ToolbarButton
          onClick={() => editor.chain().focus().toggleOrderedList().run()}
          isActive={editor.isActive('orderedList')}
          title="번호 매기기"
        >
          <ListOrdered className="h-4 w-4" />
        </ToolbarButton>
      </div>

      {/* 기타 */}
      <div className="flex gap-1">
        <ToolbarButton
          onClick={() => editor.chain().focus().toggleBlockquote().run()}
          isActive={editor.isActive('blockquote')}
          title="인용문"
        >
          <Quote className="h-4 w-4" />
        </ToolbarButton>
        <ToolbarButton
          onClick={() => editor.chain().focus().toggleCodeBlock().run()}
          isActive={editor.isActive('codeBlock')}
          title="코드 블록"
        >
          <Code className="h-4 w-4" />
        </ToolbarButton>
        <ToolbarButton
          onClick={() => editor.chain().focus().setHorizontalRule().run()}
          title="구분선"
        >
          <Minus className="h-4 w-4" />
        </ToolbarButton>
        <ToolbarButton
          onClick={addLink}
          isActive={editor.isActive('link')}
          title="링크"
        >
          <LinkIcon className="h-4 w-4" />
        </ToolbarButton>
        <ToolbarButton
          onClick={addImage}
          title="이미지"
        >
          <ImageIcon className="h-4 w-4" />
        </ToolbarButton>
      </div>
    </div>
  );
}

// ============================================
// 메인 에디터 컴포넌트
// ============================================

export function TipTapEditor({
  content,
  onChange,
  placeholder = '내용을 입력하세요...',
  editable = true,
  className,
  onImageUpload,
}: TipTapEditorProps) {
  const editor = useEditor({
    extensions: [
      StarterKit.configure({
        heading: {
          levels: [1, 2, 3],
        },
      }),
      Image.configure({
        HTMLAttributes: {
          class: 'max-w-full h-auto rounded-lg',
        },
      }),
      Link.configure({
        openOnClick: false,
        HTMLAttributes: {
          class: 'text-primary underline',
        },
      }),
      Placeholder.configure({
        placeholder,
      }),
      TextAlign.configure({
        types: ['heading', 'paragraph'],
      }),
      Underline,
    ],
    content,
    editable,
    onUpdate: ({ editor }) => {
      onChange(editor.getHTML());
    },
    editorProps: {
      attributes: {
        class: 'prose prose-sm max-w-none focus:outline-none min-h-[200px] p-4',
      },
    },
  });

  // content prop 변경 시 에디터 업데이트
  useEffect(() => {
    if (editor && content !== editor.getHTML()) {
      editor.commands.setContent(content);
    }
  }, [content, editor]);

  return (
    <div className={cn('border rounded-lg overflow-hidden', className)}>
      {editable && (
        <EditorToolbar editor={editor} onImageUpload={onImageUpload} />
      )}
      <EditorContent editor={editor} />
    </div>
  );
}
```

---

## 6. API 클라이언트

### 6.1 Fetch Wrapper

```typescript
// 파일: src/lib/api/client.ts
// 목적: 타입 안전한 API 클라이언트 (자동 토큰 갱신 포함)
// 의존성: @/stores/authStore

import { useAuthStore } from '@/stores/authStore';

// ============================================
// 타입 정의
// ============================================

interface APIError extends Error {
  status: number;
  code: string;
  details?: Record<string, unknown>;
}

interface RequestConfig extends RequestInit {
  params?: Record<string, string | number | boolean>;
  timeout?: number;
}

interface APIResponse<T = unknown> {
  data?: T;
  error?: {
    code: string;
    message: string;
    details?: Record<string, unknown>;
  };
  meta?: {
    timestamp: string;
    requestId: string;
  };
}

// ============================================
// 상수
// ============================================

const DEFAULT_TIMEOUT = 30000; // 30초
const MAX_RETRIES = 3;
const RETRY_DELAY = 1000;

// ============================================
// 유틸리티 함수
// ============================================

function buildUrl(endpoint: string, params?: Record<string, string | number | boolean>): string {
  const url = new URL(endpoint, window.location.origin);

  if (params) {
    Object.entries(params).forEach(([key, value]) => {
      url.searchParams.append(key, String(value));
    });
  }

  return url.toString();
}

function createAPIError(status: number, code: string, message: string, details?: Record<string, unknown>): APIError {
  const error = new Error(message) as APIError;
  error.status = status;
  error.code = code;
  error.details = details;
  return error;
}

async function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// ============================================
// API 클라이언트 클래스
// ============================================

class APIClient {
  private baseUrl: string;
  private isRefreshing: boolean = false;
  private refreshPromise: Promise<string | null> | null = null;

  constructor(baseUrl: string = '') {
    this.baseUrl = baseUrl;
  }

  // 요청 헤더 생성
  private getHeaders(): Headers {
    const headers = new Headers({
      'Content-Type': 'application/json',
    });

    const accessToken = useAuthStore.getState().accessToken;
    if (accessToken) {
      headers.set('Authorization', `Bearer ${accessToken}`);
    }

    return headers;
  }

  // 토큰 갱신
  private async refreshToken(): Promise<string | null> {
    // 이미 갱신 중이면 기존 Promise 반환
    if (this.isRefreshing && this.refreshPromise) {
      return this.refreshPromise;
    }

    this.isRefreshing = true;
    this.refreshPromise = (async () => {
      try {
        const response = await fetch('/api/auth/refresh', {
          method: 'POST',
          credentials: 'include', // HttpOnly 쿠키 포함
        });

        if (!response.ok) {
          throw new Error('Token refresh failed');
        }

        const data = await response.json();
        useAuthStore.getState().setAccessToken(data.accessToken);
        return data.accessToken;
      } catch (error) {
        useAuthStore.getState().logout();
        window.location.href = '/login';
        return null;
      } finally {
        this.isRefreshing = false;
        this.refreshPromise = null;
      }
    })();

    return this.refreshPromise;
  }

  // 기본 요청 메서드
  private async request<T>(
    endpoint: string,
    config: RequestConfig = {}
  ): Promise<T> {
    const { params, timeout = DEFAULT_TIMEOUT, ...fetchConfig } = config;
    const url = buildUrl(this.baseUrl + endpoint, params);

    // AbortController로 타임아웃 구현
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);

    try {
      const response = await fetch(url, {
        ...fetchConfig,
        headers: this.getHeaders(),
        signal: controller.signal,
        credentials: 'include',
      });

      clearTimeout(timeoutId);

      // 401 에러 시 토큰 갱신 시도
      if (response.status === 401) {
        const newToken = await this.refreshToken();

        if (newToken) {
          // 토큰 갱신 성공 시 재요청
          const retryResponse = await fetch(url, {
            ...fetchConfig,
            headers: this.getHeaders(),
            credentials: 'include',
          });

          return this.handleResponse<T>(retryResponse);
        }

        throw createAPIError(401, 'ERR_AUTH_1003', '세션이 만료되었습니다.');
      }

      return this.handleResponse<T>(response);
    } catch (error) {
      clearTimeout(timeoutId);

      if ((error as Error).name === 'AbortError') {
        throw createAPIError(408, 'ERR_NET_9002', '요청 시간이 초과되었습니다.');
      }

      throw error;
    }
  }

  // 응답 처리
  private async handleResponse<T>(response: Response): Promise<T> {
    const contentType = response.headers.get('content-type');

    let data: APIResponse<T>;

    if (contentType?.includes('application/json')) {
      data = await response.json();
    } else {
      data = { data: (await response.text()) as unknown as T };
    }

    if (!response.ok) {
      throw createAPIError(
        response.status,
        data.error?.code || 'ERR_UNKNOWN',
        data.error?.message || '요청에 실패했습니다.',
        data.error?.details
      );
    }

    return data.data as T;
  }

  // HTTP 메서드들
  async get<T>(endpoint: string, config?: RequestConfig): Promise<T> {
    return this.request<T>(endpoint, { ...config, method: 'GET' });
  }

  async post<T>(endpoint: string, body?: unknown, config?: RequestConfig): Promise<T> {
    return this.request<T>(endpoint, {
      ...config,
      method: 'POST',
      body: body ? JSON.stringify(body) : undefined,
    });
  }

  async put<T>(endpoint: string, body?: unknown, config?: RequestConfig): Promise<T> {
    return this.request<T>(endpoint, {
      ...config,
      method: 'PUT',
      body: body ? JSON.stringify(body) : undefined,
    });
  }

  async patch<T>(endpoint: string, body?: unknown, config?: RequestConfig): Promise<T> {
    return this.request<T>(endpoint, {
      ...config,
      method: 'PATCH',
      body: body ? JSON.stringify(body) : undefined,
    });
  }

  async delete<T>(endpoint: string, config?: RequestConfig): Promise<T> {
    return this.request<T>(endpoint, { ...config, method: 'DELETE' });
  }

  // 파일 업로드
  async upload<T>(
    endpoint: string,
    file: File,
    additionalData?: Record<string, string>,
    config?: RequestConfig
  ): Promise<T> {
    const formData = new FormData();
    formData.append('file', file);

    if (additionalData) {
      Object.entries(additionalData).forEach(([key, value]) => {
        formData.append(key, value);
      });
    }

    const headers = new Headers();
    const accessToken = useAuthStore.getState().accessToken;
    if (accessToken) {
      headers.set('Authorization', `Bearer ${accessToken}`);
    }
    // Content-Type은 브라우저가 자동 설정 (boundary 포함)

    const response = await fetch(this.baseUrl + endpoint, {
      method: 'POST',
      headers,
      body: formData,
      credentials: 'include',
      ...config,
    });

    return this.handleResponse<T>(response);
  }
}

// ============================================
// 싱글톤 인스턴스 내보내기
// ============================================

export const apiClient = new APIClient();

// 타입 내보내기
export type { APIError, RequestConfig, APIResponse };
```

---

## 7. 폼 유효성 검사 스키마

### 7.1 Zod 스키마

```typescript
// 파일: src/lib/validations/auth.ts
// 목적: 인증 관련 폼 유효성 검사 스키마
// 의존성: zod

import { z } from 'zod';

// ============================================
// 공통 스키마
// ============================================

export const emailSchema = z
  .string()
  .min(1, '이메일을 입력해주세요.')
  .email('올바른 이메일 형식이 아닙니다.');

export const passwordSchema = z
  .string()
  .min(8, '비밀번호는 최소 8자 이상이어야 합니다.')
  .regex(
    /^(?=.*[a-zA-Z])(?=.*\d)(?=.*[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]).{8,}$/,
    '비밀번호는 영문, 숫자, 특수문자를 포함해야 합니다.'
  );

export const nameSchema = z
  .string()
  .min(2, '이름은 최소 2자 이상이어야 합니다.')
  .max(20, '이름은 최대 20자까지 가능합니다.')
  .regex(/^[가-힣a-zA-Z]+$/, '이름은 한글 또는 영문만 가능합니다.');

export const phoneSchema = z
  .string()
  .optional()
  .refine(
    (val) => !val || /^010-\d{4}-\d{4}$/.test(val),
    '올바른 휴대폰 번호 형식이 아닙니다. (예: 010-1234-5678)'
  );

// ============================================
// 로그인 스키마
// ============================================

export const loginSchema = z.object({
  email: emailSchema,
  password: z.string().min(1, '비밀번호를 입력해주세요.'),
  rememberMe: z.boolean().optional(),
});

export type LoginFormData = z.infer<typeof loginSchema>;

// ============================================
// 회원가입 스키마
// ============================================

export const signupSchema = z
  .object({
    email: emailSchema,
    password: passwordSchema,
    passwordConfirm: z.string().min(1, '비밀번호 확인을 입력해주세요.'),
    name: nameSchema,
    phone: phoneSchema,
    agreeTerms: z.literal(true, {
      errorMap: () => ({ message: '서비스 이용약관에 동의해주세요.' }),
    }),
    agreePrivacy: z.literal(true, {
      errorMap: () => ({ message: '개인정보 처리방침에 동의해주세요.' }),
    }),
    agreeMarketing: z.boolean().optional(),
  })
  .refine((data) => data.password === data.passwordConfirm, {
    message: '비밀번호가 일치하지 않습니다.',
    path: ['passwordConfirm'],
  });

export type SignupFormData = z.infer<typeof signupSchema>;

// ============================================
// 비밀번호 재설정 스키마
// ============================================

export const forgotPasswordSchema = z.object({
  email: emailSchema,
});

export type ForgotPasswordFormData = z.infer<typeof forgotPasswordSchema>;

export const resetPasswordSchema = z
  .object({
    password: passwordSchema,
    passwordConfirm: z.string().min(1, '비밀번호 확인을 입력해주세요.'),
  })
  .refine((data) => data.password === data.passwordConfirm, {
    message: '비밀번호가 일치하지 않습니다.',
    path: ['passwordConfirm'],
  });

export type ResetPasswordFormData = z.infer<typeof resetPasswordSchema>;
```

```typescript
// 파일: src/lib/validations/project.ts
// 목적: 프로젝트 관련 폼 유효성 검사 스키마
// 의존성: zod

import { z } from 'zod';

// ============================================
// 프로젝트 생성 스키마
// ============================================

export const createProjectSchema = z.object({
  title: z
    .string()
    .min(2, '제목은 최소 2자 이상이어야 합니다.')
    .max(100, '제목은 최대 100자까지 가능합니다.'),
  templateId: z.string().min(1, '템플릿을 선택해주세요.'),
});

export type CreateProjectFormData = z.infer<typeof createProjectSchema>;

// ============================================
// 답변 스키마
// ============================================

export const answerSchema = z.object({
  questionId: z.number().int().positive(),
  answer: z
    .string()
    .max(2000, '답변은 최대 2000자까지 가능합니다.'),
});

export type AnswerFormData = z.infer<typeof answerSchema>;

export const batchAnswersSchema = z.object({
  answers: z.array(answerSchema),
});

export type BatchAnswersFormData = z.infer<typeof batchAnswersSchema>;

// ============================================
// 배포 스키마
// ============================================

export const publishSchema = z.object({
  slug: z
    .string()
    .min(3, 'URL은 최소 3자 이상이어야 합니다.')
    .max(50, 'URL은 최대 50자까지 가능합니다.')
    .regex(
      /^[a-z0-9]+(-[a-z0-9]+)*$/,
      'URL은 영문 소문자, 숫자, 하이픈만 사용 가능합니다.'
    )
    .refine(
      (val) => !['admin', 'api', 'auth', 'dashboard', 'login', 'signup'].includes(val),
      '사용할 수 없는 URL입니다.'
    ),
});

export type PublishFormData = z.infer<typeof publishSchema>;

// ============================================
// 이미지 업로드 스키마
// ============================================

export const imageUploadSchema = z.object({
  file: z
    .custom<File>()
    .refine((file) => file instanceof File, '파일을 선택해주세요.')
    .refine(
      (file) => file.size <= 5 * 1024 * 1024,
      '파일 크기는 5MB 이하여야 합니다.'
    )
    .refine(
      (file) => ['image/jpeg', 'image/png', 'image/webp'].includes(file.type),
      'JPG, PNG, WebP 형식만 가능합니다.'
    ),
  imageType: z.enum(['hero', 'profile', 'product', 'testimonial']),
});

export type ImageUploadFormData = z.infer<typeof imageUploadSchema>;
```

---

## 8. 반응형 레이아웃

### 8.1 Tailwind 브레이크포인트 설정

```typescript
// 파일: tailwind.config.ts
// 목적: Tailwind CSS 설정 (반응형 브레이크포인트 포함)

import type { Config } from 'tailwindcss';

const config: Config = {
  darkMode: ['class'],
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    screens: {
      sm: '640px',   // Mobile landscape
      md: '768px',   // Tablet
      lg: '1024px',  // Desktop
      xl: '1280px',  // Large desktop
      '2xl': '1536px', // Extra large
    },
    container: {
      center: true,
      padding: {
        DEFAULT: '1rem',
        sm: '2rem',
        lg: '4rem',
        xl: '5rem',
        '2xl': '6rem',
      },
    },
    extend: {
      colors: {
        border: 'hsl(var(--border))',
        input: 'hsl(var(--input))',
        ring: 'hsl(var(--ring))',
        background: 'hsl(var(--background))',
        foreground: 'hsl(var(--foreground))',
        primary: {
          DEFAULT: 'hsl(var(--primary))',
          foreground: 'hsl(var(--primary-foreground))',
        },
        secondary: {
          DEFAULT: 'hsl(var(--secondary))',
          foreground: 'hsl(var(--secondary-foreground))',
        },
        destructive: {
          DEFAULT: 'hsl(var(--destructive))',
          foreground: 'hsl(var(--destructive-foreground))',
        },
        muted: {
          DEFAULT: 'hsl(var(--muted))',
          foreground: 'hsl(var(--muted-foreground))',
        },
        accent: {
          DEFAULT: 'hsl(var(--accent))',
          foreground: 'hsl(var(--accent-foreground))',
        },
        popover: {
          DEFAULT: 'hsl(var(--popover))',
          foreground: 'hsl(var(--popover-foreground))',
        },
        card: {
          DEFAULT: 'hsl(var(--card))',
          foreground: 'hsl(var(--card-foreground))',
        },
      },
      borderRadius: {
        lg: 'var(--radius)',
        md: 'calc(var(--radius) - 2px)',
        sm: 'calc(var(--radius) - 4px)',
      },
      fontFamily: {
        sans: ['var(--font-pretendard)', 'system-ui', 'sans-serif'],
      },
      keyframes: {
        'accordion-down': {
          from: { height: '0' },
          to: { height: 'var(--radix-accordion-content-height)' },
        },
        'accordion-up': {
          from: { height: 'var(--radix-accordion-content-height)' },
          to: { height: '0' },
        },
        shimmer: {
          '0%': { backgroundPosition: '-200% 0' },
          '100%': { backgroundPosition: '200% 0' },
        },
      },
      animation: {
        'accordion-down': 'accordion-down 0.2s ease-out',
        'accordion-up': 'accordion-up 0.2s ease-out',
        shimmer: 'shimmer 2s infinite linear',
      },
    },
  },
  plugins: [
    require('tailwindcss-animate'),
    require('@tailwindcss/typography'),
  ],
};

export default config;
```

### 8.2 대시보드 레이아웃

```typescript
// 파일: src/components/layout/DashboardLayout.tsx
// 목적: 대시보드 반응형 레이아웃
// 의존성: @/components/layout/Sidebar, @/components/layout/Header

'use client';

import { useState, useEffect } from 'react';
import { usePathname } from 'next/navigation';
import { Sidebar } from './Sidebar';
import { Header } from './Header';
import { MobileNav } from './MobileNav';
import { useUIStore } from '@/stores/uiStore';
import { cn } from '@/lib/utils';

// ============================================
// 타입 정의
// ============================================

interface DashboardLayoutProps {
  children: React.ReactNode;
}

// ============================================
// 컴포넌트 구현
// ============================================

export function DashboardLayout({ children }: DashboardLayoutProps) {
  const pathname = usePathname();
  const { isSidebarOpen, isSidebarCollapsed, isMobileMenuOpen, setMobileMenuOpen } = useUIStore();
  const [isMobile, setIsMobile] = useState(false);

  // 반응형 감지
  useEffect(() => {
    const checkMobile = () => {
      setIsMobile(window.innerWidth < 1024);
    };

    checkMobile();
    window.addEventListener('resize', checkMobile);
    return () => window.removeEventListener('resize', checkMobile);
  }, []);

  // 경로 변경 시 모바일 메뉴 닫기
  useEffect(() => {
    setMobileMenuOpen(false);
  }, [pathname, setMobileMenuOpen]);

  return (
    <div className="min-h-screen bg-background">
      {/* 모바일 네비게이션 */}
      {isMobile && <MobileNav />}

      {/* 사이드바 (데스크톱) */}
      {!isMobile && isSidebarOpen && (
        <aside
          className={cn(
            'fixed left-0 top-0 z-40 h-screen border-r bg-background transition-all duration-300',
            isSidebarCollapsed ? 'w-16' : 'w-64'
          )}
        >
          <Sidebar collapsed={isSidebarCollapsed} />
        </aside>
      )}

      {/* 메인 컨텐츠 영역 */}
      <div
        className={cn(
          'flex flex-col transition-all duration-300',
          !isMobile && isSidebarOpen && (isSidebarCollapsed ? 'ml-16' : 'ml-64')
        )}
      >
        {/* 헤더 */}
        <Header />

        {/* 페이지 컨텐츠 */}
        <main className="flex-1 p-4 md:p-6 lg:p-8">
          <div className="mx-auto max-w-7xl">
            {children}
          </div>
        </main>
      </div>

      {/* 모바일 오버레이 */}
      {isMobile && isMobileMenuOpen && (
        <div
          className="fixed inset-0 z-30 bg-black/50"
          onClick={() => setMobileMenuOpen(false)}
        />
      )}
    </div>
  );
}
```

---

## 9. 접근성 (Accessibility)

### 9.1 접근성 유틸리티

```typescript
// 파일: src/lib/accessibility.ts
// 목적: 접근성 관련 유틸리티 함수
// 의존성: 없음

// ============================================
// 키보드 네비게이션 유틸리티
// ============================================

export const KEYS = {
  ENTER: 'Enter',
  SPACE: ' ',
  ESCAPE: 'Escape',
  TAB: 'Tab',
  ARROW_UP: 'ArrowUp',
  ARROW_DOWN: 'ArrowDown',
  ARROW_LEFT: 'ArrowLeft',
  ARROW_RIGHT: 'ArrowRight',
  HOME: 'Home',
  END: 'End',
} as const;

export function handleKeyboardClick(
  event: React.KeyboardEvent,
  callback: () => void
): void {
  if (event.key === KEYS.ENTER || event.key === KEYS.SPACE) {
    event.preventDefault();
    callback();
  }
}

// ============================================
// 포커스 관리
// ============================================

export function focusFirstElement(container: HTMLElement): void {
  const focusable = getFocusableElements(container);
  if (focusable.length > 0) {
    (focusable[0] as HTMLElement).focus();
  }
}

export function getFocusableElements(container: HTMLElement): NodeListOf<Element> {
  return container.querySelectorAll(
    'button:not([disabled]), [href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"])'
  );
}

export function trapFocus(container: HTMLElement, event: KeyboardEvent): void {
  const focusable = getFocusableElements(container);
  const firstFocusable = focusable[0] as HTMLElement;
  const lastFocusable = focusable[focusable.length - 1] as HTMLElement;

  if (event.key === KEYS.TAB) {
    if (event.shiftKey) {
      if (document.activeElement === firstFocusable) {
        event.preventDefault();
        lastFocusable.focus();
      }
    } else {
      if (document.activeElement === lastFocusable) {
        event.preventDefault();
        firstFocusable.focus();
      }
    }
  }
}

// ============================================
// ARIA 라이브 리전
// ============================================

export function announceToScreenReader(
  message: string,
  priority: 'polite' | 'assertive' = 'polite'
): void {
  const announcer = document.createElement('div');
  announcer.setAttribute('role', 'status');
  announcer.setAttribute('aria-live', priority);
  announcer.setAttribute('aria-atomic', 'true');
  announcer.className = 'sr-only';
  announcer.textContent = message;

  document.body.appendChild(announcer);

  setTimeout(() => {
    document.body.removeChild(announcer);
  }, 1000);
}

// ============================================
// 스킵 링크
// ============================================

export function SkipLink({ targetId, children }: { targetId: string; children: React.ReactNode }) {
  return (
    <a
      href={`#${targetId}`}
      className="sr-only focus:not-sr-only focus:absolute focus:top-4 focus:left-4 focus:z-50 focus:px-4 focus:py-2 focus:bg-primary focus:text-primary-foreground focus:rounded-md"
    >
      {children}
    </a>
  );
}

// ============================================
// 색상 대비 체크
// ============================================

export function getContrastRatio(color1: string, color2: string): number {
  const lum1 = getLuminance(color1);
  const lum2 = getLuminance(color2);
  const brightest = Math.max(lum1, lum2);
  const darkest = Math.min(lum1, lum2);
  return (brightest + 0.05) / (darkest + 0.05);
}

function getLuminance(color: string): number {
  const rgb = hexToRgb(color);
  if (!rgb) return 0;

  const [r, g, b] = [rgb.r, rgb.g, rgb.b].map((v) => {
    v /= 255;
    return v <= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
  });

  return 0.2126 * r + 0.7152 * g + 0.0722 * b;
}

function hexToRgb(hex: string): { r: number; g: number; b: number } | null {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result
    ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16),
      }
    : null;
}

// WCAG AA 기준: 4.5:1 (일반 텍스트), 3:1 (큰 텍스트)
export function meetsContrastRequirement(
  color1: string,
  color2: string,
  level: 'AA' | 'AAA' = 'AA',
  isLargeText: boolean = false
): boolean {
  const ratio = getContrastRatio(color1, color2);

  if (level === 'AAA') {
    return isLargeText ? ratio >= 4.5 : ratio >= 7;
  }

  return isLargeText ? ratio >= 3 : ratio >= 4.5;
}
```

---

## 10. 에러 처리

### 10.1 Error Boundary

```typescript
// 파일: src/components/common/ErrorBoundary.tsx
// 목적: React 에러 경계 컴포넌트
// 의존성: React

'use client';

import { Component, type ErrorInfo, type ReactNode } from 'react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { AlertCircle, RefreshCw, Home } from 'lucide-react';

// ============================================
// 타입 정의
// ============================================

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
  onError?: (error: Error, errorInfo: ErrorInfo) => void;
}

interface State {
  hasError: boolean;
  error: Error | null;
  errorId: string | null;
}

// ============================================
// 컴포넌트 구현
// ============================================

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = {
      hasError: false,
      error: null,
      errorId: null,
    };
  }

  static getDerivedStateFromError(error: Error): State {
    const errorId = `ERR-${Date.now()}-${Math.random().toString(36).substr(2, 6)}`;
    return {
      hasError: true,
      error,
      errorId,
    };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {
    // 에러 로깅
    console.error('Error caught by boundary:', error, errorInfo);

    // 외부 에러 추적 서비스로 전송
    this.props.onError?.(error, errorInfo);

    // TODO: Sentry 등 에러 트래킹 서비스 연동
    // Sentry.captureException(error, { extra: errorInfo });
  }

  handleRetry = (): void => {
    this.setState({
      hasError: false,
      error: null,
      errorId: null,
    });
  };

  handleGoHome = (): void => {
    window.location.href = '/';
  };

  render(): ReactNode {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }

      return (
        <div className="min-h-[400px] flex items-center justify-center p-4">
          <Card className="max-w-md w-full">
            <CardHeader className="text-center">
              <div className="flex justify-center mb-4">
                <AlertCircle className="h-16 w-16 text-destructive" />
              </div>
              <CardTitle>오류가 발생했습니다</CardTitle>
            </CardHeader>
            <CardContent className="text-center space-y-4">
              <p className="text-muted-foreground">
                예상치 못한 오류가 발생했습니다. 문제가 지속되면 고객센터로 문의해주세요.
              </p>
              {this.state.errorId && (
                <div className="bg-muted rounded-lg p-3 text-sm">
                  <p className="text-muted-foreground">오류 코드</p>
                  <p className="font-mono font-medium">{this.state.errorId}</p>
                </div>
              )}
            </CardContent>
            <CardFooter className="flex justify-center gap-4">
              <Button variant="outline" onClick={this.handleGoHome}>
                <Home className="h-4 w-4 mr-2" />
                홈으로
              </Button>
              <Button onClick={this.handleRetry}>
                <RefreshCw className="h-4 w-4 mr-2" />
                다시 시도
              </Button>
            </CardFooter>
          </Card>
        </div>
      );
    }

    return this.props.children;
  }
}
```

### 10.2 전역 에러 페이지

```typescript
// 파일: src/app/error.tsx
// 목적: Next.js 전역 에러 페이지
// 의존성: @/components/ui

'use client';

import { useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { AlertCircle, RefreshCw, Home } from 'lucide-react';

// ============================================
// 타입 정의
// ============================================

interface ErrorPageProps {
  error: Error & { digest?: string };
  reset: () => void;
}

// ============================================
// 컴포넌트 구현
// ============================================

export default function ErrorPage({ error, reset }: ErrorPageProps) {
  useEffect(() => {
    // 에러 로깅
    console.error('Global error:', error);

    // TODO: Sentry 등 에러 트래킹 서비스 연동
  }, [error]);

  return (
    <div className="min-h-screen flex items-center justify-center p-4 bg-background">
      <Card className="max-w-md w-full">
        <CardHeader className="text-center">
          <div className="flex justify-center mb-4">
            <AlertCircle className="h-20 w-20 text-destructive" />
          </div>
          <CardTitle className="text-2xl">문제가 발생했습니다</CardTitle>
        </CardHeader>
        <CardContent className="text-center space-y-4">
          <p className="text-muted-foreground">
            서비스 이용 중 오류가 발생했습니다. 잠시 후 다시 시도해주세요.
          </p>
          {error.digest && (
            <div className="bg-muted rounded-lg p-4 text-sm">
              <p className="text-muted-foreground mb-1">문의 시 아래 코드를 알려주세요</p>
              <p className="font-mono font-medium text-lg">{error.digest}</p>
            </div>
          )}
          <div className="bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-800 rounded-lg p-4 text-sm text-left">
            <p className="font-medium text-yellow-800 dark:text-yellow-200 mb-2">
              문제가 지속되면:
            </p>
            <ul className="list-disc list-inside space-y-1 text-yellow-700 dark:text-yellow-300">
              <li>브라우저 캐시를 삭제해보세요</li>
              <li>다른 브라우저로 접속해보세요</li>
              <li>고객센터로 문의해주세요</li>
            </ul>
          </div>
        </CardContent>
        <CardFooter className="flex justify-center gap-4">
          <Button variant="outline" onClick={() => window.location.href = '/'}>
            <Home className="h-4 w-4 mr-2" />
            홈으로 이동
          </Button>
          <Button onClick={reset}>
            <RefreshCw className="h-4 w-4 mr-2" />
            다시 시도
          </Button>
        </CardFooter>
      </Card>
    </div>
  );
}
```

---

## 11. 성능 최적화

### 11.1 이미지 최적화 컴포넌트

```typescript
// 파일: src/components/common/OptimizedImage.tsx
// 목적: Next.js Image 컴포넌트 래퍼 (로딩 상태, 에러 처리 포함)
// 의존성: next/image

'use client';

import { useState } from 'react';
import Image, { type ImageProps } from 'next/image';
import { cn } from '@/lib/utils';
import { ImageIcon } from 'lucide-react';

// ============================================
// 타입 정의
// ============================================

interface OptimizedImageProps extends Omit<ImageProps, 'onLoad' | 'onError'> {
  fallback?: React.ReactNode;
  showLoading?: boolean;
}

// ============================================
// 컴포넌트 구현
// ============================================

export function OptimizedImage({
  src,
  alt,
  className,
  fallback,
  showLoading = true,
  ...props
}: OptimizedImageProps) {
  const [isLoading, setIsLoading] = useState(true);
  const [hasError, setHasError] = useState(false);

  if (hasError) {
    return (
      fallback || (
        <div
          className={cn(
            'flex items-center justify-center bg-muted',
            className
          )}
          style={{ width: props.width, height: props.height }}
        >
          <ImageIcon className="h-8 w-8 text-muted-foreground" />
        </div>
      )
    );
  }

  return (
    <div className={cn('relative overflow-hidden', className)}>
      {showLoading && isLoading && (
        <div
          className="absolute inset-0 bg-muted animate-pulse"
          style={{ width: props.width, height: props.height }}
        />
      )}
      <Image
        src={src}
        alt={alt}
        className={cn(
          'transition-opacity duration-300',
          isLoading ? 'opacity-0' : 'opacity-100'
        )}
        onLoad={() => setIsLoading(false)}
        onError={() => {
          setIsLoading(false);
          setHasError(true);
        }}
        {...props}
      />
    </div>
  );
}
```

### 11.2 Lazy Loading 컴포넌트

```typescript
// 파일: src/components/common/LazyComponent.tsx
// 목적: 컴포넌트 지연 로딩 래퍼
// 의존성: React

'use client';

import { Suspense, lazy, type ComponentType } from 'react';
import { Skeleton } from '@/components/ui/skeleton';

// ============================================
// 타입 정의
// ============================================

interface LazyComponentProps<T extends ComponentType<any>> {
  loader: () => Promise<{ default: T }>;
  fallback?: React.ReactNode;
  componentProps?: React.ComponentProps<T>;
}

// ============================================
// 유틸리티 함수
// ============================================

export function createLazyComponent<T extends ComponentType<any>>(
  loader: () => Promise<{ default: T }>
) {
  const LazyComponent = lazy(loader);

  return function LazyWrapper({
    fallback = <DefaultFallback />,
    ...props
  }: Omit<LazyComponentProps<T>, 'loader'> & React.ComponentProps<T>) {
    return (
      <Suspense fallback={fallback}>
        <LazyComponent {...props} />
      </Suspense>
    );
  };
}

// ============================================
// 기본 폴백 컴포넌트
// ============================================

function DefaultFallback() {
  return (
    <div className="space-y-4 p-4">
      <Skeleton className="h-8 w-3/4" />
      <Skeleton className="h-4 w-full" />
      <Skeleton className="h-4 w-5/6" />
      <Skeleton className="h-32 w-full" />
    </div>
  );
}

// ============================================
// 사용 예시
// ============================================

// const LazyTipTapEditor = createLazyComponent(
//   () => import('@/components/editor/TipTapEditor')
// );
```

---

## 12. 환경 변수

### 12.1 환경 변수 스키마

```typescript
// 파일: src/lib/env.ts
// 목적: 환경 변수 타입 안전 검증
// 의존성: zod

import { z } from 'zod';

// ============================================
// 스키마 정의
// ============================================

const envSchema = z.object({
  // Supabase
  NEXT_PUBLIC_SUPABASE_URL: z.string().url(),
  NEXT_PUBLIC_SUPABASE_ANON_KEY: z.string().min(1),
  SUPABASE_SERVICE_ROLE_KEY: z.string().min(1).optional(),

  // App
  NEXT_PUBLIC_APP_URL: z.string().url(),
  NEXT_PUBLIC_APP_NAME: z.string().default('Magnetic Sales'),

  // AI
  ANTHROPIC_API_KEY: z.string().min(1).optional(),

  // Analytics (optional)
  NEXT_PUBLIC_GA_ID: z.string().optional(),
  NEXT_PUBLIC_SENTRY_DSN: z.string().url().optional(),

  // Feature Flags
  NEXT_PUBLIC_ENABLE_ANALYTICS: z.enum(['true', 'false']).default('false'),
  NEXT_PUBLIC_MAINTENANCE_MODE: z.enum(['true', 'false']).default('false'),
});

// ============================================
// 환경 변수 검증
// ============================================

const processEnv = {
  NEXT_PUBLIC_SUPABASE_URL: process.env.NEXT_PUBLIC_SUPABASE_URL,
  NEXT_PUBLIC_SUPABASE_ANON_KEY: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
  SUPABASE_SERVICE_ROLE_KEY: process.env.SUPABASE_SERVICE_ROLE_KEY,
  NEXT_PUBLIC_APP_URL: process.env.NEXT_PUBLIC_APP_URL,
  NEXT_PUBLIC_APP_NAME: process.env.NEXT_PUBLIC_APP_NAME,
  ANTHROPIC_API_KEY: process.env.ANTHROPIC_API_KEY,
  NEXT_PUBLIC_GA_ID: process.env.NEXT_PUBLIC_GA_ID,
  NEXT_PUBLIC_SENTRY_DSN: process.env.NEXT_PUBLIC_SENTRY_DSN,
  NEXT_PUBLIC_ENABLE_ANALYTICS: process.env.NEXT_PUBLIC_ENABLE_ANALYTICS,
  NEXT_PUBLIC_MAINTENANCE_MODE: process.env.NEXT_PUBLIC_MAINTENANCE_MODE,
};

const parsed = envSchema.safeParse(processEnv);

if (!parsed.success) {
  console.error(
    '환경 변수 검증 실패:',
    parsed.error.flatten().fieldErrors
  );
  throw new Error('환경 변수 설정이 올바르지 않습니다.');
}

// ============================================
// 타입 안전 환경 변수 내보내기
// ============================================

export const env = parsed.data;

// 클라이언트 안전 환경 변수
export const clientEnv = {
  supabaseUrl: env.NEXT_PUBLIC_SUPABASE_URL,
  supabaseAnonKey: env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
  appUrl: env.NEXT_PUBLIC_APP_URL,
  appName: env.NEXT_PUBLIC_APP_NAME,
  gaId: env.NEXT_PUBLIC_GA_ID,
  sentryDsn: env.NEXT_PUBLIC_SENTRY_DSN,
  enableAnalytics: env.NEXT_PUBLIC_ENABLE_ANALYTICS === 'true',
  maintenanceMode: env.NEXT_PUBLIC_MAINTENANCE_MODE === 'true',
} as const;
```

---

## 구현 체크리스트

### 라우팅
- [ ] App Router 구조 설정
- [ ] 미들웨어 구현 (인증, 승인 체크)
- [ ] 보호된 라우트 설정
- [ ] 동적 라우트 구현

### 상태 관리
- [ ] Auth Store 구현
- [ ] Project Store 구현
- [ ] UI Store 구현
- [ ] Token Store 구현

### Hooks
- [ ] useAuth Hook 구현
- [ ] useAIGeneration Hook 구현
- [ ] useAutoSave Hook 구현
- [ ] useTokenUsage Hook 구현

### UI 컴포넌트
- [ ] 기본 UI 컴포넌트 (shadcn/ui)
- [ ] 레이아웃 컴포넌트
- [ ] 인증 폼 컴포넌트
- [ ] 대시보드 컴포넌트
- [ ] 질문 폼 컴포넌트
- [ ] 생성 진행률 컴포넌트
- [ ] TipTap 에디터 컴포넌트

### API 클라이언트
- [ ] Fetch Wrapper 구현
- [ ] 자동 토큰 갱신
- [ ] 에러 처리

### 폼 검증
- [ ] 인증 스키마
- [ ] 프로젝트 스키마
- [ ] 파일 업로드 스키마

### 접근성
- [ ] 키보드 네비게이션
- [ ] 스크린 리더 지원
- [ ] ARIA 레이블
- [ ] 색상 대비 검증

### 성능 최적화
- [ ] 이미지 최적화
- [ ] 코드 분할 (Lazy Loading)
- [ ] 메모이제이션

### 에러 처리
- [ ] Error Boundary
- [ ] 전역 에러 페이지
- [ ] API 에러 처리

---

## 관련 문서

- [00_PRD_개요.md](./00_PRD_개요.md) - 프로젝트 개요
- [01_프로젝트_구조.md](./01_프로젝트_구조.md) - 폴더 구조
- [03_API_명세.md](./03_API_명세.md) - API 엔드포인트
- [04_인증_시스템.md](./04_인증_시스템.md) - 인증 시스템
- [05_AI_통합.md](./05_AI_통합.md) - AI 통합
