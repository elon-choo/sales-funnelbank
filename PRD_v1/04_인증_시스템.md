# Magnetic Sales WebApp - 인증 시스템

## 문서 정보

| 항목 | 내용 |
|------|------|
| 문서 버전 | 1.0 |
| 작성일 | 2025-12-15 |
| 이전 문서 | [03_API_명세.md](./03_API_명세.md) |
| 다음 문서 | [05_AI_통합.md](./05_AI_통합.md) |

---

## 1. 인증 아키텍처 개요

### 1.1 인증 흐름 다이어그램

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          Authentication Flow (v2)                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌──────────┐      ┌──────────────┐      ┌──────────────┐                   │
│  │  Client  │──1──▶│ Supabase Auth│──2──▶│   Database   │                   │
│  │ (Browser)│      │    Server    │      │  (profiles)  │                   │
│  └────┬─────┘      └──────────────┘      └──────────────┘                   │
│       │                                                                      │
│       │ 3. Access Token (15min) + Refresh Token (7day, HttpOnly Cookie)     │
│       │                                                                      │
│       ▼                                                                      │
│  ┌────────────────────────────────────────────────────────────────┐         │
│  │                     Token Management                            │         │
│  │  ┌─────────────┐    ┌─────────────┐    ┌─────────────────────┐ │         │
│  │  │ Access Token│    │Refresh Token│    │   Token Rotation    │ │         │
│  │  │  (Memory)   │    │  (HttpOnly) │    │ (재사용 감지 v2)    │ │         │
│  │  └─────────────┘    └─────────────┘    └─────────────────────┘ │         │
│  └────────────────────────────────────────────────────────────────┘         │
│                                                                              │
│  ┌────────────────────────────────────────────────────────────────┐         │
│  │                     Session Management (v2)                     │         │
│  │  ┌─────────────────┐    ┌─────────────────────────────────────┐ │         │
│  │  │  user_sessions  │    │ approval_changed_at 기반 무효화      │ │         │
│  │  │    테이블       │    │ 승인 취소 → 모든 세션 즉시 무효화    │ │         │
│  │  └─────────────────┘    └─────────────────────────────────────┘ │         │
│  └────────────────────────────────────────────────────────────────┘         │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 1.2 핵심 보안 정책

```yaml
Token Policy:
  Access Token:
    저장: 메모리 (Zustand Store)
    만료: 15분
    용도: API 요청 인증

  Refresh Token:
    저장: HttpOnly Cookie (JavaScript 접근 불가)
    만료: 7일
    용도: Access Token 갱신
    Rotation: 사용 시마다 새 토큰 발급
    재사용 감지: 폐기된 토큰 사용 시 모든 세션 무효화

Session Policy:
  다중 세션: 허용 (기기별 동시 로그인)
  세션 추적: user_sessions 테이블
  강제 로그아웃: 승인 상태 변경 시 자동
  전체 로그아웃: logout-all 엔드포인트

Approval System:
  신규 가입: is_approved = FALSE (대기 상태)
  관리자 승인: is_approved = TRUE
  승인 취소: 모든 세션 즉시 무효화
```

---

## 2. Supabase Auth 설정

### 2.1 프로젝트 초기 설정

```typescript
// src/lib/supabase/config.ts
/**
 * Supabase 환경 설정
 * 파일 위치: src/lib/supabase/config.ts
 * 용도: Supabase 클라이언트 생성을 위한 설정값
 */

export const SUPABASE_CONFIG = {
  // 환경 변수에서 로드
  url: process.env.NEXT_PUBLIC_SUPABASE_URL!,
  anonKey: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
  serviceRoleKey: process.env.SUPABASE_SERVICE_ROLE_KEY!,

  // Auth 설정
  auth: {
    autoRefreshToken: false,        // 클라이언트에서 자동 갱신 비활성화 (직접 제어)
    persistSession: false,          // 세션 저장 비활성화 (HttpOnly Cookie 사용)
    detectSessionInUrl: false,      // URL에서 세션 감지 비활성화
    flowType: 'pkce' as const,      // PKCE 플로우 (보안 강화)
  },

  // Cookie 설정
  cookie: {
    name: 'refresh_token',
    lifetime: 60 * 60 * 24 * 7,     // 7일
    domain: process.env.COOKIE_DOMAIN || '',
    path: '/api/auth',
    sameSite: 'strict' as const,
    secure: process.env.NODE_ENV === 'production',
  },
};

// 환경 변수 검증
export function validateEnv(): void {
  const required = [
    'NEXT_PUBLIC_SUPABASE_URL',
    'NEXT_PUBLIC_SUPABASE_ANON_KEY',
    'SUPABASE_SERVICE_ROLE_KEY',
  ];

  const missing = required.filter((key) => !process.env[key]);

  if (missing.length > 0) {
    throw new Error(
      `Missing required environment variables: ${missing.join(', ')}`
    );
  }
}
```

### 2.2 Supabase 클라이언트 생성

```typescript
// src/lib/supabase/client.ts
/**
 * 클라이언트 사이드 Supabase 클라이언트
 * 파일 위치: src/lib/supabase/client.ts
 * 용도: 브라우저에서 사용하는 Supabase 클라이언트
 */

import { createBrowserClient } from '@supabase/ssr';
import type { Database } from '@/types/database';

let client: ReturnType<typeof createBrowserClient<Database>> | null = null;

export function getSupabaseClient() {
  if (client) return client;

  client = createBrowserClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      auth: {
        autoRefreshToken: false,
        persistSession: false,
        detectSessionInUrl: false,
      },
    }
  );

  return client;
}
```

```typescript
// src/lib/supabase/server.ts
/**
 * 서버 사이드 Supabase 클라이언트 (App Router)
 * 파일 위치: src/lib/supabase/server.ts
 * 용도: Server Components, Route Handlers에서 사용
 * 의존성: @supabase/ssr, next/headers
 */

import { createServerClient, type CookieOptions } from '@supabase/ssr';
import { cookies } from 'next/headers';
import type { Database } from '@/types/database';

export async function getSupabaseServer() {
  const cookieStore = await cookies();

  return createServerClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: CookieOptions) {
          try {
            cookieStore.set({ name, value, ...options });
          } catch {
            // Server Component에서는 쿠키 설정 불가
          }
        },
        remove(name: string, options: CookieOptions) {
          try {
            cookieStore.set({ name, value: '', ...options });
          } catch {
            // Server Component에서는 쿠키 삭제 불가
          }
        },
      },
    }
  );
}
```

```typescript
// src/lib/supabase/admin.ts
/**
 * Admin Supabase 클라이언트 (Service Role)
 * 파일 위치: src/lib/supabase/admin.ts
 * 용도: 서버 사이드에서 RLS 우회가 필요한 작업
 * 주의: 절대 클라이언트에 노출되면 안 됨!
 */

import { createClient } from '@supabase/supabase-js';
import type { Database } from '@/types/database';

let adminClient: ReturnType<typeof createClient<Database>> | null = null;

export function getSupabaseAdmin() {
  if (adminClient) return adminClient;

  const url = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

  if (!url || !serviceRoleKey) {
    throw new Error('Missing Supabase admin credentials');
  }

  adminClient = createClient<Database>(url, serviceRoleKey, {
    auth: {
      autoRefreshToken: false,
      persistSession: false,
    },
  });

  return adminClient;
}
```

### 2.3 미들웨어 설정

```typescript
// src/middleware.ts
/**
 * Next.js 미들웨어
 * 파일 위치: src/middleware.ts
 * 용도: 모든 요청에 대한 인증/인가 처리, CORS 설정
 */

import { NextResponse, type NextRequest } from 'next/server';
import { createServerClient } from '@supabase/ssr';

// 보호되지 않는 경로
const PUBLIC_PATHS = [
  '/',
  '/login',
  '/signup',
  '/forgot-password',
  '/api/auth/login',
  '/api/auth/signup',
  '/api/auth/refresh',
  '/api/health',
];

// 공개 랜딩페이지 경로 패턴
const PUBLIC_LP_PATTERN = /^\/lp\/[a-zA-Z0-9-]+$/;

// CORS 허용 도메인 (명시적 화이트리스트)
const ALLOWED_ORIGINS = [
  'https://magnetic-sales.vercel.app',
  'https://www.magnetic-sales.com',
  ...(process.env.NODE_ENV === 'development' ? ['http://localhost:3000'] : []),
];

export async function middleware(request: NextRequest) {
  const response = NextResponse.next();
  const { pathname } = request.nextUrl;

  // 1. CORS 처리
  const origin = request.headers.get('origin');
  if (origin && ALLOWED_ORIGINS.includes(origin)) {
    response.headers.set('Access-Control-Allow-Origin', origin);
    response.headers.set('Access-Control-Allow-Credentials', 'true');
    response.headers.set(
      'Access-Control-Allow-Methods',
      'GET, POST, PUT, PATCH, DELETE, OPTIONS'
    );
    response.headers.set(
      'Access-Control-Allow-Headers',
      'Content-Type, Authorization, X-Requested-With'
    );
  }

  // Preflight 요청 처리
  if (request.method === 'OPTIONS') {
    return new NextResponse(null, {
      status: 204,
      headers: response.headers,
    });
  }

  // 2. 공개 경로 확인
  if (
    PUBLIC_PATHS.some((path) => pathname === path || pathname.startsWith(path + '/')) ||
    PUBLIC_LP_PATTERN.test(pathname)
  ) {
    return response;
  }

  // 3. API 경로 - Bearer Token 검증
  if (pathname.startsWith('/api/')) {
    const authHeader = request.headers.get('authorization');

    if (!authHeader?.startsWith('Bearer ')) {
      return NextResponse.json(
        {
          success: false,
          error: {
            code: 'AUTH_003',
            message: '인증이 필요합니다',
          },
        },
        { status: 401 }
      );
    }

    // Supabase JWT 검증은 Route Handler에서 수행
    return response;
  }

  // 4. 페이지 경로 - 세션 확인 후 리다이렉트
  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          response.cookies.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          response.cookies.delete({ name, ...options });
        },
      },
    }
  );

  const {
    data: { session },
  } = await supabase.auth.getSession();

  if (!session) {
    const loginUrl = new URL('/login', request.url);
    loginUrl.searchParams.set('redirect', pathname);
    return NextResponse.redirect(loginUrl);
  }

  return response;
}

export const config = {
  matcher: [
    /*
     * 다음 경로를 제외한 모든 경로에서 실행:
     * - _next/static (정적 파일)
     * - _next/image (이미지 최적화)
     * - favicon.ico, robots.txt 등
     */
    '/((?!_next/static|_next/image|favicon.ico|robots.txt|sitemap.xml).*)',
  ],
};
```

---

## 3. JWT 토큰 관리

### 3.1 토큰 유틸리티 함수

```typescript
// src/lib/auth/tokens.ts
/**
 * JWT 토큰 유틸리티
 * 파일 위치: src/lib/auth/tokens.ts
 * 용도: Access Token, Refresh Token 관리
 */

import { jwtVerify, decodeJwt, type JWTPayload } from 'jose';

// Supabase JWT 시크릿
const JWT_SECRET = new TextEncoder().encode(
  process.env.SUPABASE_JWT_SECRET || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);

/**
 * JWT 페이로드 타입
 */
export interface TokenPayload extends JWTPayload {
  sub: string;          // 사용자 ID
  email?: string;
  role?: string;
  aal?: string;         // Authenticator Assurance Level
  amr?: { method: string; timestamp: number }[];
  session_id?: string;
}

/**
 * Access Token 검증
 */
export async function verifyAccessToken(token: string): Promise<TokenPayload | null> {
  try {
    const { payload } = await jwtVerify(token, JWT_SECRET, {
      algorithms: ['HS256'],
    });
    return payload as TokenPayload;
  } catch (error) {
    console.error('Token verification failed:', error);
    return null;
  }
}

/**
 * Access Token 디코딩 (검증 없이)
 * 주의: 검증이 필요한 경우 verifyAccessToken 사용
 */
export function decodeAccessToken(token: string): TokenPayload | null {
  try {
    return decodeJwt(token) as TokenPayload;
  } catch {
    return null;
  }
}

/**
 * 토큰 만료 시간 확인
 */
export function isTokenExpired(token: string): boolean {
  const payload = decodeAccessToken(token);
  if (!payload?.exp) return true;

  // 30초 버퍼
  const now = Math.floor(Date.now() / 1000) + 30;
  return payload.exp < now;
}

/**
 * 토큰 남은 시간 계산 (초)
 */
export function getTokenRemainingTime(token: string): number {
  const payload = decodeAccessToken(token);
  if (!payload?.exp) return 0;

  const remaining = payload.exp - Math.floor(Date.now() / 1000);
  return Math.max(0, remaining);
}

/**
 * Authorization 헤더에서 토큰 추출
 */
export function extractBearerToken(authHeader: string | null): string | null {
  if (!authHeader?.startsWith('Bearer ')) return null;
  return authHeader.slice(7);
}
```

### 3.2 Refresh Token Rotation 구현

```typescript
// src/lib/auth/rotation.ts
/**
 * Refresh Token Rotation 로직
 * 파일 위치: src/lib/auth/rotation.ts
 * 용도: Token Rotation 및 재사용 감지
 */

import { getSupabaseAdmin } from '@/lib/supabase/admin';
import { hashToken, generateSecureToken } from '@/lib/security/crypto';

export interface RefreshResult {
  success: boolean;
  accessToken?: string;
  newRefreshToken?: string;
  error?: string;
  securityAlert?: boolean;
}

/**
 * Refresh Token으로 새 토큰 발급
 * v2: Token Rotation + 재사용 감지
 */
export async function rotateRefreshToken(
  refreshToken: string,
  ipAddress?: string,
  userAgent?: string
): Promise<RefreshResult> {
  const supabase = getSupabaseAdmin();
  const tokenHash = hashToken(refreshToken);

  // 1. 토큰 조회
  const { data: tokenRecord, error: fetchError } = await supabase
    .from('refresh_tokens')
    .select('*')
    .eq('token_hash', tokenHash)
    .single();

  if (fetchError || !tokenRecord) {
    return { success: false, error: 'invalid_token' };
  }

  // 2. 재사용 감지 (CRITICAL)
  if (tokenRecord.revoked) {
    // 보안 위협: 모든 토큰 폐기
    await supabase
      .from('refresh_tokens')
      .update({ revoked: true, revoked_at: new Date().toISOString() })
      .eq('user_id', tokenRecord.user_id);

    // 모든 세션 무효화
    await supabase
      .from('user_sessions')
      .update({ invalidated_at: new Date().toISOString() })
      .eq('user_id', tokenRecord.user_id)
      .is('invalidated_at', null);

    // 감사 로그
    await supabase.from('audit_logs').insert({
      user_id: tokenRecord.user_id,
      action: 'token_reuse_detected',
      details: {
        severity: 'critical',
        token_id: tokenRecord.id,
        original_created_at: tokenRecord.created_at,
      },
      ip_address: ipAddress,
      user_agent: userAgent,
    });

    return {
      success: false,
      error: 'token_reuse_detected',
      securityAlert: true,
    };
  }

  // 3. 만료 확인
  if (new Date(tokenRecord.expires_at) < new Date()) {
    return { success: false, error: 'token_expired' };
  }

  // 4. 사용자 상태 확인 (승인/삭제)
  const { data: profile } = await supabase
    .from('profiles')
    .select('is_approved, deleted_at')
    .eq('id', tokenRecord.user_id)
    .single();

  if (profile?.deleted_at) {
    return { success: false, error: 'account_deleted' };
  }

  if (!profile?.is_approved) {
    return { success: false, error: 'account_not_approved' };
  }

  // 5. 기존 토큰 폐기 (Rotation)
  await supabase
    .from('refresh_tokens')
    .update({ revoked: true, revoked_at: new Date().toISOString() })
    .eq('id', tokenRecord.id);

  // 6. 새 Refresh Token 발급
  const newRefreshToken = generateSecureToken(64);
  const newTokenHash = hashToken(newRefreshToken);
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);

  await supabase.from('refresh_tokens').insert({
    user_id: tokenRecord.user_id,
    token_hash: newTokenHash,
    expires_at: expiresAt.toISOString(),
    revoked: false,
  });

  // 7. 새 Access Token 발급 (Supabase Admin API)
  const { data: userData, error: userError } = await supabase.auth.admin.getUserById(
    tokenRecord.user_id
  );

  if (userError || !userData.user) {
    return { success: false, error: 'user_not_found' };
  }

  // 세션 생성을 위한 Magic Link 생성 (Access Token 추출용)
  const { data: sessionData, error: sessionError } = await supabase.auth.admin.generateLink({
    type: 'magiclink',
    email: userData.user.email!,
    options: {
      redirectTo: '/',
    },
  });

  if (sessionError) {
    return { success: false, error: 'session_creation_failed' };
  }

  return {
    success: true,
    accessToken: sessionData.properties?.access_token,
    newRefreshToken,
  };
}

/**
 * 사용자의 모든 Refresh Token 폐기
 */
export async function revokeAllUserTokens(userId: string): Promise<void> {
  const supabase = getSupabaseAdmin();

  await supabase
    .from('refresh_tokens')
    .update({ revoked: true, revoked_at: new Date().toISOString() })
    .eq('user_id', userId)
    .eq('revoked', false);
}

/**
 * 만료된 토큰 정리 (배치 작업용)
 */
export async function cleanupExpiredTokens(): Promise<number> {
  const supabase = getSupabaseAdmin();

  const { data, error } = await supabase
    .from('refresh_tokens')
    .delete()
    .lt('expires_at', new Date().toISOString())
    .select('id');

  if (error) {
    console.error('Failed to cleanup expired tokens:', error);
    return 0;
  }

  return data?.length || 0;
}
```

### 3.3 암호화 유틸리티

```typescript
// src/lib/security/crypto.ts
/**
 * 암호화 유틸리티
 * 파일 위치: src/lib/security/crypto.ts
 * 용도: 토큰 생성, 해싱, 에러 참조 ID 생성
 */

import { createHash, randomBytes } from 'crypto';

/**
 * 보안 랜덤 토큰 생성
 * @param length 바이트 길이 (결과는 hex로 2배)
 */
export function generateSecureToken(length: number = 32): string {
  return randomBytes(length).toString('hex');
}

/**
 * SHA-256 해싱 (토큰 저장용)
 */
export function hashToken(token: string): string {
  return createHash('sha256').update(token).digest('hex');
}

/**
 * 에러 참조 ID 생성
 * 형식: ERR-YYYYMMDDHHMMSS-XXXX
 */
export function generateErrorReference(): string {
  const now = new Date();
  const timestamp = now
    .toISOString()
    .replace(/[-:T.Z]/g, '')
    .slice(0, 14);
  const random = randomBytes(2).toString('hex').toUpperCase();
  return `ERR-${timestamp}-${random}`;
}

/**
 * 비밀번호 강도 확인
 */
export interface PasswordStrength {
  score: number;      // 0-4
  feedback: string[];
}

export function checkPasswordStrength(password: string): PasswordStrength {
  const feedback: string[] = [];
  let score = 0;

  // 길이 검사
  if (password.length >= 8) score++;
  else feedback.push('8자 이상이어야 합니다');

  if (password.length >= 12) score++;

  // 대문자 포함
  if (/[A-Z]/.test(password)) score++;
  else feedback.push('대문자를 포함하세요');

  // 숫자 포함
  if (/[0-9]/.test(password)) score++;
  else feedback.push('숫자를 포함하세요');

  // 특수문자 포함
  if (/[!@#$%^&*(),.?":{}|<>]/.test(password)) {
    score++;
  }

  return { score: Math.min(4, score), feedback };
}
```

---

## 4. Cookie 관리

### 4.1 Cookie 유틸리티

```typescript
// src/lib/auth/cookies.ts
/**
 * HttpOnly Cookie 관리
 * 파일 위치: src/lib/auth/cookies.ts
 * 용도: Refresh Token Cookie 설정/조회/삭제
 */

import { ResponseCookie } from 'next/dist/compiled/@edge-runtime/cookies';
import { SUPABASE_CONFIG } from '@/lib/supabase/config';

/**
 * Refresh Token Cookie 설정값 생성
 */
export function createRefreshTokenCookie(token: string): ResponseCookie {
  return {
    name: SUPABASE_CONFIG.cookie.name,
    value: token,
    httpOnly: true,
    secure: SUPABASE_CONFIG.cookie.secure,
    sameSite: SUPABASE_CONFIG.cookie.sameSite,
    path: SUPABASE_CONFIG.cookie.path,
    maxAge: SUPABASE_CONFIG.cookie.lifetime,
    domain: SUPABASE_CONFIG.cookie.domain || undefined,
  };
}

/**
 * Refresh Token Cookie 삭제 설정값 생성
 */
export function createRefreshTokenDeleteCookie(): ResponseCookie {
  return {
    name: SUPABASE_CONFIG.cookie.name,
    value: '',
    httpOnly: true,
    secure: SUPABASE_CONFIG.cookie.secure,
    sameSite: SUPABASE_CONFIG.cookie.sameSite,
    path: SUPABASE_CONFIG.cookie.path,
    maxAge: 0,
  };
}

/**
 * Cookie 옵션 문자열 생성 (디버깅용)
 */
export function cookieOptionsToString(cookie: ResponseCookie): string {
  const parts = [`${cookie.name}=${cookie.value}`];

  if (cookie.httpOnly) parts.push('HttpOnly');
  if (cookie.secure) parts.push('Secure');
  if (cookie.sameSite) parts.push(`SameSite=${cookie.sameSite}`);
  if (cookie.path) parts.push(`Path=${cookie.path}`);
  if (cookie.maxAge !== undefined) parts.push(`Max-Age=${cookie.maxAge}`);
  if (cookie.domain) parts.push(`Domain=${cookie.domain}`);

  return parts.join('; ');
}
```

### 4.2 Cookie 파서

```typescript
// src/lib/auth/cookie-parser.ts
/**
 * Cookie 파싱 유틸리티
 * 파일 위치: src/lib/auth/cookie-parser.ts
 * 용도: Request에서 Cookie 값 추출
 */

import { NextRequest } from 'next/server';
import { SUPABASE_CONFIG } from '@/lib/supabase/config';

/**
 * Request에서 Refresh Token 추출
 */
export function getRefreshTokenFromRequest(request: NextRequest): string | null {
  // 1. Next.js cookies() API
  const cookieValue = request.cookies.get(SUPABASE_CONFIG.cookie.name)?.value;
  if (cookieValue) return cookieValue;

  // 2. Cookie 헤더 직접 파싱 (fallback)
  const cookieHeader = request.headers.get('cookie');
  if (!cookieHeader) return null;

  const cookies = parseCookieHeader(cookieHeader);
  return cookies[SUPABASE_CONFIG.cookie.name] || null;
}

/**
 * Cookie 헤더 문자열 파싱
 */
function parseCookieHeader(header: string): Record<string, string> {
  const cookies: Record<string, string> = {};

  header.split(';').forEach((pair) => {
    const [key, value] = pair.trim().split('=');
    if (key && value) {
      cookies[key] = decodeURIComponent(value);
    }
  });

  return cookies;
}
```

---

## 5. Auth Guard (인증 보호)

### 5.1 Route Handler Guard

```typescript
// src/lib/auth/guards.ts
/**
 * API Route 인증 가드
 * 파일 위치: src/lib/auth/guards.ts
 * 용도: Route Handler에서 인증 검증
 */

import { NextRequest, NextResponse } from 'next/server';
import { verifyAccessToken, extractBearerToken, TokenPayload } from './tokens';
import { getSupabaseAdmin } from '@/lib/supabase/admin';
import { ERROR_CODES, ERROR_MESSAGES } from '@/lib/constants/errors';
import { generateErrorReference } from '@/lib/security/crypto';

/**
 * 인증된 요청 타입
 */
export interface AuthenticatedRequest extends NextRequest {
  userId: string;
  userEmail: string;
  userTier: 'FREE' | 'PRO' | 'ENTERPRISE';
  tokenPayload: TokenPayload;
}

/**
 * 인증 가드 옵션
 */
export interface AuthGuardOptions {
  requireApproval?: boolean;  // 승인 필요 여부 (기본: true)
  allowedTiers?: ('FREE' | 'PRO' | 'ENTERPRISE')[]; // 허용 티어
}

/**
 * 인증 가드 HOF (Higher-Order Function)
 *
 * @example
 * export async function GET(request: NextRequest) {
 *   return withAuth(request, async (req) => {
 *     // req.userId, req.userTier 사용 가능
 *     return NextResponse.json({ data: 'protected' });
 *   });
 * }
 */
export async function withAuth(
  request: NextRequest,
  handler: (req: AuthenticatedRequest) => Promise<NextResponse>,
  options: AuthGuardOptions = {}
): Promise<NextResponse> {
  const { requireApproval = true, allowedTiers } = options;

  try {
    // 1. Bearer Token 추출
    const authHeader = request.headers.get('authorization');
    const token = extractBearerToken(authHeader);

    if (!token) {
      return NextResponse.json(
        {
          success: false,
          error: {
            code: ERROR_CODES.AUTH_003,
            message: ERROR_MESSAGES[ERROR_CODES.AUTH_003],
          },
        },
        { status: 401 }
      );
    }

    // 2. JWT 검증
    const payload = await verifyAccessToken(token);

    if (!payload || !payload.sub) {
      return NextResponse.json(
        {
          success: false,
          error: {
            code: ERROR_CODES.AUTH_003,
            message: '유효하지 않은 토큰입니다',
          },
        },
        { status: 401 }
      );
    }

    // 3. 사용자 프로필 조회
    const supabase = getSupabaseAdmin();
    const { data: profile, error } = await supabase
      .from('profiles')
      .select('tier, is_approved, deleted_at')
      .eq('id', payload.sub)
      .single();

    if (error || !profile) {
      return NextResponse.json(
        {
          success: false,
          error: {
            code: ERROR_CODES.AUTH_003,
            message: '사용자 정보를 찾을 수 없습니다',
          },
        },
        { status: 401 }
      );
    }

    // 4. 삭제된 계정 확인
    if (profile.deleted_at) {
      return NextResponse.json(
        {
          success: false,
          error: {
            code: ERROR_CODES.AUTH_006,
            message: ERROR_MESSAGES[ERROR_CODES.AUTH_006],
          },
        },
        { status: 403 }
      );
    }

    // 5. 승인 상태 확인
    if (requireApproval && !profile.is_approved) {
      return NextResponse.json(
        {
          success: false,
          error: {
            code: ERROR_CODES.AUTH_002,
            message: ERROR_MESSAGES[ERROR_CODES.AUTH_002],
          },
        },
        { status: 403 }
      );
    }

    // 6. 티어 확인
    if (allowedTiers && !allowedTiers.includes(profile.tier)) {
      return NextResponse.json(
        {
          success: false,
          error: {
            code: ERROR_CODES.GEN_003,
            message: '해당 기능에 대한 접근 권한이 없습니다',
          },
        },
        { status: 403 }
      );
    }

    // 7. 인증 정보를 요청에 추가
    const authenticatedRequest = request as AuthenticatedRequest;
    authenticatedRequest.userId = payload.sub;
    authenticatedRequest.userEmail = payload.email || '';
    authenticatedRequest.userTier = profile.tier;
    authenticatedRequest.tokenPayload = payload;

    // 8. 핸들러 실행
    return await handler(authenticatedRequest);
  } catch (error) {
    console.error('Auth guard error:', error);
    return NextResponse.json(
      {
        success: false,
        error: {
          code: ERROR_CODES.GEN_001,
          message: ERROR_MESSAGES[ERROR_CODES.GEN_001],
          reference: generateErrorReference(),
        },
      },
      { status: 500 }
    );
  }
}

/**
 * 관리자 전용 가드
 */
export async function withAdminAuth(
  request: NextRequest,
  handler: (req: AuthenticatedRequest) => Promise<NextResponse>
): Promise<NextResponse> {
  return withAuth(request, handler, {
    allowedTiers: ['ENTERPRISE'],
  });
}
```

### 5.2 Server Component Guard

```typescript
// src/lib/auth/server-guard.ts
/**
 * Server Component 인증 가드
 * 파일 위치: src/lib/auth/server-guard.ts
 * 용도: Server Component에서 인증 상태 확인
 */

import { redirect } from 'next/navigation';
import { getSupabaseServer } from '@/lib/supabase/server';

/**
 * 인증된 사용자 정보
 */
export interface AuthUser {
  id: string;
  email: string;
  fullName: string;
  tier: 'FREE' | 'PRO' | 'ENTERPRISE';
  isApproved: boolean;
}

/**
 * 인증 확인 및 사용자 정보 반환
 * 미인증 시 로그인 페이지로 리다이렉트
 */
export async function requireAuth(): Promise<AuthUser> {
  const supabase = await getSupabaseServer();

  const {
    data: { session },
  } = await supabase.auth.getSession();

  if (!session) {
    redirect('/login');
  }

  const { data: profile } = await supabase
    .from('profiles')
    .select('full_name, tier, is_approved, deleted_at')
    .eq('id', session.user.id)
    .single();

  if (profile?.deleted_at) {
    redirect('/account-deleted');
  }

  if (!profile?.is_approved) {
    redirect('/pending-approval');
  }

  return {
    id: session.user.id,
    email: session.user.email!,
    fullName: profile.full_name,
    tier: profile.tier,
    isApproved: profile.is_approved,
  };
}

/**
 * 인증 확인 (리다이렉트 없이)
 */
export async function getAuthUser(): Promise<AuthUser | null> {
  const supabase = await getSupabaseServer();

  const {
    data: { session },
  } = await supabase.auth.getSession();

  if (!session) {
    return null;
  }

  const { data: profile } = await supabase
    .from('profiles')
    .select('full_name, tier, is_approved, deleted_at')
    .eq('id', session.user.id)
    .single();

  if (!profile || profile.deleted_at || !profile.is_approved) {
    return null;
  }

  return {
    id: session.user.id,
    email: session.user.email!,
    fullName: profile.full_name,
    tier: profile.tier,
    isApproved: profile.is_approved,
  };
}
```

---

## 6. 세션 관리

### 6.1 세션 서비스

```typescript
// src/lib/auth/session.ts
/**
 * 세션 관리 서비스
 * 파일 위치: src/lib/auth/session.ts
 * 용도: 세션 생성, 조회, 무효화
 */

import { getSupabaseAdmin } from '@/lib/supabase/admin';

/**
 * 세션 정보 타입
 */
export interface UserSession {
  id: string;
  userId: string;
  ipAddress: string | null;
  userAgent: string | null;
  createdAt: string;
  invalidatedAt: string | null;
  isCurrent: boolean;
}

/**
 * 새 세션 생성
 */
export async function createSession(
  userId: string,
  ipAddress?: string,
  userAgent?: string
): Promise<string> {
  const supabase = getSupabaseAdmin();

  const { data, error } = await supabase
    .from('user_sessions')
    .insert({
      user_id: userId,
      ip_address: ipAddress,
      user_agent: userAgent,
    })
    .select('id')
    .single();

  if (error) {
    throw new Error(`Failed to create session: ${error.message}`);
  }

  return data.id;
}

/**
 * 사용자의 활성 세션 목록 조회
 */
export async function getUserSessions(
  userId: string,
  currentSessionId?: string
): Promise<UserSession[]> {
  const supabase = getSupabaseAdmin();

  const { data, error } = await supabase
    .from('user_sessions')
    .select('*')
    .eq('user_id', userId)
    .is('invalidated_at', null)
    .order('created_at', { ascending: false });

  if (error) {
    throw new Error(`Failed to get sessions: ${error.message}`);
  }

  return (data || []).map((session) => ({
    id: session.id,
    userId: session.user_id,
    ipAddress: session.ip_address,
    userAgent: session.user_agent,
    createdAt: session.created_at,
    invalidatedAt: session.invalidated_at,
    isCurrent: session.id === currentSessionId,
  }));
}

/**
 * 특정 세션 무효화
 */
export async function invalidateSession(sessionId: string): Promise<void> {
  const supabase = getSupabaseAdmin();

  await supabase
    .from('user_sessions')
    .update({ invalidated_at: new Date().toISOString() })
    .eq('id', sessionId);
}

/**
 * 사용자의 모든 세션 무효화
 */
export async function invalidateAllSessions(
  userId: string,
  excludeSessionId?: string
): Promise<number> {
  const supabase = getSupabaseAdmin();

  let query = supabase
    .from('user_sessions')
    .update({ invalidated_at: new Date().toISOString() })
    .eq('user_id', userId)
    .is('invalidated_at', null);

  if (excludeSessionId) {
    query = query.neq('id', excludeSessionId);
  }

  const { data } = await query.select('id');
  return data?.length || 0;
}

/**
 * 세션 유효성 확인
 */
export async function isSessionValid(
  userId: string,
  sessionId: string
): Promise<boolean> {
  const supabase = getSupabaseAdmin();

  const { data } = await supabase
    .from('user_sessions')
    .select('id')
    .eq('id', sessionId)
    .eq('user_id', userId)
    .is('invalidated_at', null)
    .single();

  return !!data;
}

/**
 * 오래된 세션 정리 (배치 작업용)
 * 30일 이상 된 무효화 세션 삭제
 */
export async function cleanupOldSessions(): Promise<number> {
  const supabase = getSupabaseAdmin();
  const cutoffDate = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);

  const { data } = await supabase
    .from('user_sessions')
    .delete()
    .lt('invalidated_at', cutoffDate.toISOString())
    .select('id');

  return data?.length || 0;
}
```

### 6.2 승인 상태 변경 시 세션 무효화

```typescript
// src/lib/auth/approval.ts
/**
 * 승인 시스템 서비스
 * 파일 위치: src/lib/auth/approval.ts
 * 용도: 관리자 승인/취소 처리
 */

import { getSupabaseAdmin } from '@/lib/supabase/admin';
import { revokeAllUserTokens } from './rotation';
import { invalidateAllSessions } from './session';

/**
 * 승인 상태 변경 결과
 */
export interface ApprovalResult {
  success: boolean;
  previousStatus: boolean;
  newStatus: boolean;
  sessionsInvalidated: number;
  error?: string;
}

/**
 * 사용자 승인
 */
export async function approveUser(
  userId: string,
  adminId: string
): Promise<ApprovalResult> {
  const supabase = getSupabaseAdmin();

  // 현재 상태 확인
  const { data: profile } = await supabase
    .from('profiles')
    .select('is_approved')
    .eq('id', userId)
    .single();

  if (!profile) {
    return {
      success: false,
      previousStatus: false,
      newStatus: false,
      sessionsInvalidated: 0,
      error: 'user_not_found',
    };
  }

  // 이미 승인됨
  if (profile.is_approved) {
    return {
      success: true,
      previousStatus: true,
      newStatus: true,
      sessionsInvalidated: 0,
    };
  }

  // 승인 처리
  await supabase
    .from('profiles')
    .update({ is_approved: true })
    .eq('id', userId);

  // 감사 로그
  await supabase.from('audit_logs').insert({
    user_id: userId,
    action: 'approval_change',
    details: {
      admin_id: adminId,
      previous_status: false,
      new_status: true,
    },
  });

  return {
    success: true,
    previousStatus: false,
    newStatus: true,
    sessionsInvalidated: 0,
  };
}

/**
 * 사용자 승인 취소
 * v2: 모든 세션 즉시 무효화
 */
export async function revokeApproval(
  userId: string,
  adminId: string
): Promise<ApprovalResult> {
  const supabase = getSupabaseAdmin();

  // 현재 상태 확인
  const { data: profile } = await supabase
    .from('profiles')
    .select('is_approved')
    .eq('id', userId)
    .single();

  if (!profile) {
    return {
      success: false,
      previousStatus: false,
      newStatus: false,
      sessionsInvalidated: 0,
      error: 'user_not_found',
    };
  }

  // 이미 미승인 상태
  if (!profile.is_approved) {
    return {
      success: true,
      previousStatus: false,
      newStatus: false,
      sessionsInvalidated: 0,
    };
  }

  // 승인 취소
  await supabase
    .from('profiles')
    .update({ is_approved: false })
    .eq('id', userId);

  // 모든 토큰 폐기
  await revokeAllUserTokens(userId);

  // 모든 세션 무효화
  const sessionsInvalidated = await invalidateAllSessions(userId);

  // 감사 로그
  await supabase.from('audit_logs').insert({
    user_id: userId,
    action: 'approval_change',
    details: {
      admin_id: adminId,
      previous_status: true,
      new_status: false,
      sessions_invalidated: sessionsInvalidated,
    },
  });

  return {
    success: true,
    previousStatus: true,
    newStatus: false,
    sessionsInvalidated,
  };
}
```

---

## 7. 클라이언트 사이드 인증 상태

### 7.1 Auth Store (Zustand)

```typescript
// src/store/auth.ts
/**
 * 인증 상태 스토어 (Zustand)
 * 파일 위치: src/store/auth.ts
 * 용도: 클라이언트 사이드 인증 상태 관리
 */

import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';

/**
 * 사용자 정보 타입
 */
export interface User {
  id: string;
  email: string;
  fullName: string;
  tier: 'FREE' | 'PRO' | 'ENTERPRISE';
}

/**
 * 인증 상태 타입
 */
export interface AuthState {
  // 상태
  user: User | null;
  accessToken: string | null;
  expiresAt: number | null;
  isAuthenticated: boolean;
  isLoading: boolean;

  // 액션
  setAuth: (user: User, accessToken: string, expiresIn: number) => void;
  clearAuth: () => void;
  setLoading: (isLoading: boolean) => void;
  updateAccessToken: (accessToken: string, expiresIn: number) => void;
}

export const useAuthStore = create<AuthState>()(
  persist(
    (set, get) => ({
      // 초기 상태
      user: null,
      accessToken: null,
      expiresAt: null,
      isAuthenticated: false,
      isLoading: true,

      // 로그인 성공 시
      setAuth: (user, accessToken, expiresIn) => {
        const expiresAt = Date.now() + expiresIn * 1000;
        set({
          user,
          accessToken,
          expiresAt,
          isAuthenticated: true,
          isLoading: false,
        });
      },

      // 로그아웃 또는 세션 만료 시
      clearAuth: () => {
        set({
          user: null,
          accessToken: null,
          expiresAt: null,
          isAuthenticated: false,
          isLoading: false,
        });
      },

      // 로딩 상태 변경
      setLoading: (isLoading) => {
        set({ isLoading });
      },

      // Access Token 갱신
      updateAccessToken: (accessToken, expiresIn) => {
        const expiresAt = Date.now() + expiresIn * 1000;
        set({ accessToken, expiresAt });
      },
    }),
    {
      name: 'auth-storage',
      storage: createJSONStorage(() => sessionStorage),
      // Access Token은 persist하지 않음 (보안)
      partialize: (state) => ({
        user: state.user,
        isAuthenticated: state.isAuthenticated,
      }),
    }
  )
);

/**
 * Access Token 가져오기 (자동 갱신 포함)
 */
export function useAccessToken(): string | null {
  const { accessToken, expiresAt, updateAccessToken, clearAuth } = useAuthStore();

  // 토큰이 없으면 null
  if (!accessToken) return null;

  // 만료 확인 (1분 버퍼)
  if (expiresAt && Date.now() > expiresAt - 60000) {
    // 자동 갱신 시도
    refreshAccessToken()
      .then((result) => {
        if (result.success) {
          updateAccessToken(result.accessToken!, result.expiresIn!);
        } else {
          clearAuth();
        }
      })
      .catch(() => {
        clearAuth();
      });
  }

  return accessToken;
}

/**
 * Access Token 갱신 API 호출
 */
async function refreshAccessToken(): Promise<{
  success: boolean;
  accessToken?: string;
  expiresIn?: number;
}> {
  try {
    const response = await fetch('/api/auth/refresh', {
      method: 'POST',
      credentials: 'include', // HttpOnly Cookie 포함
    });

    if (!response.ok) {
      return { success: false };
    }

    const data = await response.json();

    if (data.success) {
      return {
        success: true,
        accessToken: data.data.accessToken,
        expiresIn: data.data.expiresIn,
      };
    }

    return { success: false };
  } catch {
    return { success: false };
  }
}
```

### 7.2 Auth Provider

```typescript
// src/components/providers/AuthProvider.tsx
/**
 * 인증 Provider
 * 파일 위치: src/components/providers/AuthProvider.tsx
 * 용도: 앱 초기화 시 인증 상태 복원
 */

'use client';

import { useEffect, ReactNode } from 'react';
import { useRouter, usePathname } from 'next/navigation';
import { useAuthStore } from '@/store/auth';

interface AuthProviderProps {
  children: ReactNode;
}

// 인증 불필요 경로
const PUBLIC_PATHS = [
  '/login',
  '/signup',
  '/forgot-password',
  '/pending-approval',
  '/account-deleted',
];

export function AuthProvider({ children }: AuthProviderProps) {
  const router = useRouter();
  const pathname = usePathname();
  const { isAuthenticated, isLoading, setLoading, setAuth, clearAuth } = useAuthStore();

  useEffect(() => {
    // 앱 초기화 시 세션 복원 시도
    async function initAuth() {
      try {
        const response = await fetch('/api/auth/refresh', {
          method: 'POST',
          credentials: 'include',
        });

        if (response.ok) {
          const data = await response.json();

          if (data.success) {
            // 사용자 정보 조회
            const userResponse = await fetch('/api/auth/me', {
              headers: {
                Authorization: `Bearer ${data.data.accessToken}`,
              },
            });

            if (userResponse.ok) {
              const userData = await userResponse.json();
              setAuth(userData.data, data.data.accessToken, data.data.expiresIn);
              return;
            }
          }
        }

        clearAuth();
      } catch (error) {
        console.error('Auth initialization failed:', error);
        clearAuth();
      }
    }

    initAuth();
  }, [setAuth, clearAuth]);

  useEffect(() => {
    // 인증 필요 경로에서 미인증 시 리다이렉트
    if (!isLoading && !isAuthenticated && !PUBLIC_PATHS.includes(pathname)) {
      router.push(`/login?redirect=${encodeURIComponent(pathname)}`);
    }
  }, [isLoading, isAuthenticated, pathname, router]);

  // 로딩 중 표시
  if (isLoading) {
    return (
      <div className="flex min-h-screen items-center justify-center">
        <div className="h-8 w-8 animate-spin rounded-full border-4 border-primary border-t-transparent" />
      </div>
    );
  }

  return <>{children}</>;
}
```

### 7.3 useAuth Hook

```typescript
// src/hooks/useAuth.ts
/**
 * 인증 훅
 * 파일 위치: src/hooks/useAuth.ts
 * 용도: 컴포넌트에서 인증 관련 기능 사용
 */

import { useCallback } from 'react';
import { useRouter } from 'next/navigation';
import { useAuthStore, User } from '@/store/auth';

export interface LoginParams {
  email: string;
  password: string;
}

export interface SignupParams {
  email: string;
  password: string;
  fullName: string;
  agreeTerms: boolean;
  agreePrivacy: boolean;
  agreeMarketing?: boolean;
}

export interface AuthError {
  code: string;
  message: string;
}

export function useAuth() {
  const router = useRouter();
  const { user, isAuthenticated, setAuth, clearAuth, setLoading } = useAuthStore();

  /**
   * 로그인
   */
  const login = useCallback(async (params: LoginParams): Promise<{ success: boolean; error?: AuthError }> => {
    setLoading(true);

    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify(params),
      });

      const data = await response.json();

      if (data.success) {
        setAuth(data.data.user, data.data.accessToken, data.data.expiresIn);
        return { success: true };
      }

      setLoading(false);
      return { success: false, error: data.error };
    } catch (error) {
      setLoading(false);
      return {
        success: false,
        error: { code: 'GEN_001', message: '로그인 중 오류가 발생했습니다' },
      };
    }
  }, [setAuth, setLoading]);

  /**
   * 회원가입
   */
  const signup = useCallback(async (params: SignupParams): Promise<{ success: boolean; error?: AuthError }> => {
    setLoading(true);

    try {
      const response = await fetch('/api/auth/signup', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(params),
      });

      const data = await response.json();

      setLoading(false);

      if (data.success) {
        return { success: true };
      }

      return { success: false, error: data.error };
    } catch (error) {
      setLoading(false);
      return {
        success: false,
        error: { code: 'GEN_001', message: '회원가입 중 오류가 발생했습니다' },
      };
    }
  }, [setLoading]);

  /**
   * 로그아웃
   */
  const logout = useCallback(async () => {
    try {
      await fetch('/api/auth/logout', {
        method: 'POST',
        credentials: 'include',
      });
    } catch (error) {
      console.error('Logout error:', error);
    } finally {
      clearAuth();
      router.push('/login');
    }
  }, [clearAuth, router]);

  /**
   * 전체 로그아웃 (모든 기기)
   */
  const logoutAll = useCallback(async () => {
    const { accessToken } = useAuthStore.getState();

    try {
      await fetch('/api/auth/logout-all', {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${accessToken}`,
        },
        credentials: 'include',
      });
    } catch (error) {
      console.error('Logout all error:', error);
    } finally {
      clearAuth();
      router.push('/login');
    }
  }, [clearAuth, router]);

  return {
    user,
    isAuthenticated,
    login,
    signup,
    logout,
    logoutAll,
  };
}
```

---

## 8. Rate Limiting

### 8.1 Rate Limit 미들웨어

```typescript
// src/lib/security/rate-limit.ts
/**
 * Rate Limit 미들웨어
 * 파일 위치: src/lib/security/rate-limit.ts
 * 용도: API 요청 제한 (PostgreSQL 기반)
 */

import { NextRequest, NextResponse } from 'next/server';
import { getSupabaseAdmin } from '@/lib/supabase/admin';
import { ERROR_CODES, ERROR_MESSAGES } from '@/lib/constants/errors';

/**
 * Rate Limit 설정
 */
export interface RateLimitConfig {
  limit: number;          // 허용 요청 수
  windowSeconds: number;  // 윈도우 크기 (초)
}

/**
 * 엔드포인트별 Rate Limit 설정
 */
export const RATE_LIMITS: Record<string, RateLimitConfig> = {
  // 인증
  '/api/auth/signup': { limit: 3, windowSeconds: 60 },
  '/api/auth/login': { limit: 5, windowSeconds: 60 },
  '/api/auth/refresh': { limit: 10, windowSeconds: 60 },

  // AI
  '/api/ai/generate': { limit: 10, windowSeconds: 60 },
  '/api/ai/chat': { limit: 30, windowSeconds: 60 },

  // 랜딩페이지
  '/api/lp': { limit: 60, windowSeconds: 60 },

  // 기본값
  default: { limit: 100, windowSeconds: 60 },
};

/**
 * Rate Limit 체크 결과
 */
export interface RateLimitResult {
  allowed: boolean;
  current: number;
  limit: number;
  remaining?: number;
  resetAt?: Date;
}

/**
 * Rate Limit 체크
 */
export async function checkRateLimit(
  identifier: string,
  endpoint: string
): Promise<RateLimitResult> {
  const supabase = getSupabaseAdmin();
  const config = RATE_LIMITS[endpoint] || RATE_LIMITS.default;

  const { data, error } = await supabase.rpc('check_rate_limit', {
    p_identifier: identifier,
    p_endpoint: endpoint,
    p_limit: config.limit,
    p_window_seconds: config.windowSeconds,
  });

  if (error) {
    console.error('Rate limit check error:', error);
    // 에러 시 허용 (fail-open)
    return { allowed: true, current: 0, limit: config.limit };
  }

  return {
    allowed: data.allowed,
    current: data.current,
    limit: data.limit,
    remaining: data.remaining,
    resetAt: data.reset_at ? new Date(data.reset_at) : undefined,
  };
}

/**
 * Rate Limit HOF
 */
export async function withRateLimit(
  request: NextRequest,
  handler: () => Promise<NextResponse>
): Promise<NextResponse> {
  const pathname = new URL(request.url).pathname;

  // 식별자: IP + User ID (인증된 경우)
  const ip = request.headers.get('x-forwarded-for')?.split(',')[0] || 'unknown';
  const authHeader = request.headers.get('authorization');
  const userId = authHeader ? 'auth:' + extractUserIdFromToken(authHeader) : '';
  const identifier = userId || `ip:${ip}`;

  const result = await checkRateLimit(identifier, pathname);

  if (!result.allowed) {
    // 감사 로그
    const supabase = getSupabaseAdmin();
    await supabase.from('audit_logs').insert({
      user_id: userId ? userId.replace('auth:', '') : null,
      action: 'rate_limit_exceeded',
      details: {
        endpoint: pathname,
        current: result.current,
        limit: result.limit,
      },
      ip_address: ip,
    });

    const response = NextResponse.json(
      {
        success: false,
        error: {
          code: ERROR_CODES.RATE_001,
          message: ERROR_MESSAGES[ERROR_CODES.RATE_001],
        },
      },
      { status: 429 }
    );

    // Rate Limit 헤더 설정
    response.headers.set('X-RateLimit-Limit', String(result.limit));
    response.headers.set('X-RateLimit-Remaining', '0');
    response.headers.set('X-RateLimit-Reset', result.resetAt?.toISOString() || '');
    response.headers.set(
      'Retry-After',
      String(Math.ceil((result.resetAt?.getTime() || Date.now() + 60000 - Date.now()) / 1000))
    );

    return response;
  }

  // 핸들러 실행
  const response = await handler();

  // Rate Limit 헤더 추가
  response.headers.set('X-RateLimit-Limit', String(result.limit));
  response.headers.set('X-RateLimit-Remaining', String(result.remaining || 0));
  response.headers.set('X-RateLimit-Reset', result.resetAt?.toISOString() || '');

  return response;
}

/**
 * 토큰에서 사용자 ID 추출 (간단 버전)
 */
function extractUserIdFromToken(authHeader: string): string {
  try {
    const token = authHeader.replace('Bearer ', '');
    const payload = JSON.parse(atob(token.split('.')[1]));
    return payload.sub || '';
  } catch {
    return '';
  }
}
```

---

## 9. 구현 체크리스트

### 9.1 Supabase 설정
- [ ] 환경 변수 설정 (SUPABASE_URL, ANON_KEY, SERVICE_ROLE_KEY)
- [ ] Supabase Dashboard에서 Auth 설정
- [ ] JWT Secret 확인
- [ ] Email Template 설정

### 9.2 인증 API
- [ ] POST /api/auth/signup
- [ ] POST /api/auth/login
- [ ] POST /api/auth/refresh
- [ ] POST /api/auth/logout
- [ ] POST /api/auth/logout-all
- [ ] GET /api/auth/me

### 9.3 토큰 관리
- [ ] Access Token 검증 (JWT)
- [ ] Refresh Token 저장 (HttpOnly Cookie)
- [ ] Token Rotation 구현
- [ ] 재사용 감지 및 세션 무효화

### 9.4 세션 관리
- [ ] user_sessions 테이블 사용
- [ ] 세션 생성/조회/무효화
- [ ] 승인 상태 변경 시 전체 세션 무효화
- [ ] 세션 목록 API

### 9.5 클라이언트
- [ ] Zustand Auth Store
- [ ] AuthProvider
- [ ] useAuth Hook
- [ ] 자동 토큰 갱신

### 9.6 보안
- [ ] CORS 설정 (명시적 화이트리스트)
- [ ] Rate Limiting (PostgreSQL 기반)
- [ ] 미들웨어 인증 체크
- [ ] 감사 로그

---

**이전 문서: [03_API_명세.md](./03_API_명세.md)**
**다음 문서: [05_AI_통합.md](./05_AI_통합.md)**
