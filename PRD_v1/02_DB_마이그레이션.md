# Magnetic Sales WebApp - DB 마이그레이션

## 문서 정보

| 항목 | 내용 |
|------|------|
| 문서 버전 | 1.0 |
| 작성일 | 2025-12-15 |
| 이전 문서 | [01_프로젝트_구조.md](./01_프로젝트_구조.md) |
| 다음 문서 | [03_API_명세.md](./03_API_명세.md) |

---

## 1. 마이그레이션 개요

### 1.1 실행 순서

```
1. 00_extensions.sql     - PostgreSQL 확장 활성화
2. 01_functions.sql      - 공통 함수 생성
3. 02_profiles.sql       - profiles 테이블
4. 03_landing_pages.sql  - landing_pages 테이블
5. 04_qa_sessions.sql    - qa_sessions 테이블
6. 05_token_tables.sql   - token_usage, token_reservations
7. 06_auth_tables.sql    - refresh_tokens, user_sessions
8. 07_audit_tables.sql   - audit_logs, rate_limits
9. 08_triggers.sql       - 트리거 설정
10. 09_seed_data.sql     - 시드 데이터 (개발용)
```

### 1.2 파일 위치

```
supabase/
└── migrations/
    ├── 00_extensions.sql
    ├── 01_functions.sql
    ├── 02_profiles.sql
    ├── 03_landing_pages.sql
    ├── 04_qa_sessions.sql
    ├── 05_token_tables.sql
    ├── 06_auth_tables.sql
    ├── 07_audit_tables.sql
    ├── 08_triggers.sql
    └── 09_seed_data.sql
```

---

## 2. 마이그레이션 스크립트

### 2.1 00_extensions.sql

```sql
-- =============================================================================
-- 파일: 00_extensions.sql
-- 설명: PostgreSQL 확장 활성화
-- 실행: Supabase Dashboard > SQL Editor 또는 supabase db push
-- =============================================================================

-- UUID 생성 함수 (기본 활성화되어 있음)
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- pg_cron 확장 (스케줄링용 - Supabase Pro 이상)
-- CREATE EXTENSION IF NOT EXISTS pg_cron;

-- 확인
SELECT * FROM pg_extension;
```

### 2.2 01_functions.sql

```sql
-- =============================================================================
-- 파일: 01_functions.sql
-- 설명: 공통 함수 정의
-- =============================================================================

-- -----------------------------------------------------------------------------
-- 1. updated_at 자동 갱신 함수
-- -----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION update_updated_at_column() IS
'트리거용: updated_at 컬럼을 현재 시간으로 자동 갱신';

-- -----------------------------------------------------------------------------
-- 2. Rate Limit 체크 함수 (v2)
-- -----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION check_rate_limit(
    p_identifier TEXT,
    p_endpoint TEXT,
    p_limit INTEGER,
    p_window_seconds INTEGER
)
RETURNS JSONB AS $$
DECLARE
    v_window_start TIMESTAMPTZ;
    v_current_count INTEGER;
BEGIN
    -- 슬라이딩 윈도우 시작 시간 계산
    v_window_start := DATE_TRUNC('second', NOW())
        - (EXTRACT(EPOCH FROM NOW())::INTEGER % p_window_seconds) * INTERVAL '1 second';

    -- UPSERT: 카운트 증가 또는 새 레코드 생성
    INSERT INTO rate_limits (identifier, endpoint, request_count, window_start)
    VALUES (p_identifier, p_endpoint, 1, v_window_start)
    ON CONFLICT (identifier, endpoint, window_start)
    DO UPDATE SET request_count = rate_limits.request_count + 1
    RETURNING request_count INTO v_current_count;

    -- 제한 초과 확인
    IF v_current_count > p_limit THEN
        RETURN jsonb_build_object(
            'allowed', FALSE,
            'current', v_current_count,
            'limit', p_limit,
            'reset_at', v_window_start + (p_window_seconds * INTERVAL '1 second')
        );
    END IF;

    RETURN jsonb_build_object(
        'allowed', TRUE,
        'current', v_current_count,
        'limit', p_limit,
        'remaining', p_limit - v_current_count
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION check_rate_limit(TEXT, TEXT, INTEGER, INTEGER) IS
'Rate Limit 체크 및 카운트 증가. 허용 여부와 남은 횟수 반환.';

-- -----------------------------------------------------------------------------
-- 3. 토큰 예약 함수 (v2 - Advisory Lock 사용)
-- -----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION check_and_reserve_tokens(
    p_user_id UUID,
    p_estimated_tokens INTEGER
)
RETURNS JSONB AS $$
DECLARE
    v_tier TEXT;
    v_daily_limit INTEGER;
    v_used_today INTEGER;
    v_reserved_pending INTEGER;
    v_available INTEGER;
    v_reservation_id UUID;
BEGIN
    -- Advisory Lock 획득 (사용자별 직렬화)
    PERFORM pg_advisory_xact_lock(hashtext(p_user_id::text));

    -- 사용자 티어 확인
    SELECT tier INTO v_tier
    FROM profiles
    WHERE id = p_user_id AND deleted_at IS NULL;

    IF v_tier IS NULL THEN
        RETURN jsonb_build_object(
            'success', FALSE,
            'error', 'user_not_found',
            'message', '사용자를 찾을 수 없습니다'
        );
    END IF;

    -- 티어별 일일 한도
    v_daily_limit := CASE v_tier
        WHEN 'FREE' THEN 100000
        WHEN 'PRO' THEN 500000
        WHEN 'ENTERPRISE' THEN 2000000
        ELSE 100000
    END;

    -- 오늘 사용량 조회
    SELECT COALESCE(SUM(tokens_used), 0) INTO v_used_today
    FROM token_usage
    WHERE user_id = p_user_id
      AND created_at >= DATE_TRUNC('day', NOW() AT TIME ZONE 'UTC');

    -- 대기 중인 예약량 조회 (10분 이내)
    SELECT COALESCE(SUM(estimated_tokens), 0) INTO v_reserved_pending
    FROM token_reservations
    WHERE user_id = p_user_id
      AND status = 'reserved'
      AND created_at > NOW() - INTERVAL '10 minutes';

    -- 사용 가능 토큰 계산
    v_available := v_daily_limit - v_used_today - v_reserved_pending;

    IF v_available < p_estimated_tokens THEN
        RETURN jsonb_build_object(
            'success', FALSE,
            'error', 'insufficient_tokens',
            'message', '토큰이 부족합니다',
            'available', v_available,
            'requested', p_estimated_tokens,
            'daily_limit', v_daily_limit,
            'used_today', v_used_today,
            'reserved', v_reserved_pending
        );
    END IF;

    -- 예약 생성
    INSERT INTO token_reservations (user_id, estimated_tokens, status)
    VALUES (p_user_id, p_estimated_tokens, 'reserved')
    RETURNING id INTO v_reservation_id;

    RETURN jsonb_build_object(
        'success', TRUE,
        'reservation_id', v_reservation_id,
        'available_after', v_available - p_estimated_tokens,
        'daily_limit', v_daily_limit,
        'used_today', v_used_today
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION check_and_reserve_tokens(UUID, INTEGER) IS
'토큰 예약 함수. Advisory Lock으로 Race Condition 방지. 예약 ID 반환.';

-- -----------------------------------------------------------------------------
-- 4. 토큰 확정 함수
-- -----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION confirm_token_usage(
    p_reservation_id UUID,
    p_actual_tokens INTEGER
)
RETURNS JSONB AS $$
DECLARE
    v_reservation RECORD;
BEGIN
    -- 예약 조회 및 업데이트
    UPDATE token_reservations
    SET
        status = 'confirmed',
        actual_tokens = p_actual_tokens,
        confirmed_at = NOW()
    WHERE id = p_reservation_id AND status = 'reserved'
    RETURNING * INTO v_reservation;

    IF v_reservation IS NULL THEN
        RETURN jsonb_build_object(
            'success', FALSE,
            'error', 'reservation_not_found',
            'message', '예약을 찾을 수 없습니다'
        );
    END IF;

    -- token_usage에 실제 사용량 기록
    INSERT INTO token_usage (user_id, tokens_used, action, metadata)
    VALUES (
        v_reservation.user_id,
        p_actual_tokens,
        'generate',
        jsonb_build_object('reservation_id', p_reservation_id)
    );

    RETURN jsonb_build_object(
        'success', TRUE,
        'estimated', v_reservation.estimated_tokens,
        'actual', p_actual_tokens,
        'difference', v_reservation.estimated_tokens - p_actual_tokens
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION confirm_token_usage(UUID, INTEGER) IS
'토큰 사용 확정. 예약 상태를 confirmed로 변경하고 token_usage에 기록.';

-- -----------------------------------------------------------------------------
-- 5. 토큰 예약 취소 함수
-- -----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION cancel_token_reservation(
    p_reservation_id UUID
)
RETURNS JSONB AS $$
DECLARE
    v_updated INTEGER;
BEGIN
    UPDATE token_reservations
    SET status = 'cancelled'
    WHERE id = p_reservation_id AND status = 'reserved';

    GET DIAGNOSTICS v_updated = ROW_COUNT;

    IF v_updated = 0 THEN
        RETURN jsonb_build_object(
            'success', FALSE,
            'error', 'reservation_not_found'
        );
    END IF;

    RETURN jsonb_build_object('success', TRUE);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- -----------------------------------------------------------------------------
-- 6. 만료된 예약 정리 함수
-- -----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION cleanup_expired_reservations()
RETURNS INTEGER AS $$
DECLARE
    v_count INTEGER;
BEGIN
    UPDATE token_reservations
    SET status = 'expired'
    WHERE status = 'reserved'
      AND created_at < NOW() - INTERVAL '10 minutes';

    GET DIAGNOSTICS v_count = ROW_COUNT;
    RETURN v_count;
END;
$$ LANGUAGE plpgsql;

-- -----------------------------------------------------------------------------
-- 7. 오래된 Rate Limit 정리 함수
-- -----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION cleanup_old_rate_limits()
RETURNS INTEGER AS $$
DECLARE
    v_count INTEGER;
BEGIN
    DELETE FROM rate_limits
    WHERE window_start < NOW() - INTERVAL '1 hour';

    GET DIAGNOSTICS v_count = ROW_COUNT;
    RETURN v_count;
END;
$$ LANGUAGE plpgsql;

-- -----------------------------------------------------------------------------
-- 8. 토큰 사용량 조회 함수
-- -----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION get_token_usage_summary(
    p_user_id UUID
)
RETURNS JSONB AS $$
DECLARE
    v_tier TEXT;
    v_daily_limit INTEGER;
    v_used_today INTEGER;
    v_reserved_pending INTEGER;
BEGIN
    -- 사용자 티어 확인
    SELECT tier INTO v_tier
    FROM profiles
    WHERE id = p_user_id AND deleted_at IS NULL;

    IF v_tier IS NULL THEN
        RETURN jsonb_build_object('error', 'user_not_found');
    END IF;

    -- 티어별 일일 한도
    v_daily_limit := CASE v_tier
        WHEN 'FREE' THEN 100000
        WHEN 'PRO' THEN 500000
        WHEN 'ENTERPRISE' THEN 2000000
        ELSE 100000
    END;

    -- 오늘 사용량
    SELECT COALESCE(SUM(tokens_used), 0) INTO v_used_today
    FROM token_usage
    WHERE user_id = p_user_id
      AND created_at >= DATE_TRUNC('day', NOW() AT TIME ZONE 'UTC');

    -- 대기 중인 예약량
    SELECT COALESCE(SUM(estimated_tokens), 0) INTO v_reserved_pending
    FROM token_reservations
    WHERE user_id = p_user_id
      AND status = 'reserved'
      AND created_at > NOW() - INTERVAL '10 minutes';

    RETURN jsonb_build_object(
        'tier', v_tier,
        'daily_limit', v_daily_limit,
        'used_today', v_used_today,
        'reserved', v_reserved_pending,
        'available', v_daily_limit - v_used_today - v_reserved_pending,
        'reset_at', (DATE_TRUNC('day', NOW() AT TIME ZONE 'UTC') + INTERVAL '1 day')::TEXT
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

### 2.3 02_profiles.sql

```sql
-- =============================================================================
-- 파일: 02_profiles.sql
-- 설명: profiles 테이블 (사용자 프로필)
-- =============================================================================

-- -----------------------------------------------------------------------------
-- 테이블 생성
-- -----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT NOT NULL,
    tier TEXT NOT NULL DEFAULT 'FREE' CHECK (tier IN ('FREE', 'PRO', 'ENTERPRISE')),
    is_approved BOOLEAN NOT NULL DEFAULT FALSE,
    agree_marketing BOOLEAN NOT NULL DEFAULT FALSE,
    deleted_at TIMESTAMPTZ,  -- v2: Soft Delete
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 테이블 코멘트
COMMENT ON TABLE profiles IS '사용자 프로필 테이블';
COMMENT ON COLUMN profiles.tier IS '사용자 등급: FREE, PRO, ENTERPRISE';
COMMENT ON COLUMN profiles.is_approved IS '관리자 승인 여부';
COMMENT ON COLUMN profiles.deleted_at IS 'Soft Delete 시간 (NULL이면 활성)';

-- -----------------------------------------------------------------------------
-- 인덱스
-- -----------------------------------------------------------------------------
CREATE INDEX IF NOT EXISTS idx_profiles_email ON profiles(email);
CREATE INDEX IF NOT EXISTS idx_profiles_tier ON profiles(tier);
CREATE INDEX IF NOT EXISTS idx_profiles_is_approved ON profiles(is_approved);
CREATE INDEX IF NOT EXISTS idx_profiles_deleted_at ON profiles(deleted_at)
    WHERE deleted_at IS NULL;

-- -----------------------------------------------------------------------------
-- 트리거 (updated_at 자동 갱신)
-- -----------------------------------------------------------------------------
DROP TRIGGER IF EXISTS update_profiles_updated_at ON profiles;
CREATE TRIGGER update_profiles_updated_at
    BEFORE UPDATE ON profiles
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- -----------------------------------------------------------------------------
-- RLS (Row Level Security)
-- -----------------------------------------------------------------------------
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;

-- 기존 정책 삭제 (재실행 대비)
DROP POLICY IF EXISTS "Users can view own profile" ON profiles;
DROP POLICY IF EXISTS "Users can update own profile" ON profiles;
DROP POLICY IF EXISTS "Admins can view all profiles" ON profiles;
DROP POLICY IF EXISTS "Admins can update approval status" ON profiles;

-- 사용자: 자신의 프로필만 조회 (삭제되지 않은 것만)
CREATE POLICY "Users can view own profile"
    ON profiles FOR SELECT
    USING (
        auth.uid() = id
        AND deleted_at IS NULL
    );

-- 사용자: 자신의 프로필만 수정 (삭제되지 않은 것만)
CREATE POLICY "Users can update own profile"
    ON profiles FOR UPDATE
    USING (
        auth.uid() = id
        AND deleted_at IS NULL
    )
    WITH CHECK (
        auth.uid() = id
        AND deleted_at IS NULL
    );

-- 관리자: 모든 프로필 조회
CREATE POLICY "Admins can view all profiles"
    ON profiles FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM profiles
            WHERE id = auth.uid()
            AND tier = 'ENTERPRISE'
            AND deleted_at IS NULL
        )
    );

-- 관리자: 승인 상태 변경
CREATE POLICY "Admins can update approval status"
    ON profiles FOR UPDATE
    USING (
        EXISTS (
            SELECT 1 FROM profiles
            WHERE id = auth.uid()
            AND tier = 'ENTERPRISE'
            AND deleted_at IS NULL
        )
    );

-- -----------------------------------------------------------------------------
-- 회원가입 시 프로필 자동 생성 트리거
-- -----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO profiles (id, email, full_name)
    VALUES (
        NEW.id,
        NEW.email,
        COALESCE(NEW.raw_user_meta_data->>'full_name', 'Unknown')
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW
    EXECUTE FUNCTION handle_new_user();
```

### 2.4 03_landing_pages.sql

```sql
-- =============================================================================
-- 파일: 03_landing_pages.sql
-- 설명: landing_pages 테이블 (랜딩페이지)
-- =============================================================================

-- -----------------------------------------------------------------------------
-- 테이블 생성
-- -----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS landing_pages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
    qa_session_id UUID,  -- FK는 qa_sessions 생성 후 추가
    title TEXT NOT NULL,
    content JSONB NOT NULL DEFAULT '{}',
    status TEXT NOT NULL DEFAULT 'draft' CHECK (status IN ('draft', 'published', 'archived')),
    slug TEXT UNIQUE,
    published_url TEXT,
    deleted_at TIMESTAMPTZ,  -- v2: Soft Delete
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 테이블 코멘트
COMMENT ON TABLE landing_pages IS '랜딩페이지 테이블';
COMMENT ON COLUMN landing_pages.content IS 'JSON 형식의 랜딩페이지 콘텐츠';
COMMENT ON COLUMN landing_pages.status IS '상태: draft, published, archived';
COMMENT ON COLUMN landing_pages.slug IS '공개 URL용 고유 식별자';
COMMENT ON COLUMN landing_pages.deleted_at IS 'Soft Delete 시간 (NULL이면 활성)';

-- -----------------------------------------------------------------------------
-- 인덱스
-- -----------------------------------------------------------------------------
CREATE INDEX IF NOT EXISTS idx_landing_pages_user_id ON landing_pages(user_id);
CREATE INDEX IF NOT EXISTS idx_landing_pages_status ON landing_pages(status);
CREATE INDEX IF NOT EXISTS idx_landing_pages_slug ON landing_pages(slug);
CREATE INDEX IF NOT EXISTS idx_landing_pages_deleted_at ON landing_pages(deleted_at)
    WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_landing_pages_user_deleted ON landing_pages(user_id, deleted_at);

-- -----------------------------------------------------------------------------
-- 트리거
-- -----------------------------------------------------------------------------
DROP TRIGGER IF EXISTS update_landing_pages_updated_at ON landing_pages;
CREATE TRIGGER update_landing_pages_updated_at
    BEFORE UPDATE ON landing_pages
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- -----------------------------------------------------------------------------
-- RLS
-- -----------------------------------------------------------------------------
ALTER TABLE landing_pages ENABLE ROW LEVEL SECURITY;

-- 기존 정책 삭제
DROP POLICY IF EXISTS "Users can view own active landing pages" ON landing_pages;
DROP POLICY IF EXISTS "Users can view own deleted landing pages for recovery" ON landing_pages;
DROP POLICY IF EXISTS "Users can create landing pages" ON landing_pages;
DROP POLICY IF EXISTS "Users can update own active landing pages" ON landing_pages;
DROP POLICY IF EXISTS "Users can soft delete own landing pages" ON landing_pages;
DROP POLICY IF EXISTS "Anyone can view published landing pages" ON landing_pages;

-- 활성 랜딩페이지 조회
CREATE POLICY "Users can view own active landing pages"
    ON landing_pages FOR SELECT
    USING (
        user_id = auth.uid()
        AND deleted_at IS NULL
    );

-- 삭제된 랜딩페이지 조회 (복구용, 30일 이내)
CREATE POLICY "Users can view own deleted landing pages for recovery"
    ON landing_pages FOR SELECT
    USING (
        user_id = auth.uid()
        AND deleted_at IS NOT NULL
        AND deleted_at > NOW() - INTERVAL '30 days'
    );

-- 생성
CREATE POLICY "Users can create landing pages"
    ON landing_pages FOR INSERT
    WITH CHECK (user_id = auth.uid());

-- 수정 (삭제되지 않은 것만)
CREATE POLICY "Users can update own active landing pages"
    ON landing_pages FOR UPDATE
    USING (
        user_id = auth.uid()
        AND deleted_at IS NULL
    )
    WITH CHECK (user_id = auth.uid());

-- Soft Delete용 UPDATE
CREATE POLICY "Users can soft delete own landing pages"
    ON landing_pages FOR UPDATE
    USING (user_id = auth.uid())
    WITH CHECK (user_id = auth.uid());

-- 공개 랜딩페이지 조회 (배포된 것만, 인증 불필요)
CREATE POLICY "Anyone can view published landing pages"
    ON landing_pages FOR SELECT
    USING (
        status = 'published'
        AND deleted_at IS NULL
    );

-- -----------------------------------------------------------------------------
-- Slug 자동 생성 함수
-- -----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION generate_unique_slug(p_title TEXT)
RETURNS TEXT AS $$
DECLARE
    v_base_slug TEXT;
    v_slug TEXT;
    v_counter INTEGER := 0;
BEGIN
    -- 기본 slug 생성 (영문, 숫자, 하이픈만)
    v_base_slug := LOWER(REGEXP_REPLACE(p_title, '[^a-zA-Z0-9]+', '-', 'g'));
    v_base_slug := TRIM(BOTH '-' FROM v_base_slug);
    v_base_slug := SUBSTRING(v_base_slug FROM 1 FOR 50);  -- 최대 50자

    -- 빈 경우 랜덤 생성
    IF v_base_slug = '' THEN
        v_base_slug := 'page-' || SUBSTRING(gen_random_uuid()::TEXT FROM 1 FOR 8);
    END IF;

    v_slug := v_base_slug;

    -- 중복 체크 및 카운터 추가
    WHILE EXISTS (SELECT 1 FROM landing_pages WHERE slug = v_slug) LOOP
        v_counter := v_counter + 1;
        v_slug := v_base_slug || '-' || v_counter;
    END LOOP;

    RETURN v_slug;
END;
$$ LANGUAGE plpgsql;
```

### 2.5 04_qa_sessions.sql

```sql
-- =============================================================================
-- 파일: 04_qa_sessions.sql
-- 설명: qa_sessions 테이블 (Q&A 세션)
-- =============================================================================

-- -----------------------------------------------------------------------------
-- 테이블 생성
-- -----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS qa_sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
    landing_page_id UUID REFERENCES landing_pages(id) ON DELETE SET NULL,
    answers JSONB NOT NULL DEFAULT '{}',
    current_step INTEGER NOT NULL DEFAULT 1 CHECK (current_step BETWEEN 1 AND 40),
    status TEXT NOT NULL DEFAULT 'in_progress' CHECK (status IN ('in_progress', 'completed', 'abandoned')),
    deleted_at TIMESTAMPTZ,  -- v2: Soft Delete
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 테이블 코멘트
COMMENT ON TABLE qa_sessions IS 'Q&A 세션 테이블 (40개 질문)';
COMMENT ON COLUMN qa_sessions.answers IS 'JSON 형식: {"q1": "답변1", "q2": "답변2", ...}';
COMMENT ON COLUMN qa_sessions.current_step IS '현재 질문 단계 (1-40)';
COMMENT ON COLUMN qa_sessions.status IS '상태: in_progress, completed, abandoned';

-- landing_pages에 FK 추가
ALTER TABLE landing_pages
    ADD CONSTRAINT fk_landing_pages_qa_session
    FOREIGN KEY (qa_session_id) REFERENCES qa_sessions(id) ON DELETE SET NULL;

-- -----------------------------------------------------------------------------
-- 인덱스
-- -----------------------------------------------------------------------------
CREATE INDEX IF NOT EXISTS idx_qa_sessions_user_id ON qa_sessions(user_id);
CREATE INDEX IF NOT EXISTS idx_qa_sessions_status ON qa_sessions(status);
CREATE INDEX IF NOT EXISTS idx_qa_sessions_deleted_at ON qa_sessions(deleted_at)
    WHERE deleted_at IS NULL;

-- -----------------------------------------------------------------------------
-- 트리거
-- -----------------------------------------------------------------------------
DROP TRIGGER IF EXISTS update_qa_sessions_updated_at ON qa_sessions;
CREATE TRIGGER update_qa_sessions_updated_at
    BEFORE UPDATE ON qa_sessions
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- -----------------------------------------------------------------------------
-- RLS
-- -----------------------------------------------------------------------------
ALTER TABLE qa_sessions ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own active sessions" ON qa_sessions;
DROP POLICY IF EXISTS "Users can create sessions" ON qa_sessions;
DROP POLICY IF EXISTS "Users can update own active sessions" ON qa_sessions;

CREATE POLICY "Users can view own active sessions"
    ON qa_sessions FOR SELECT
    USING (
        user_id = auth.uid()
        AND deleted_at IS NULL
    );

CREATE POLICY "Users can create sessions"
    ON qa_sessions FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update own active sessions"
    ON qa_sessions FOR UPDATE
    USING (
        user_id = auth.uid()
        AND deleted_at IS NULL
    )
    WITH CHECK (user_id = auth.uid());
```

### 2.6 05_token_tables.sql

```sql
-- =============================================================================
-- 파일: 05_token_tables.sql
-- 설명: token_usage, token_reservations 테이블
-- =============================================================================

-- -----------------------------------------------------------------------------
-- token_usage 테이블
-- -----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS token_usage (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
    tokens_used INTEGER NOT NULL CHECK (tokens_used > 0),
    action TEXT NOT NULL CHECK (action IN ('generate', 'regenerate', 'edit', 'chat')),
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE token_usage IS '토큰 사용 기록 테이블';
COMMENT ON COLUMN token_usage.action IS '사용 유형: generate, regenerate, edit, chat';
COMMENT ON COLUMN token_usage.metadata IS '추가 정보 (reservation_id, landing_page_id 등)';

-- 인덱스
CREATE INDEX IF NOT EXISTS idx_token_usage_user_id ON token_usage(user_id);
CREATE INDEX IF NOT EXISTS idx_token_usage_created_at ON token_usage(created_at);
CREATE INDEX IF NOT EXISTS idx_token_usage_user_date ON token_usage(user_id, DATE(created_at));

-- RLS
ALTER TABLE token_usage ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own token usage" ON token_usage;
DROP POLICY IF EXISTS "System can insert token usage" ON token_usage;

CREATE POLICY "Users can view own token usage"
    ON token_usage FOR SELECT
    USING (user_id = auth.uid());

-- INSERT는 서버 사이드에서만 (check_and_reserve_tokens, confirm_token_usage 함수 통해)
CREATE POLICY "System can insert token usage"
    ON token_usage FOR INSERT
    WITH CHECK (user_id = auth.uid());

-- -----------------------------------------------------------------------------
-- token_reservations 테이블 (v2 신규)
-- -----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS token_reservations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
    estimated_tokens INTEGER NOT NULL CHECK (estimated_tokens > 0),
    actual_tokens INTEGER,
    status TEXT NOT NULL DEFAULT 'reserved' CHECK (status IN ('reserved', 'confirmed', 'cancelled', 'expired')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    confirmed_at TIMESTAMPTZ
);

COMMENT ON TABLE token_reservations IS '토큰 예약 테이블 (2-Phase 토큰 관리)';
COMMENT ON COLUMN token_reservations.estimated_tokens IS '예상 사용 토큰';
COMMENT ON COLUMN token_reservations.actual_tokens IS '실제 사용 토큰 (확정 후)';
COMMENT ON COLUMN token_reservations.status IS '상태: reserved, confirmed, cancelled, expired';

-- 인덱스
CREATE INDEX IF NOT EXISTS idx_token_reservations_user_id ON token_reservations(user_id);
CREATE INDEX IF NOT EXISTS idx_token_reservations_status ON token_reservations(status);
CREATE INDEX IF NOT EXISTS idx_token_reservations_created_at ON token_reservations(created_at);
CREATE INDEX IF NOT EXISTS idx_token_reservations_user_pending ON token_reservations(user_id, status)
    WHERE status = 'reserved';

-- RLS
ALTER TABLE token_reservations ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own reservations" ON token_reservations;

CREATE POLICY "Users can view own reservations"
    ON token_reservations FOR SELECT
    USING (user_id = auth.uid());

-- INSERT/UPDATE는 서버 사이드 함수에서만 (SECURITY DEFINER)
```

### 2.7 06_auth_tables.sql

```sql
-- =============================================================================
-- 파일: 06_auth_tables.sql
-- 설명: refresh_tokens, user_sessions 테이블 (v2 신규)
-- =============================================================================

-- -----------------------------------------------------------------------------
-- refresh_tokens 테이블 (Token Rotation)
-- -----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS refresh_tokens (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
    token_hash TEXT NOT NULL,
    revoked BOOLEAN NOT NULL DEFAULT FALSE,
    revoked_at TIMESTAMPTZ,
    expires_at TIMESTAMPTZ NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    CONSTRAINT unique_token_hash UNIQUE (token_hash)
);

COMMENT ON TABLE refresh_tokens IS 'Refresh Token 관리 테이블 (v2)';
COMMENT ON COLUMN refresh_tokens.token_hash IS '토큰 해시 (SHA-256)';
COMMENT ON COLUMN refresh_tokens.revoked IS '폐기 여부';
COMMENT ON COLUMN refresh_tokens.expires_at IS '만료 시간 (7일)';

-- 인덱스
CREATE INDEX IF NOT EXISTS idx_refresh_tokens_user_id ON refresh_tokens(user_id);
CREATE INDEX IF NOT EXISTS idx_refresh_tokens_token_hash ON refresh_tokens(token_hash);
CREATE INDEX IF NOT EXISTS idx_refresh_tokens_expires_at ON refresh_tokens(expires_at);
CREATE INDEX IF NOT EXISTS idx_refresh_tokens_user_active ON refresh_tokens(user_id, revoked)
    WHERE revoked = FALSE;

-- RLS (서버 사이드에서만 접근)
ALTER TABLE refresh_tokens ENABLE ROW LEVEL SECURITY;

-- 클라이언트 직접 접근 불가

-- -----------------------------------------------------------------------------
-- user_sessions 테이블 (세션 관리)
-- -----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS user_sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
    ip_address INET,
    user_agent TEXT,
    invalidated_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE user_sessions IS '사용자 세션 관리 테이블 (v2)';
COMMENT ON COLUMN user_sessions.invalidated_at IS '무효화 시간 (NULL이면 활성)';

-- 인덱스
CREATE INDEX IF NOT EXISTS idx_user_sessions_user_id ON user_sessions(user_id);
CREATE INDEX IF NOT EXISTS idx_user_sessions_user_active ON user_sessions(user_id, invalidated_at)
    WHERE invalidated_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_user_sessions_created_at ON user_sessions(created_at);

-- RLS
ALTER TABLE user_sessions ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own sessions" ON user_sessions;

CREATE POLICY "Users can view own sessions"
    ON user_sessions FOR SELECT
    USING (user_id = auth.uid());
```

### 2.8 07_audit_tables.sql

```sql
-- =============================================================================
-- 파일: 07_audit_tables.sql
-- 설명: audit_logs, rate_limits 테이블 (v2 신규)
-- =============================================================================

-- -----------------------------------------------------------------------------
-- audit_logs 테이블
-- -----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS audit_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES profiles(id) ON DELETE SET NULL,
    action TEXT NOT NULL,
    details JSONB DEFAULT '{}',
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE audit_logs IS '감사 로그 테이블 (v2)';
COMMENT ON COLUMN audit_logs.action IS '
감사 대상 액션:
- signup: 회원가입
- login: 로그인
- logout: 로그아웃
- password_change: 비밀번호 변경
- profile_update: 프로필 수정
- approval_change: 승인 상태 변경
- sessions_invalidated: 세션 무효화
- token_reuse_detected: 토큰 재사용 감지
- landing_page_created: LP 생성
- landing_page_updated: LP 수정
- landing_page_deleted: LP 삭제 (soft)
- landing_page_restored: LP 복구
- landing_page_permanently_deleted: LP 영구 삭제
- ai_generation: AI 생성 요청
- rate_limit_exceeded: Rate Limit 초과
- cors_blocked: CORS 차단
- error: 에러 발생
';

-- 인덱스
CREATE INDEX IF NOT EXISTS idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_action ON audit_logs(action);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON audit_logs(created_at);
CREATE INDEX IF NOT EXISTS idx_audit_logs_ip_address ON audit_logs(ip_address);

-- RLS
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own audit logs" ON audit_logs;
DROP POLICY IF EXISTS "Admins can view all audit logs" ON audit_logs;

-- 일반 사용자: 자신의 로그만 조회
CREATE POLICY "Users can view own audit logs"
    ON audit_logs FOR SELECT
    USING (user_id = auth.uid());

-- 관리자: 모든 로그 조회
CREATE POLICY "Admins can view all audit logs"
    ON audit_logs FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM profiles
            WHERE id = auth.uid()
            AND tier = 'ENTERPRISE'
            AND deleted_at IS NULL
        )
    );

-- INSERT는 서버 사이드에서만

-- -----------------------------------------------------------------------------
-- rate_limits 테이블
-- -----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS rate_limits (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL,
    endpoint TEXT NOT NULL,
    request_count INTEGER NOT NULL DEFAULT 1,
    window_start TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    CONSTRAINT unique_rate_limit UNIQUE (identifier, endpoint, window_start)
);

COMMENT ON TABLE rate_limits IS 'Rate Limit 카운터 테이블 (v2)';
COMMENT ON COLUMN rate_limits.identifier IS 'IP 주소 또는 user_id';
COMMENT ON COLUMN rate_limits.endpoint IS 'API 엔드포인트';
COMMENT ON COLUMN rate_limits.window_start IS '윈도우 시작 시간';

-- 인덱스
CREATE INDEX IF NOT EXISTS idx_rate_limits_identifier ON rate_limits(identifier);
CREATE INDEX IF NOT EXISTS idx_rate_limits_endpoint ON rate_limits(endpoint);
CREATE INDEX IF NOT EXISTS idx_rate_limits_window_start ON rate_limits(window_start);
CREATE INDEX IF NOT EXISTS idx_rate_limits_lookup ON rate_limits(identifier, endpoint, window_start);

-- RLS (서버 사이드에서만)
ALTER TABLE rate_limits ENABLE ROW LEVEL SECURITY;
```

### 2.9 08_triggers.sql

```sql
-- =============================================================================
-- 파일: 08_triggers.sql
-- 설명: 트리거 설정 (v2)
-- =============================================================================

-- -----------------------------------------------------------------------------
-- 세션 무효화 트리거 (승인 상태 변경 시)
-- -----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION invalidate_user_sessions()
RETURNS TRIGGER AS $$
BEGIN
    -- is_approved가 변경된 경우
    IF OLD.is_approved IS DISTINCT FROM NEW.is_approved THEN
        -- 모든 Refresh Token 폐기
        UPDATE refresh_tokens
        SET revoked = TRUE, revoked_at = NOW()
        WHERE user_id = NEW.id AND revoked = FALSE;

        -- 세션 무효화
        UPDATE user_sessions
        SET invalidated_at = NOW()
        WHERE user_id = NEW.id AND invalidated_at IS NULL;

        -- 감사 로그
        INSERT INTO audit_logs (user_id, action, details)
        VALUES (
            NEW.id,
            'sessions_invalidated',
            jsonb_build_object(
                'reason', 'approval_status_changed',
                'old_status', OLD.is_approved,
                'new_status', NEW.is_approved
            )
        );
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_approval_change ON profiles;
CREATE TRIGGER on_approval_change
    AFTER UPDATE ON profiles
    FOR EACH ROW
    EXECUTE FUNCTION invalidate_user_sessions();

-- -----------------------------------------------------------------------------
-- 랜딩페이지 생성 시 감사 로그
-- -----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION log_landing_page_creation()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO audit_logs (user_id, action, details)
    VALUES (
        NEW.user_id,
        'landing_page_created',
        jsonb_build_object(
            'landing_page_id', NEW.id,
            'title', NEW.title
        )
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_landing_page_created ON landing_pages;
CREATE TRIGGER on_landing_page_created
    AFTER INSERT ON landing_pages
    FOR EACH ROW
    EXECUTE FUNCTION log_landing_page_creation();

-- -----------------------------------------------------------------------------
-- 랜딩페이지 Soft Delete 시 감사 로그
-- -----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION log_landing_page_deletion()
RETURNS TRIGGER AS $$
BEGIN
    -- deleted_at이 NULL에서 값이 설정된 경우 (Soft Delete)
    IF OLD.deleted_at IS NULL AND NEW.deleted_at IS NOT NULL THEN
        INSERT INTO audit_logs (user_id, action, details)
        VALUES (
            NEW.user_id,
            'landing_page_deleted',
            jsonb_build_object(
                'landing_page_id', NEW.id,
                'title', NEW.title,
                'deleted_at', NEW.deleted_at
            )
        );
    END IF;

    -- deleted_at이 값에서 NULL로 변경된 경우 (복구)
    IF OLD.deleted_at IS NOT NULL AND NEW.deleted_at IS NULL THEN
        INSERT INTO audit_logs (user_id, action, details)
        VALUES (
            NEW.user_id,
            'landing_page_restored',
            jsonb_build_object(
                'landing_page_id', NEW.id,
                'title', NEW.title
            )
        );
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_landing_page_soft_delete ON landing_pages;
CREATE TRIGGER on_landing_page_soft_delete
    AFTER UPDATE OF deleted_at ON landing_pages
    FOR EACH ROW
    EXECUTE FUNCTION log_landing_page_deletion();
```

### 2.10 09_seed_data.sql

```sql
-- =============================================================================
-- 파일: 09_seed_data.sql
-- 설명: 시드 데이터 (개발/테스트 환경용)
-- 주의: 프로덕션에서 실행 금지!
-- =============================================================================

-- 실행 확인 (개발 환경에서만)
DO $$
BEGIN
    IF current_database() = 'production' THEN
        RAISE EXCEPTION '프로덕션 데이터베이스에서는 시드 데이터를 실행할 수 없습니다!';
    END IF;
END
$$;

-- -----------------------------------------------------------------------------
-- 테스트 사용자 (auth.users에 직접 삽입은 Supabase Dashboard에서)
-- 아래는 profiles 테이블 시드만 제공
-- -----------------------------------------------------------------------------

-- 참고: 실제 사용자는 Supabase Auth를 통해 생성해야 함
-- 아래는 이미 auth.users에 존재하는 사용자의 프로필 업데이트 예시

-- 관리자 계정 업데이트 (이미 가입된 경우)
-- UPDATE profiles
-- SET tier = 'ENTERPRISE', is_approved = TRUE
-- WHERE email = 'admin@example.com';

-- -----------------------------------------------------------------------------
-- 테스트용 랜딩페이지 (프로필이 존재할 때)
-- -----------------------------------------------------------------------------

-- INSERT INTO landing_pages (user_id, title, content, status, slug)
-- SELECT
--     id,
--     '테스트 랜딩페이지',
--     '{"headline": "테스트 헤드라인", "description": "테스트 설명"}'::JSONB,
--     'draft',
--     'test-landing-page'
-- FROM profiles
-- WHERE email = 'test@example.com'
-- ON CONFLICT (slug) DO NOTHING;

-- -----------------------------------------------------------------------------
-- Q&A 세션 템플릿 질문 정의 (참조용)
-- -----------------------------------------------------------------------------

-- 실제 질문 목록은 프론트엔드 상수로 관리
-- 아래는 참조용 문서

COMMENT ON TABLE qa_sessions IS '
40개 질문 구조 (6 Phase, 18 Step):

Phase 1: 고객 이해 (6개 질문)
  Step 1: 타겟 고객 (Q1-Q3)
  Step 2: 고객 문제 (Q4-Q6)

Phase 2: 제품/서비스 정의 (8개 질문)
  Step 3: 핵심 가치 (Q7-Q9)
  Step 4: 차별화 포인트 (Q10-Q12)
  Step 5: 결과/혜택 (Q13-Q14)

Phase 3: 신뢰 구축 (6개 질문)
  Step 6: 전문성 증명 (Q15-Q17)
  Step 7: 사회적 증거 (Q18-Q20)

Phase 4: 오퍼 설계 (8개 질문)
  Step 8: 가격/패키지 (Q21-Q24)
  Step 9: 보너스/긴급성 (Q25-Q28)

Phase 5: 스토리텔링 (6개 질문)
  Step 10: 브랜드 스토리 (Q29-Q31)
  Step 11: 변화 스토리 (Q32-Q34)

Phase 6: CTA 최적화 (6개 질문)
  Step 12: 행동 유도 (Q35-Q37)
  Step 13: 반대 극복 (Q38-Q40)
';

-- -----------------------------------------------------------------------------
-- 정리 스케줄 (pg_cron - Supabase Pro)
-- -----------------------------------------------------------------------------

-- 만료된 토큰 예약 정리 (매 분)
-- SELECT cron.schedule(
--     'cleanup-expired-reservations',
--     '* * * * *',
--     'SELECT cleanup_expired_reservations()'
-- );

-- 오래된 Rate Limit 정리 (매 시간)
-- SELECT cron.schedule(
--     'cleanup-old-rate-limits',
--     '0 * * * *',
--     'SELECT cleanup_old_rate_limits()'
-- );

-- 오래된 감사 로그 정리 (매일, 90일 이전)
-- SELECT cron.schedule(
--     'cleanup-old-audit-logs',
--     '0 3 * * *',
--     'DELETE FROM audit_logs WHERE created_at < NOW() - INTERVAL ''90 days'''
-- );

SELECT 'Seed data script completed (development only)' AS result;
```

---

## 3. TypeScript 타입 생성

### 3.1 Supabase CLI로 타입 생성

```bash
# Supabase CLI 설치
npm install -g supabase

# 프로젝트 연결
supabase login
supabase link --project-ref your-project-ref

# 타입 생성
supabase gen types typescript --local > src/types/database.ts
```

### 3.2 생성된 타입 예시

```typescript
// src/types/database.ts (자동 생성됨)
export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export interface Database {
  public: {
    Tables: {
      profiles: {
        Row: {
          id: string
          email: string
          full_name: string
          tier: 'FREE' | 'PRO' | 'ENTERPRISE'
          is_approved: boolean
          agree_marketing: boolean
          deleted_at: string | null
          created_at: string
          updated_at: string
        }
        Insert: {
          id: string
          email: string
          full_name: string
          tier?: 'FREE' | 'PRO' | 'ENTERPRISE'
          is_approved?: boolean
          agree_marketing?: boolean
          deleted_at?: string | null
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          email?: string
          full_name?: string
          tier?: 'FREE' | 'PRO' | 'ENTERPRISE'
          is_approved?: boolean
          agree_marketing?: boolean
          deleted_at?: string | null
          created_at?: string
          updated_at?: string
        }
      }
      landing_pages: {
        Row: {
          id: string
          user_id: string
          qa_session_id: string | null
          title: string
          content: Json
          status: 'draft' | 'published' | 'archived'
          slug: string | null
          published_url: string | null
          deleted_at: string | null
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: string
          user_id: string
          qa_session_id?: string | null
          title: string
          content?: Json
          status?: 'draft' | 'published' | 'archived'
          slug?: string | null
          published_url?: string | null
          deleted_at?: string | null
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          user_id?: string
          qa_session_id?: string | null
          title?: string
          content?: Json
          status?: 'draft' | 'published' | 'archived'
          slug?: string | null
          published_url?: string | null
          deleted_at?: string | null
          created_at?: string
          updated_at?: string
        }
      }
      // ... 나머지 테이블
    }
    Functions: {
      check_rate_limit: {
        Args: {
          p_identifier: string
          p_endpoint: string
          p_limit: number
          p_window_seconds: number
        }
        Returns: Json
      }
      check_and_reserve_tokens: {
        Args: {
          p_user_id: string
          p_estimated_tokens: number
        }
        Returns: Json
      }
      confirm_token_usage: {
        Args: {
          p_reservation_id: string
          p_actual_tokens: number
        }
        Returns: Json
      }
      get_token_usage_summary: {
        Args: {
          p_user_id: string
        }
        Returns: Json
      }
    }
  }
}
```

---

## 4. 마이그레이션 실행 가이드

### 4.1 로컬 개발 환경

```bash
# 1. Supabase CLI 설치
npm install -g supabase

# 2. 로컬 Supabase 시작
supabase start

# 3. 마이그레이션 실행
supabase db push

# 4. 타입 생성
supabase gen types typescript --local > src/types/database.ts
```

### 4.2 프로덕션 환경

```bash
# 1. Supabase 프로젝트 연결
supabase link --project-ref your-project-ref

# 2. 마이그레이션 적용
supabase db push

# 또는 Supabase Dashboard > SQL Editor에서 직접 실행
```

### 4.3 주의사항

```yaml
실행_순서:
  - 반드시 00번부터 순서대로 실행
  - 외래 키 의존성 주의

백업:
  - 프로덕션 적용 전 반드시 백업
  - supabase db dump --file backup.sql

롤백:
  - 각 마이그레이션에 롤백 SQL 준비
  - 문제 발생 시 역순으로 롤백
```

---

## 5. 구현 체크리스트

### 5.1 테이블 생성
- [ ] profiles (deleted_at 포함)
- [ ] landing_pages (deleted_at 포함)
- [ ] qa_sessions (deleted_at 포함)
- [ ] token_usage
- [ ] token_reservations (신규)
- [ ] refresh_tokens (신규)
- [ ] user_sessions (신규)
- [ ] audit_logs (신규)
- [ ] rate_limits (신규)

### 5.2 인덱스
- [ ] deleted_at 부분 인덱스
- [ ] 복합 인덱스 (user_id + deleted_at)
- [ ] token_hash 인덱스
- [ ] rate_limits lookup 인덱스

### 5.3 RLS 정책
- [ ] profiles 정책
- [ ] landing_pages 정책 (활성/삭제 분리)
- [ ] qa_sessions 정책
- [ ] 신규 테이블 정책

### 5.4 함수
- [ ] check_rate_limit
- [ ] check_and_reserve_tokens
- [ ] confirm_token_usage
- [ ] cancel_token_reservation
- [ ] get_token_usage_summary
- [ ] cleanup 함수들

### 5.5 트리거
- [ ] updated_at 자동 갱신
- [ ] 세션 무효화 (승인 상태 변경)
- [ ] 감사 로그 자동 기록

---

**이전 문서: [01_프로젝트_구조.md](./01_프로젝트_구조.md)**
**다음 문서: [03_API_명세.md](./03_API_명세.md)**
