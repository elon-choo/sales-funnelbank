# 인증 시스템 PRD

## 문서 정보

| 항목 | 내용 |
|------|------|
| 버전 | PRD v1.0 |
| 작성일 | 2025-01-15 |
| 관련 기획 | 기획_v2/05_API_설계_v2.md, 기획_v2/07_보안_아키텍처_v2.md |

---

## 1. 개요

### 1.1 인증 아키텍처

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│   Client    │────>│  Next.js    │────>│  Supabase   │
│  (Browser)  │     │  API Routes │     │    Auth     │
└─────────────┘     └─────────────┘     └─────────────┘
      │                    │                   │
      │  Access Token      │                   │
      │  (Memory)          │                   │
      │                    │                   │
      │  Refresh Token     │                   │
      │  (HttpOnly Cookie) │                   │
      └────────────────────┴───────────────────┘
```

### 1.2 토큰 전략 (v2)

| 토큰 | 저장 위치 | 만료 시간 | 용도 |
|------|----------|----------|------|
| Access Token | 메모리 (Zustand) | 15분 | API 인증 |
| Refresh Token | HttpOnly Cookie | 7일 | Access Token 갱신 |

---

## 2. 파일 구조

```
src/
├── lib/
│   ├── supabase/
│   │   ├── client.ts         # 클라이언트용
│   │   ├── server.ts         # 서버용 (API Routes)
│   │   └── admin.ts          # Admin 작업용
│   │
│   ├── auth/
│   │   ├── tokens.ts         # 토큰 생성/검증
│   │   ├── session.ts        # 세션 관리
│   │   └── middleware.ts     # 인증 미들웨어
│   │
│   └── security/
│       └── crypto.ts         # 암호화 유틸
│
├── app/
│   └── api/
│       └── auth/
│           ├── signup/route.ts
│           ├── login/route.ts
│           ├── logout/route.ts
│           └── refresh/route.ts
│
├── hooks/
│   └── useAuth.ts
│
├── stores/
│   └── authStore.ts
│
└── types/
    └── auth.ts
```

---

## 3. 상세 구현

### 3.1 타입 정의

```typescript
// src/types/auth.ts

export type UserTier = 'FREE' | 'PRO' | 'ENTERPRISE';

export interface User {
  id: string;
  email: string;
  fullName: string;
  tier: UserTier;
  isApproved: boolean;
  createdAt: string;
}

export interface AuthState {
  user: User | null;
  accessToken: string | null;
  isLoading: boolean;
  isAuthenticated: boolean;
}

export interface LoginRequest {
  email: string;
  password: string;
}

export interface SignupRequest {
  email: string;
  password: string;
  fullName: string;
  agreeTerms: boolean;
  agreePrivacy: boolean;
  agreeMarketing?: boolean;
}

export interface TokenPayload {
  sub: string;
  email: string;
  tier: UserTier;
  exp: number;
  iat: number;
}

export interface RefreshTokenRecord {
  id: string;
  user_id: string;
  token_hash: string;
  revoked: boolean;
  revoked_at: string | null;
  expires_at: string;
  created_at: string;
}
```

### 3.2 암호화 유틸리티

```typescript
// src/lib/security/crypto.ts

import crypto from 'crypto';

/**
 * 보안 토큰 생성 (Base64 URL-safe)
 */
export function generateSecureToken(length: number = 64): string {
  return crypto.randomBytes(length).toString('base64url');
}

/**
 * 토큰 해시 생성 (SHA-256)
 * - 원본 토큰은 저장하지 않고 해시만 저장
 */
export async function hashToken(token: string): Promise<string> {
  const encoder = new TextEncoder();
  const data = encoder.encode(token);
  const hashBuffer = await crypto.subtle.digest('SHA-256', data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
}

/**
 * 에러 참조 ID 생성
 */
export function generateErrorReference(): string {
  const timestamp = new Date().toISOString().replace(/[-:T.Z]/g, '').slice(0, 14);
  const random = crypto.randomBytes(2).toString('hex').toUpperCase();
  return `ERR-${timestamp}-${random}`;
}
```

### 3.3 Supabase 클라이언트 설정

```typescript
// src/lib/supabase/client.ts

import { createBrowserClient } from '@supabase/ssr';
import type { Database } from '@/types/database';

export function createClient() {
  return createBrowserClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}
```

```typescript
// src/lib/supabase/server.ts

import { createServerClient, type CookieOptions } from '@supabase/ssr';
import { cookies } from 'next/headers';
import type { Database } from '@/types/database';

export function createServerSupabaseClient() {
  const cookieStore = cookies();

  return createServerClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: CookieOptions) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: CookieOptions) {
          cookieStore.delete({ name, ...options });
        },
      },
    }
  );
}
```

```typescript
// src/lib/supabase/admin.ts

import { createClient } from '@supabase/supabase-js';
import type { Database } from '@/types/database';

// Service Role Key 사용 - 서버 사이드에서만!
export function createAdminClient() {
  return createClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!,
    {
      auth: {
        autoRefreshToken: false,
        persistSession: false,
      },
    }
  );
}
```

### 3.4 인증 미들웨어

```typescript
// src/lib/auth/middleware.ts

import { NextRequest, NextResponse } from 'next/server';
import { createAdminClient } from '@/lib/supabase/admin';

interface AuthResult {
  userId: string;
  email: string;
  tier: string;
}

/**
 * API Route에서 인증 확인
 */
export async function authenticateRequest(
  request: NextRequest
): Promise<AuthResult | null> {
  const authHeader = request.headers.get('authorization');

  if (!authHeader?.startsWith('Bearer ')) {
    return null;
  }

  const token = authHeader.substring(7);

  try {
    const supabase = createAdminClient();

    const { data: { user }, error } = await supabase.auth.getUser(token);

    if (error || !user) {
      return null;
    }

    // 프로필 조회 (deleted_at 확인)
    const { data: profile } = await supabase
      .from('profiles')
      .select('tier, is_approved, deleted_at')
      .eq('id', user.id)
      .single();

    if (!profile || profile.deleted_at || !profile.is_approved) {
      return null;
    }

    return {
      userId: user.id,
      email: user.email!,
      tier: profile.tier,
    };
  } catch (error) {
    console.error('Authentication error:', error);
    return null;
  }
}

/**
 * 인증 필수 API Route Wrapper
 */
export function withAuth(
  handler: (
    request: NextRequest,
    auth: AuthResult
  ) => Promise<NextResponse>
) {
  return async (request: NextRequest): Promise<NextResponse> => {
    const auth = await authenticateRequest(request);

    if (!auth) {
      return NextResponse.json(
        {
          success: false,
          error: {
            code: 'AUTH_003',
            message: '세션이 만료되었습니다',
          },
        },
        { status: 401 }
      );
    }

    return handler(request, auth);
  };
}
```

### 3.5 회원가입 API

```typescript
// src/app/api/auth/signup/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { createAdminClient } from '@/lib/supabase/admin';
import { generateErrorReference } from '@/lib/security/crypto';

// Zod 스키마
const signupSchema = z.object({
  email: z
    .string()
    .email('유효한 이메일을 입력해주세요')
    .max(255),
  password: z
    .string()
    .min(8, '비밀번호는 8자 이상이어야 합니다')
    .max(72, '비밀번호는 72자 이하여야 합니다')
    .regex(/[a-zA-Z]/, '영문을 포함해야 합니다')
    .regex(/[0-9]/, '숫자를 포함해야 합니다'),
  fullName: z
    .string()
    .min(2, '이름은 2자 이상이어야 합니다')
    .max(50, '이름은 50자 이하여야 합니다')
    .regex(/^[가-힣a-zA-Z\s]+$/, '이름에는 한글, 영문, 공백만 사용 가능합니다'),
  agreeTerms: z.literal(true, {
    errorMap: () => ({ message: '서비스 이용약관에 동의해주세요' }),
  }),
  agreePrivacy: z.literal(true, {
    errorMap: () => ({ message: '개인정보 처리방침에 동의해주세요' }),
  }),
  agreeMarketing: z.boolean().optional().default(false),
});

export async function POST(request: NextRequest) {
  try {
    // 1. 요청 본문 파싱 및 검증
    const body = await request.json();
    const validationResult = signupSchema.safeParse(body);

    if (!validationResult.success) {
      return NextResponse.json(
        {
          success: false,
          error: {
            code: 'GEN_002',
            message: validationResult.error.errors[0].message,
          },
        },
        { status: 400 }
      );
    }

    const { email, password, fullName, agreeMarketing } = validationResult.data;
    const supabase = createAdminClient();

    // 2. 이메일 중복 확인
    const { data: existingUser } = await supabase
      .from('profiles')
      .select('id, deleted_at')
      .eq('email', email)
      .single();

    if (existingUser) {
      // 탈퇴한 계정인 경우
      if (existingUser.deleted_at) {
        return NextResponse.json(
          {
            success: false,
            error: {
              code: 'AUTH_006',
              message: '탈퇴한 계정입니다. 재가입은 30일 후 가능합니다',
            },
          },
          { status: 409 }
        );
      }

      return NextResponse.json(
        {
          success: false,
          error: {
            code: 'AUTH_005',
            message: '이미 가입된 이메일입니다',
          },
        },
        { status: 409 }
      );
    }

    // 3. Supabase Auth 회원가입
    const { data: authData, error: authError } = await supabase.auth.admin.createUser({
      email,
      password,
      email_confirm: true, // 이메일 인증 필요
    });

    if (authError) {
      console.error('Signup auth error:', authError);
      return NextResponse.json(
        {
          success: false,
          error: {
            code: 'GEN_001',
            message: '회원가입 처리 중 문제가 발생했습니다',
            reference: generateErrorReference(),
          },
        },
        { status: 500 }
      );
    }

    // 4. 프로필 생성
    const { error: profileError } = await supabase.from('profiles').insert({
      id: authData.user.id,
      email,
      full_name: fullName,
      tier: 'FREE',
      is_approved: false, // 수동 승인 필요
      agree_marketing: agreeMarketing,
    });

    if (profileError) {
      // 롤백: Auth 사용자 삭제
      await supabase.auth.admin.deleteUser(authData.user.id);

      console.error('Signup profile error:', profileError);
      return NextResponse.json(
        {
          success: false,
          error: {
            code: 'GEN_001',
            message: '회원가입 처리 중 문제가 발생했습니다',
            reference: generateErrorReference(),
          },
        },
        { status: 500 }
      );
    }

    // 5. 감사 로그
    await supabase.from('audit_logs').insert({
      user_id: authData.user.id,
      action: 'signup',
      details: { email, agree_marketing: agreeMarketing },
      ip_address: request.headers.get('x-forwarded-for')?.split(',')[0] || null,
      user_agent: request.headers.get('user-agent'),
    });

    return NextResponse.json(
      {
        success: true,
        data: {
          message: '회원가입이 완료되었습니다. 관리자 승인 후 이용 가능합니다.',
        },
      },
      { status: 201 }
    );
  } catch (error) {
    console.error('Signup error:', error);
    return NextResponse.json(
      {
        success: false,
        error: {
          code: 'GEN_001',
          message: '서비스 연결에 문제가 있습니다',
          reference: generateErrorReference(),
        },
      },
      { status: 500 }
    );
  }
}
```

### 3.6 로그인 API

```typescript
// src/app/api/auth/login/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { createAdminClient } from '@/lib/supabase/admin';
import { generateSecureToken, hashToken, generateErrorReference } from '@/lib/security/crypto';

const loginSchema = z.object({
  email: z.string().email(),
  password: z.string().min(1),
});

export async function POST(request: NextRequest) {
  try {
    // 1. 요청 검증
    const body = await request.json();
    const validationResult = loginSchema.safeParse(body);

    if (!validationResult.success) {
      return NextResponse.json(
        {
          success: false,
          error: {
            code: 'AUTH_001',
            message: '이메일 또는 비밀번호를 확인해주세요',
          },
        },
        { status: 401 }
      );
    }

    const { email, password } = validationResult.data;
    const supabase = createAdminClient();

    // 2. Supabase Auth 로그인
    const { data: authData, error: authError } = await supabase.auth.signInWithPassword({
      email,
      password,
    });

    if (authError) {
      // 감사 로그 (실패)
      await supabase.from('audit_logs').insert({
        action: 'login_failed',
        details: { email, reason: 'invalid_credentials' },
        ip_address: request.headers.get('x-forwarded-for')?.split(',')[0] || null,
        user_agent: request.headers.get('user-agent'),
      });

      return NextResponse.json(
        {
          success: false,
          error: {
            code: 'AUTH_001',
            message: '이메일 또는 비밀번호를 확인해주세요',
          },
        },
        { status: 401 }
      );
    }

    // 3. 프로필 확인 (승인 상태, 삭제 여부)
    const { data: profile } = await supabase
      .from('profiles')
      .select('is_approved, tier, full_name, deleted_at')
      .eq('id', authData.user.id)
      .single();

    // 탈퇴한 계정
    if (profile?.deleted_at) {
      return NextResponse.json(
        {
          success: false,
          error: {
            code: 'AUTH_006',
            message: '탈퇴한 계정입니다',
          },
        },
        { status: 403 }
      );
    }

    // 미승인 계정
    if (!profile?.is_approved) {
      return NextResponse.json(
        {
          success: false,
          error: {
            code: 'AUTH_002',
            message: '관리자 승인 대기 중입니다',
          },
        },
        { status: 403 }
      );
    }

    // 4. Refresh Token 생성 및 저장
    const refreshToken = generateSecureToken(64);
    const tokenHash = await hashToken(refreshToken);
    const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7일

    await supabase.from('refresh_tokens').insert({
      user_id: authData.user.id,
      token_hash: tokenHash,
      expires_at: expiresAt.toISOString(),
      revoked: false,
    });

    // 5. 세션 기록
    await supabase.from('user_sessions').insert({
      user_id: authData.user.id,
      ip_address: request.headers.get('x-forwarded-for')?.split(',')[0] || null,
      user_agent: request.headers.get('user-agent'),
    });

    // 6. 감사 로그
    await supabase.from('audit_logs').insert({
      user_id: authData.user.id,
      action: 'login',
      details: {},
      ip_address: request.headers.get('x-forwarded-for')?.split(',')[0] || null,
      user_agent: request.headers.get('user-agent'),
    });

    // 7. 응답 생성
    const response = NextResponse.json(
      {
        success: true,
        data: {
          accessToken: authData.session.access_token,
          expiresIn: 900, // 15분
          user: {
            id: authData.user.id,
            email: authData.user.email,
            fullName: profile.full_name,
            tier: profile.tier,
          },
        },
      },
      { status: 200 }
    );

    // 8. HttpOnly Cookie 설정
    response.cookies.set('refresh_token', refreshToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      path: '/api/auth',
      maxAge: 7 * 24 * 60 * 60, // 7일 (초)
    });

    return response;
  } catch (error) {
    console.error('Login error:', error);
    return NextResponse.json(
      {
        success: false,
        error: {
          code: 'GEN_001',
          message: '서비스 연결에 문제가 있습니다',
          reference: generateErrorReference(),
        },
      },
      { status: 500 }
    );
  }
}
```

### 3.7 토큰 갱신 API (Refresh Token Rotation)

```typescript
// src/app/api/auth/refresh/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { createAdminClient } from '@/lib/supabase/admin';
import { generateSecureToken, hashToken, generateErrorReference } from '@/lib/security/crypto';

export async function POST(request: NextRequest) {
  try {
    // 1. Cookie에서 Refresh Token 추출
    const refreshToken = request.cookies.get('refresh_token')?.value;

    if (!refreshToken) {
      return NextResponse.json(
        {
          success: false,
          error: {
            code: 'AUTH_003',
            message: '세션이 만료되었습니다',
          },
        },
        { status: 401 }
      );
    }

    const tokenHash = await hashToken(refreshToken);
    const supabase = createAdminClient();

    // 2. 토큰 조회
    const { data: tokenRecord } = await supabase
      .from('refresh_tokens')
      .select('*')
      .eq('token_hash', tokenHash)
      .single();

    if (!tokenRecord) {
      // Cookie 삭제
      const response = NextResponse.json(
        {
          success: false,
          error: {
            code: 'AUTH_003',
            message: '세션이 만료되었습니다',
          },
        },
        { status: 401 }
      );
      response.cookies.delete('refresh_token');
      return response;
    }

    // 3. 토큰 재사용 감지 (중요!)
    if (tokenRecord.revoked) {
      // 보안 위협: 해당 사용자의 모든 토큰 폐기
      await supabase
        .from('refresh_tokens')
        .update({ revoked: true, revoked_at: new Date().toISOString() })
        .eq('user_id', tokenRecord.user_id);

      // 모든 세션 무효화
      await supabase
        .from('user_sessions')
        .update({ invalidated_at: new Date().toISOString() })
        .eq('user_id', tokenRecord.user_id)
        .is('invalidated_at', null);

      // 감사 로그 (CRITICAL)
      await supabase.from('audit_logs').insert({
        user_id: tokenRecord.user_id,
        action: 'token_reuse_detected',
        details: {
          severity: 'critical',
          token_id: tokenRecord.id,
          ip_address: request.headers.get('x-forwarded-for')?.split(',')[0],
        },
        ip_address: request.headers.get('x-forwarded-for')?.split(',')[0] || null,
        user_agent: request.headers.get('user-agent'),
      });

      // Cookie 삭제
      const response = NextResponse.json(
        {
          success: false,
          error: {
            code: 'AUTH_004',
            message: '보안 문제가 감지되었습니다. 다시 로그인해주세요',
          },
        },
        { status: 401 }
      );
      response.cookies.delete('refresh_token');
      return response;
    }

    // 4. 만료 확인
    if (new Date(tokenRecord.expires_at) < new Date()) {
      const response = NextResponse.json(
        {
          success: false,
          error: {
            code: 'AUTH_003',
            message: '세션이 만료되었습니다',
          },
        },
        { status: 401 }
      );
      response.cookies.delete('refresh_token');
      return response;
    }

    // 5. 기존 토큰 폐기 (Rotation)
    await supabase
      .from('refresh_tokens')
      .update({ revoked: true, revoked_at: new Date().toISOString() })
      .eq('id', tokenRecord.id);

    // 6. 새 Refresh Token 발급
    const newRefreshToken = generateSecureToken(64);
    const newTokenHash = await hashToken(newRefreshToken);
    const newExpiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);

    await supabase.from('refresh_tokens').insert({
      user_id: tokenRecord.user_id,
      token_hash: newTokenHash,
      expires_at: newExpiresAt.toISOString(),
      revoked: false,
    });

    // 7. 새 Access Token 발급
    // Supabase Auth의 세션 갱신 사용
    const { data: sessionData, error: sessionError } = await supabase.auth.admin.getUserById(
      tokenRecord.user_id
    );

    if (sessionError || !sessionData.user) {
      throw new Error('Failed to get user');
    }

    // Custom Access Token 생성 (또는 Supabase 세션 사용)
    const { data: newSession } = await supabase.auth.admin.generateLink({
      type: 'magiclink',
      email: sessionData.user.email!,
    });

    // 8. 응답
    const response = NextResponse.json(
      {
        success: true,
        data: {
          accessToken: newSession.properties?.access_token || '',
          expiresIn: 900,
        },
      },
      { status: 200 }
    );

    // 새 Refresh Token Cookie 설정
    response.cookies.set('refresh_token', newRefreshToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      path: '/api/auth',
      maxAge: 7 * 24 * 60 * 60,
    });

    return response;
  } catch (error) {
    console.error('Token refresh error:', error);
    return NextResponse.json(
      {
        success: false,
        error: {
          code: 'GEN_001',
          message: '서비스 연결에 문제가 있습니다',
          reference: generateErrorReference(),
        },
      },
      { status: 500 }
    );
  }
}
```

### 3.8 로그아웃 API

```typescript
// src/app/api/auth/logout/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { createAdminClient } from '@/lib/supabase/admin';
import { hashToken, generateErrorReference } from '@/lib/security/crypto';
import { authenticateRequest } from '@/lib/auth/middleware';

export async function POST(request: NextRequest) {
  try {
    const supabase = createAdminClient();

    // 1. 인증 확인 (선택적 - 로그아웃은 토큰 없어도 가능)
    const auth = await authenticateRequest(request);

    // 2. Refresh Token 폐기
    const refreshToken = request.cookies.get('refresh_token')?.value;

    if (refreshToken) {
      const tokenHash = await hashToken(refreshToken);

      await supabase
        .from('refresh_tokens')
        .update({ revoked: true, revoked_at: new Date().toISOString() })
        .eq('token_hash', tokenHash);
    }

    // 3. 현재 세션 무효화
    if (auth) {
      // 현재 세션만 무효화 (모든 세션이 아님)
      await supabase
        .from('user_sessions')
        .update({ invalidated_at: new Date().toISOString() })
        .eq('user_id', auth.userId)
        .is('invalidated_at', null)
        .order('created_at', { ascending: false })
        .limit(1);

      // 감사 로그
      await supabase.from('audit_logs').insert({
        user_id: auth.userId,
        action: 'logout',
        details: {},
        ip_address: request.headers.get('x-forwarded-for')?.split(',')[0] || null,
        user_agent: request.headers.get('user-agent'),
      });
    }

    // 4. 응답 (Cookie 삭제)
    const response = NextResponse.json(
      {
        success: true,
        data: {
          message: '로그아웃되었습니다',
        },
      },
      { status: 200 }
    );

    // HttpOnly Cookie 삭제
    response.cookies.set('refresh_token', '', {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      path: '/api/auth',
      maxAge: 0, // 즉시 만료
    });

    return response;
  } catch (error) {
    console.error('Logout error:', error);
    return NextResponse.json(
      {
        success: false,
        error: {
          code: 'GEN_001',
          message: '서비스 연결에 문제가 있습니다',
          reference: generateErrorReference(),
        },
      },
      { status: 500 }
    );
  }
}
```

### 3.9 Auth Store (Zustand)

```typescript
// src/stores/authStore.ts

import { create } from 'zustand';
import type { User, AuthState } from '@/types/auth';

interface AuthStore extends AuthState {
  // Actions
  setUser: (user: User | null) => void;
  setAccessToken: (token: string | null) => void;
  setLoading: (loading: boolean) => void;
  login: (email: string, password: string) => Promise<boolean>;
  logout: () => Promise<void>;
  refreshToken: () => Promise<boolean>;
  initialize: () => Promise<void>;
}

export const useAuthStore = create<AuthStore>((set, get) => ({
  // Initial State
  user: null,
  accessToken: null,
  isLoading: true,
  isAuthenticated: false,

  // Setters
  setUser: (user) => set({ user, isAuthenticated: !!user }),
  setAccessToken: (accessToken) => set({ accessToken }),
  setLoading: (isLoading) => set({ isLoading }),

  // Login
  login: async (email, password) => {
    try {
      set({ isLoading: true });

      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password }),
        credentials: 'include', // Cookie 포함
      });

      const data = await response.json();

      if (!data.success) {
        throw new Error(data.error.message);
      }

      set({
        user: data.data.user,
        accessToken: data.data.accessToken,
        isAuthenticated: true,
        isLoading: false,
      });

      // 토큰 만료 전 자동 갱신 설정 (14분 후)
      setTimeout(() => {
        get().refreshToken();
      }, (data.data.expiresIn - 60) * 1000);

      return true;
    } catch (error) {
      set({ isLoading: false });
      throw error;
    }
  },

  // Logout
  logout: async () => {
    try {
      await fetch('/api/auth/logout', {
        method: 'POST',
        credentials: 'include',
        headers: {
          'Authorization': `Bearer ${get().accessToken}`,
        },
      });
    } catch (error) {
      console.error('Logout error:', error);
    } finally {
      set({
        user: null,
        accessToken: null,
        isAuthenticated: false,
      });
    }
  },

  // Refresh Token
  refreshToken: async () => {
    try {
      const response = await fetch('/api/auth/refresh', {
        method: 'POST',
        credentials: 'include',
      });

      const data = await response.json();

      if (!data.success) {
        // 갱신 실패 시 로그아웃
        set({
          user: null,
          accessToken: null,
          isAuthenticated: false,
        });
        return false;
      }

      set({ accessToken: data.data.accessToken });

      // 다음 갱신 예약
      setTimeout(() => {
        get().refreshToken();
      }, (data.data.expiresIn - 60) * 1000);

      return true;
    } catch (error) {
      console.error('Token refresh error:', error);
      set({
        user: null,
        accessToken: null,
        isAuthenticated: false,
      });
      return false;
    }
  },

  // Initialize (앱 시작 시)
  initialize: async () => {
    try {
      set({ isLoading: true });

      // Refresh Token으로 세션 복구 시도
      const response = await fetch('/api/auth/refresh', {
        method: 'POST',
        credentials: 'include',
      });

      const data = await response.json();

      if (data.success) {
        // 사용자 정보 조회
        const userResponse = await fetch('/api/auth/me', {
          headers: {
            'Authorization': `Bearer ${data.data.accessToken}`,
          },
        });

        const userData = await userResponse.json();

        if (userData.success) {
          set({
            user: userData.data.user,
            accessToken: data.data.accessToken,
            isAuthenticated: true,
          });

          // 자동 갱신 설정
          setTimeout(() => {
            get().refreshToken();
          }, (data.data.expiresIn - 60) * 1000);
        }
      }
    } catch (error) {
      console.error('Initialize error:', error);
    } finally {
      set({ isLoading: false });
    }
  },
}));
```

### 3.10 useAuth Hook

```typescript
// src/hooks/useAuth.ts

import { useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { useAuthStore } from '@/stores/authStore';

export function useAuth(requireAuth: boolean = true) {
  const router = useRouter();
  const {
    user,
    accessToken,
    isLoading,
    isAuthenticated,
    login,
    logout,
    initialize,
  } = useAuthStore();

  useEffect(() => {
    initialize();
  }, [initialize]);

  useEffect(() => {
    if (!isLoading && requireAuth && !isAuthenticated) {
      router.push('/login');
    }
  }, [isLoading, requireAuth, isAuthenticated, router]);

  return {
    user,
    accessToken,
    isLoading,
    isAuthenticated,
    login,
    logout,
  };
}

// 인증 필요 없는 페이지용
export function usePublicAuth() {
  return useAuth(false);
}
```

---

## 4. 구현 체크리스트

### 4.1 파일 생성

- [ ] `src/types/auth.ts`
- [ ] `src/lib/security/crypto.ts`
- [ ] `src/lib/supabase/client.ts`
- [ ] `src/lib/supabase/server.ts`
- [ ] `src/lib/supabase/admin.ts`
- [ ] `src/lib/auth/middleware.ts`
- [ ] `src/app/api/auth/signup/route.ts`
- [ ] `src/app/api/auth/login/route.ts`
- [ ] `src/app/api/auth/logout/route.ts`
- [ ] `src/app/api/auth/refresh/route.ts`
- [ ] `src/stores/authStore.ts`
- [ ] `src/hooks/useAuth.ts`

### 4.2 기능 구현

- [ ] 회원가입 (이메일 검증 + Zod)
- [ ] 로그인 (HttpOnly Cookie)
- [ ] Refresh Token Rotation
- [ ] 토큰 재사용 감지
- [ ] 로그아웃 (Cookie 삭제)
- [ ] 세션 복구 (initialize)
- [ ] 자동 토큰 갱신

### 4.3 보안 검증

- [ ] Access Token이 localStorage에 저장되지 않는지 확인
- [ ] Refresh Token이 HttpOnly Cookie로만 전송되는지 확인
- [ ] 토큰 재사용 시 모든 세션이 무효화되는지 확인
- [ ] 승인되지 않은 사용자가 로그인 못하는지 확인
- [ ] 탈퇴한 사용자가 로그인 못하는지 확인

---

## 5. 에러 코드 참조

| 코드 | HTTP | 설명 |
|------|------|------|
| AUTH_001 | 401 | 이메일 또는 비밀번호 오류 |
| AUTH_002 | 403 | 관리자 승인 대기 중 |
| AUTH_003 | 401 | 세션 만료 |
| AUTH_004 | 401 | 보안 문제 감지 (토큰 재사용) |
| AUTH_005 | 409 | 이미 가입된 이메일 |
| AUTH_006 | 403 | 탈퇴한 계정 |

---

**이전 문서**: [00_프로젝트_개요.md](./00_프로젝트_개요.md)
**다음 문서**: [02_데이터베이스.md](./02_데이터베이스.md)
